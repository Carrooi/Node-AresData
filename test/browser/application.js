/** Generated by SimQ **/
/** modules **/

// Generated by CoffeeScript 1.6.3
(function() {
  var SUPPORTED, arrayIndexOf, cache, creating, modules, require, resolve, stats;

  if (!this.require) {
    SUPPORTED = ['js', 'json', 'ts', 'coffee', 'eco'];
    modules = {};
    stats = {};
    cache = {};
    creating = [];
    require = function(name, parent) {
      var fullName, m;
      if (parent == null) {
        parent = null;
      }
      fullName = resolve(name, parent);
      if (fullName === null) {
        throw new Error('Module ' + name + ' was not found.');
      }
      if (typeof cache[fullName] === 'undefined') {
        m = {
          exports: {},
          id: fullName,
          filename: fullName,
          loaded: false,
          parent: null,
          children: null
        };
        if (arrayIndexOf(creating, fullName) === -1) {
          creating.push(fullName);
          modules[fullName].apply(window, [m.exports, m]);
          creating.splice(arrayIndexOf(creating, fullName));
          cache[fullName] = m;
        }
        m.loaded = true;
      } else {
        m = cache[fullName];
      }
      if (typeof stats[fullName] === 'undefined') {
        stats[fullName] = {
          atime: null,
          mtime: null,
          ctime: null
        };
      }
      stats[fullName].atime = new Date;
      return m.exports;
    };
    resolve = function(name, parent) {
      var ext, num, part, parts, prev, result, _i, _j, _k, _len, _len1, _len2;
      if (parent == null) {
        parent = null;
      }
      if (parent !== null && name[0] === '.') {
        num = parent.lastIndexOf('/');
        if (num !== -1) {
          parent = parent.substr(0, num);
        }
        name = parent + '/' + name;
        parts = name.split('/');
        result = [];
        prev = null;
        for (_i = 0, _len = parts.length; _i < _len; _i++) {
          part = parts[_i];
          if (part === '.' || part === '') {
            continue;
          } else if (part === '..' && prev) {
            result.pop();
          } else {
            result.push(part);
          }
          prev = part;
        }
        name = result.join('/');
        if (parent[0] === '/') {
          name = '/' + name;
        }
      }
      if (typeof modules[name] !== 'undefined') {
        return name;
      }
      for (_j = 0, _len1 = SUPPORTED.length; _j < _len1; _j++) {
        ext = SUPPORTED[_j];
        if (typeof modules[name + '.' + ext] !== 'undefined') {
          return name + '.' + ext;
        }
      }
      for (_k = 0, _len2 = SUPPORTED.length; _k < _len2; _k++) {
        ext = SUPPORTED[_k];
        if (typeof modules[name + '/index.' + ext] !== 'undefined') {
          return name + '/index.' + ext;
        }
      }
      return null;
    };
    arrayIndexOf = function(array, search) {
      var element, i, _i, _len;
      if (typeof Array.prototype.indexOf !== 'undefined') {
        return array.indexOf(search);
      }
      if (array.length === 0) {
        return -1;
      }
      for (i = _i = 0, _len = array.length; _i < _len; i = ++_i) {
        element = array[i];
        if (element === search) {
          return i;
        }
      }
      return -1;
    };
    this.require = function(name, parent) {
      if (parent == null) {
        parent = null;
      }
      return require(name, parent);
    };
    this.require.simq = true;
    this.require.version = 1;
    this.require.resolve = function(name, parent) {
      if (parent == null) {
        parent = null;
      }
      return resolve(name, parent);
    };
    this.require.define = function(bundleOrName, obj) {
      var m, name, _results;
      if (obj == null) {
        obj = null;
      }
      if (typeof bundleOrName === 'string') {
        return modules[bundleOrName] = obj;
      } else {
        _results = [];
        for (name in bundleOrName) {
          m = bundleOrName[name];
          _results.push(modules[name] = m);
        }
        return _results;
      }
    };
    this.require.release = function() {
      var name, _results;
      _results = [];
      for (name in cache) {
        _results.push(delete cache[name]);
      }
      return _results;
    };
    this.require.getStats = function(name, parent) {
      var fullName;
      if (parent == null) {
        parent = null;
      }
      fullName = resolve(name, parent);
      if (fullName === null) {
        throw new Error('Module ' + name + ' was not found.');
      }
      if (typeof stats[fullName] === 'undefined') {
        stats[fullName] = {
          atime: null,
          mtime: null,
          ctime: null
        };
      }
      return stats[fullName];
    };
    this.require.__setStats = function(bundle) {
      var data, name, _results;
      _results = [];
      for (name in bundle) {
        data = bundle[name];
        _results.push(stats[name] = {
          atime: new Date(data.atime),
          mtime: new Date(data.mtime),
          ctime: new Date(data.ctime)
        });
      }
      return _results;
    };
    this.require.cache = cache;
  }

  return this.require.define;

}).call(this)({
 '/lib/Validators.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/lib/Validators.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Validators.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/lib/Validators.js';
	var __dirname = '/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Validators.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var Validators;
	
	  Validators = (function() {
	    function Validators() {}
	
	    /*
	       Coffeescript implementation of PHP version from David Grudl
	       http://latrine.dgx.cz/jak-overit-platne-ic-a-rodne-cislo
	    */
	
	
	    Validators.companyIdentification = function(identification) {
	      var a, c, i, _i;
	      identification += '';
	      identification = identification.replace(/\s+/g, '');
	      if (identification.match(/^\d{8}$/) === null) {
	        return false;
	      }
	      a = 0;
	      for (i = _i = 0; _i <= 6; i = ++_i) {
	        a += identification.charAt(i) * (8 - i);
	      }
	      a = a % 11;
	      switch (a) {
	        case 0:
	        case 10:
	          c = 1;
	          break;
	        case 1:
	          c = 0;
	          break;
	        default:
	          c = 11 - a;
	      }
	      return parseInt(identification.charAt(7)) === c;
	    };
	
	    return Validators;
	
	  })();
	
	  module.exports = Validators;
	
	}).call(this);
	

}, 'q/q.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'q/q.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'q/q.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'q/q.js';
	var __dirname = 'q';
	var process = {cwd: function() {return '/';}, argv: ['node', 'q/q.js'], env: {}};

	/** code **/
	// vim:ts=4:sts=4:sw=4:
	/*!
	 *
	 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
	 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
	 *
	 * With parts by Tyler Close
	 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
	 * at http://www.opensource.org/licenses/mit-license.html
	 * Forked at ref_send.js version: 2009-05-11
	 *
	 * With parts by Mark Miller
	 * Copyright (C) 2011 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	
	(function (definition) {
	    // Turn off strict mode for this function so we can assign to global.Q
	    /* jshint strict: false */
	
	    // This file will function properly as a <script> tag, or a module
	    // using CommonJS and NodeJS or RequireJS module formats.  In
	    // Common/Node/RequireJS, the module exports the Q API and when
	    // executed as a simple <script>, it creates a Q global instead.
	
	    // Montage Require
	    if (typeof bootstrap === "function") {
	        bootstrap("promise", definition);
	
	    // CommonJS
	    } else if (typeof exports === "object") {
	        module.exports = definition();
	
	    // RequireJS
	    } else if (typeof define === "function" && define.amd) {
	        define(definition);
	
	    // SES (Secure EcmaScript)
	    } else if (typeof ses !== "undefined") {
	        if (!ses.ok()) {
	            return;
	        } else {
	            ses.makeQ = definition;
	        }
	
	    // <script>
	    } else {
	        Q = definition();
	    }
	
	})(function () {
	"use strict";
	
	var hasStacks = false;
	try {
	    throw new Error();
	} catch (e) {
	    hasStacks = !!e.stack;
	}
	
	// All code after this point will be filtered from stack traces reported
	// by Q.
	var qStartingLine = captureLine();
	var qFileName;
	
	// shims
	
	// used for fallback in "allResolved"
	var noop = function () {};
	
	// Use the fastest possible means to execute a task in a future turn
	// of the event loop.
	var nextTick =(function () {
	    // linked list of tasks (single, with head node)
	    var head = {task: void 0, next: null};
	    var tail = head;
	    var flushing = false;
	    var requestTick = void 0;
	    var isNodeJS = false;
	
	    function flush() {
	        /* jshint loopfunc: true */
	
	        while (head.next) {
	            head = head.next;
	            var task = head.task;
	            head.task = void 0;
	            var domain = head.domain;
	
	            if (domain) {
	                head.domain = void 0;
	                domain.enter();
	            }
	
	            try {
	                task();
	
	            } catch (e) {
	                if (isNodeJS) {
	                    // In node, uncaught exceptions are considered fatal errors.
	                    // Re-throw them synchronously to interrupt flushing!
	
	                    // Ensure continuation if the uncaught exception is suppressed
	                    // listening "uncaughtException" events (as domains does).
	                    // Continue in next event to avoid tick recursion.
	                    if (domain) {
	                        domain.exit();
	                    }
	                    setTimeout(flush, 0);
	                    if (domain) {
	                        domain.enter();
	                    }
	
	                    throw e;
	
	                } else {
	                    // In browsers, uncaught exceptions are not fatal.
	                    // Re-throw them asynchronously to avoid slow-downs.
	                    setTimeout(function() {
	                       throw e;
	                    }, 0);
	                }
	            }
	
	            if (domain) {
	                domain.exit();
	            }
	        }
	
	        flushing = false;
	    }
	
	    nextTick = function (task) {
	        tail = tail.next = {
	            task: task,
	            domain: isNodeJS && process.domain,
	            next: null
	        };
	
	        if (!flushing) {
	            flushing = true;
	            requestTick();
	        }
	    };
	
	    if (typeof process !== "undefined" && process.nextTick) {
	        // Node.js before 0.9. Note that some fake-Node environments, like the
	        // Mocha test runner, introduce a `process` global without a `nextTick`.
	        isNodeJS = true;
	
	        requestTick = function () {
	            process.nextTick(flush);
	        };
	
	    } else if (typeof setImmediate === "function") {
	        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
	        if (typeof window !== "undefined") {
	            requestTick = setImmediate.bind(window, flush);
	        } else {
	            requestTick = function () {
	                setImmediate(flush);
	            };
	        }
	
	    } else if (typeof MessageChannel !== "undefined") {
	        // modern browsers
	        // http://www.nonblocking.io/2011/06/windownexttick.html
	        var channel = new MessageChannel();
	        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
	        // working message ports the first time a page loads.
	        channel.port1.onmessage = function () {
	            requestTick = requestPortTick;
	            channel.port1.onmessage = flush;
	            flush();
	        };
	        var requestPortTick = function () {
	            // Opera requires us to provide a message payload, regardless of
	            // whether we use it.
	            channel.port2.postMessage(0);
	        };
	        requestTick = function () {
	            setTimeout(flush, 0);
	            requestPortTick();
	        };
	
	    } else {
	        // old browsers
	        requestTick = function () {
	            setTimeout(flush, 0);
	        };
	    }
	
	    return nextTick;
	})();
	
	// Attempt to make generics safe in the face of downstream
	// modifications.
	// There is no situation where this is necessary.
	// If you need a security guarantee, these primordials need to be
	// deeply frozen anyway, and if you don’t need a security guarantee,
	// this is just plain paranoid.
	// However, this does have the nice side-effect of reducing the size
	// of the code by reducing x.call() to merely x(), eliminating many
	// hard-to-minify characters.
	// See Mark Miller’s explanation of what this does.
	// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
	var call = Function.call;
	function uncurryThis(f) {
	    return function () {
	        return call.apply(f, arguments);
	    };
	}
	// This is equivalent, but slower:
	// uncurryThis = Function_bind.bind(Function_bind.call);
	// http://jsperf.com/uncurrythis
	
	var array_slice = uncurryThis(Array.prototype.slice);
	
	var array_reduce = uncurryThis(
	    Array.prototype.reduce || function (callback, basis) {
	        var index = 0,
	            length = this.length;
	        // concerning the initial value, if one is not provided
	        if (arguments.length === 1) {
	            // seek to the first value in the array, accounting
	            // for the possibility that is is a sparse array
	            do {
	                if (index in this) {
	                    basis = this[index++];
	                    break;
	                }
	                if (++index >= length) {
	                    throw new TypeError();
	                }
	            } while (1);
	        }
	        // reduce
	        for (; index < length; index++) {
	            // account for the possibility that the array is sparse
	            if (index in this) {
	                basis = callback(basis, this[index], index);
	            }
	        }
	        return basis;
	    }
	);
	
	var array_indexOf = uncurryThis(
	    Array.prototype.indexOf || function (value) {
	        // not a very good shim, but good enough for our one use of it
	        for (var i = 0; i < this.length; i++) {
	            if (this[i] === value) {
	                return i;
	            }
	        }
	        return -1;
	    }
	);
	
	var array_map = uncurryThis(
	    Array.prototype.map || function (callback, thisp) {
	        var self = this;
	        var collect = [];
	        array_reduce(self, function (undefined, value, index) {
	            collect.push(callback.call(thisp, value, index, self));
	        }, void 0);
	        return collect;
	    }
	);
	
	var object_create = Object.create || function (prototype) {
	    function Type() { }
	    Type.prototype = prototype;
	    return new Type();
	};
	
	var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
	
	var object_keys = Object.keys || function (object) {
	    var keys = [];
	    for (var key in object) {
	        if (object_hasOwnProperty(object, key)) {
	            keys.push(key);
	        }
	    }
	    return keys;
	};
	
	var object_toString = uncurryThis(Object.prototype.toString);
	
	function isObject(value) {
	    return value === Object(value);
	}
	
	// generator related shims
	
	// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
	function isStopIteration(exception) {
	    return (
	        object_toString(exception) === "[object StopIteration]" ||
	        exception instanceof QReturnValue
	    );
	}
	
	// FIXME: Remove this helper and Q.return once ES6 generators are in
	// SpiderMonkey.
	var QReturnValue;
	if (typeof ReturnValue !== "undefined") {
	    QReturnValue = ReturnValue;
	} else {
	    QReturnValue = function (value) {
	        this.value = value;
	    };
	}
	
	// Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
	// engine that has a deployed base of browsers that support generators.
	// However, SM's generators use the Python-inspired semantics of
	// outdated ES6 drafts.  We would like to support ES6, but we'd also
	// like to make it possible to use generators in deployed browsers, so
	// we also support Python-style generators.  At some point we can remove
	// this block.
	var hasES6Generators;
	try {
	    /* jshint evil: true, nonew: false */
	    new Function("(function* (){ yield 1; })");
	    hasES6Generators = true;
	} catch (e) {
	    hasES6Generators = false;
	}
	
	// long stack traces
	
	var STACK_JUMP_SEPARATOR = "From previous event:";
	
	function makeStackTraceLong(error, promise) {
	    // If possible, transform the error stack trace by removing Node and Q
	    // cruft, then concatenating with the stack trace of `promise`. See #57.
	    if (hasStacks &&
	        promise.stack &&
	        typeof error === "object" &&
	        error !== null &&
	        error.stack &&
	        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
	    ) {
	        var stacks = [];
	        for (var p = promise; !!p; p = p.source) {
	            if (p.stack) {
	                stacks.unshift(p.stack);
	            }
	        }
	        stacks.unshift(error.stack);
	
	        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
	        error.stack = filterStackString(concatedStacks);
	    }
	}
	
	function filterStackString(stackString) {
	    var lines = stackString.split("\n");
	    var desiredLines = [];
	    for (var i = 0; i < lines.length; ++i) {
	        var line = lines[i];
	
	        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
	            desiredLines.push(line);
	        }
	    }
	    return desiredLines.join("\n");
	}
	
	function isNodeFrame(stackLine) {
	    return stackLine.indexOf("(module.js:") !== -1 ||
	           stackLine.indexOf("(node.js:") !== -1;
	}
	
	function getFileNameAndLineNumber(stackLine) {
	    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
	    // In IE10 function name can have spaces ("Anonymous function") O_o
	    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
	    if (attempt1) {
	        return [attempt1[1], Number(attempt1[2])];
	    }
	
	    // Anonymous functions: "at filename:lineNumber:columnNumber"
	    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
	    if (attempt2) {
	        return [attempt2[1], Number(attempt2[2])];
	    }
	
	    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
	    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
	    if (attempt3) {
	        return [attempt3[1], Number(attempt3[2])];
	    }
	}
	
	function isInternalFrame(stackLine) {
	    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
	
	    if (!fileNameAndLineNumber) {
	        return false;
	    }
	
	    var fileName = fileNameAndLineNumber[0];
	    var lineNumber = fileNameAndLineNumber[1];
	
	    return fileName === qFileName &&
	        lineNumber >= qStartingLine &&
	        lineNumber <= qEndingLine;
	}
	
	// discover own file name and line number range for filtering stack
	// traces
	function captureLine() {
	    if (!hasStacks) {
	        return;
	    }
	
	    try {
	        throw new Error();
	    } catch (e) {
	        var lines = e.stack.split("\n");
	        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
	        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
	        if (!fileNameAndLineNumber) {
	            return;
	        }
	
	        qFileName = fileNameAndLineNumber[0];
	        return fileNameAndLineNumber[1];
	    }
	}
	
	function deprecate(callback, name, alternative) {
	    return function () {
	        if (typeof console !== "undefined" &&
	            typeof console.warn === "function") {
	            console.warn(name + " is deprecated, use " + alternative +
	                         " instead.", new Error("").stack);
	        }
	        return callback.apply(callback, arguments);
	    };
	}
	
	// end of shims
	// beginning of real work
	
	/**
	 * Constructs a promise for an immediate reference, passes promises through, or
	 * coerces promises from different systems.
	 * @param value immediate reference or promise
	 */
	function Q(value) {
	    // If the object is already a Promise, return it directly.  This enables
	    // the resolve function to both be used to created references from objects,
	    // but to tolerably coerce non-promises to promises.
	    if (isPromise(value)) {
	        return value;
	    }
	
	    // assimilate thenables
	    if (isPromiseAlike(value)) {
	        return coerce(value);
	    } else {
	        return fulfill(value);
	    }
	}
	Q.resolve = Q;
	
	/**
	 * Performs a task in a future turn of the event loop.
	 * @param {Function} task
	 */
	Q.nextTick = nextTick;
	
	/**
	 * Controls whether or not long stack traces will be on
	 */
	Q.longStackSupport = false;
	
	/**
	 * Constructs a {promise, resolve, reject} object.
	 *
	 * `resolve` is a callback to invoke with a more resolved value for the
	 * promise. To fulfill the promise, invoke `resolve` with any value that is
	 * not a thenable. To reject the promise, invoke `resolve` with a rejected
	 * thenable, or invoke `reject` with the reason directly. To resolve the
	 * promise to another thenable, thus putting it in the same state, invoke
	 * `resolve` with that other thenable.
	 */
	Q.defer = defer;
	function defer() {
	    // if "messages" is an "Array", that indicates that the promise has not yet
	    // been resolved.  If it is "undefined", it has been resolved.  Each
	    // element of the messages array is itself an array of complete arguments to
	    // forward to the resolved promise.  We coerce the resolution value to a
	    // promise using the `resolve` function because it handles both fully
	    // non-thenable values and other thenables gracefully.
	    var messages = [], progressListeners = [], resolvedPromise;
	
	    var deferred = object_create(defer.prototype);
	    var promise = object_create(Promise.prototype);
	
	    promise.promiseDispatch = function (resolve, op, operands) {
	        var args = array_slice(arguments);
	        if (messages) {
	            messages.push(args);
	            if (op === "when" && operands[1]) { // progress operand
	                progressListeners.push(operands[1]);
	            }
	        } else {
	            nextTick(function () {
	                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
	            });
	        }
	    };
	
	    // XXX deprecated
	    promise.valueOf = deprecate(function () {
	        if (messages) {
	            return promise;
	        }
	        var nearerValue = nearer(resolvedPromise);
	        if (isPromise(nearerValue)) {
	            resolvedPromise = nearerValue; // shorten chain
	        }
	        return nearerValue;
	    }, "valueOf", "inspect");
	
	    promise.inspect = function () {
	        if (!resolvedPromise) {
	            return { state: "pending" };
	        }
	        return resolvedPromise.inspect();
	    };
	
	    if (Q.longStackSupport && hasStacks) {
	        try {
	            throw new Error();
	        } catch (e) {
	            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
	            // accessor around; that causes memory leaks as per GH-111. Just
	            // reify the stack trace as a string ASAP.
	            //
	            // At the same time, cut off the first line; it's always just
	            // "[object Promise]\n", as per the `toString`.
	            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
	        }
	    }
	
	    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
	    // consolidating them into `become`, since otherwise we'd create new
	    // promises with the lines `become(whatever(value))`. See e.g. GH-252.
	
	    function become(newPromise) {
	        resolvedPromise = newPromise;
	        promise.source = newPromise;
	
	        array_reduce(messages, function (undefined, message) {
	            nextTick(function () {
	                newPromise.promiseDispatch.apply(newPromise, message);
	            });
	        }, void 0);
	
	        messages = void 0;
	        progressListeners = void 0;
	    }
	
	    deferred.promise = promise;
	    deferred.resolve = function (value) {
	        if (resolvedPromise) {
	            return;
	        }
	
	        become(Q(value));
	    };
	
	    deferred.fulfill = function (value) {
	        if (resolvedPromise) {
	            return;
	        }
	
	        become(fulfill(value));
	    };
	    deferred.reject = function (reason) {
	        if (resolvedPromise) {
	            return;
	        }
	
	        become(reject(reason));
	    };
	    deferred.notify = function (progress) {
	        if (resolvedPromise) {
	            return;
	        }
	
	        array_reduce(progressListeners, function (undefined, progressListener) {
	            nextTick(function () {
	                progressListener(progress);
	            });
	        }, void 0);
	    };
	
	    return deferred;
	}
	
	/**
	 * Creates a Node-style callback that will resolve or reject the deferred
	 * promise.
	 * @returns a nodeback
	 */
	defer.prototype.makeNodeResolver = function () {
	    var self = this;
	    return function (error, value) {
	        if (error) {
	            self.reject(error);
	        } else if (arguments.length > 2) {
	            self.resolve(array_slice(arguments, 1));
	        } else {
	            self.resolve(value);
	        }
	    };
	};
	
	/**
	 * @param resolver {Function} a function that returns nothing and accepts
	 * the resolve, reject, and notify functions for a deferred.
	 * @returns a promise that may be resolved with the given resolve and reject
	 * functions, or rejected by a thrown exception in resolver
	 */
	Q.promise = promise;
	function promise(resolver) {
	    if (typeof resolver !== "function") {
	        throw new TypeError("resolver must be a function.");
	    }
	    var deferred = defer();
	    try {
	        resolver(deferred.resolve, deferred.reject, deferred.notify);
	    } catch (reason) {
	        deferred.reject(reason);
	    }
	    return deferred.promise;
	}
	
	// XXX experimental.  This method is a way to denote that a local value is
	// serializable and should be immediately dispatched to a remote upon request,
	// instead of passing a reference.
	Q.passByCopy = function (object) {
	    //freeze(object);
	    //passByCopies.set(object, true);
	    return object;
	};
	
	Promise.prototype.passByCopy = function () {
	    //freeze(object);
	    //passByCopies.set(object, true);
	    return this;
	};
	
	/**
	 * If two promises eventually fulfill to the same value, promises that value,
	 * but otherwise rejects.
	 * @param x {Any*}
	 * @param y {Any*}
	 * @returns {Any*} a promise for x and y if they are the same, but a rejection
	 * otherwise.
	 *
	 */
	Q.join = function (x, y) {
	    return Q(x).join(y);
	};
	
	Promise.prototype.join = function (that) {
	    return Q([this, that]).spread(function (x, y) {
	        if (x === y) {
	            // TODO: "===" should be Object.is or equiv
	            return x;
	        } else {
	            throw new Error("Can't join: not the same: " + x + " " + y);
	        }
	    });
	};
	
	/**
	 * Returns a promise for the first of an array of promises to become fulfilled.
	 * @param answers {Array[Any*]} promises to race
	 * @returns {Any*} the first promise to be fulfilled
	 */
	Q.race = race;
	function race(answerPs) {
	    return promise(function(resolve, reject) {
	        // Switch to this once we can assume at least ES5
	        // answerPs.forEach(function(answerP) {
	        //     Q(answerP).then(resolve, reject);
	        // });
	        // Use this in the meantime
	        for (var i = 0, len = answerPs.length; i < len; i++) {
	            Q(answerPs[i]).then(resolve, reject);
	        }
	    });
	}
	
	Promise.prototype.race = function () {
	    return this.then(Q.race);
	};
	
	/**
	 * Constructs a Promise with a promise descriptor object and optional fallback
	 * function.  The descriptor contains methods like when(rejected), get(name),
	 * set(name, value), post(name, args), and delete(name), which all
	 * return either a value, a promise for a value, or a rejection.  The fallback
	 * accepts the operation name, a resolver, and any further arguments that would
	 * have been forwarded to the appropriate method above had a method been
	 * provided with the proper name.  The API makes no guarantees about the nature
	 * of the returned object, apart from that it is usable whereever promises are
	 * bought and sold.
	 */
	Q.makePromise = Promise;
	function Promise(descriptor, fallback, inspect) {
	    if (fallback === void 0) {
	        fallback = function (op) {
	            return reject(new Error(
	                "Promise does not support operation: " + op
	            ));
	        };
	    }
	    if (inspect === void 0) {
	        inspect = function () {
	            return {state: "unknown"};
	        };
	    }
	
	    var promise = object_create(Promise.prototype);
	
	    promise.promiseDispatch = function (resolve, op, args) {
	        var result;
	        try {
	            if (descriptor[op]) {
	                result = descriptor[op].apply(promise, args);
	            } else {
	                result = fallback.call(promise, op, args);
	            }
	        } catch (exception) {
	            result = reject(exception);
	        }
	        if (resolve) {
	            resolve(result);
	        }
	    };
	
	    promise.inspect = inspect;
	
	    // XXX deprecated `valueOf` and `exception` support
	    if (inspect) {
	        var inspected = inspect();
	        if (inspected.state === "rejected") {
	            promise.exception = inspected.reason;
	        }
	
	        promise.valueOf = deprecate(function () {
	            var inspected = inspect();
	            if (inspected.state === "pending" ||
	                inspected.state === "rejected") {
	                return promise;
	            }
	            return inspected.value;
	        });
	    }
	
	    return promise;
	}
	
	Promise.prototype.toString = function () {
	    return "[object Promise]";
	};
	
	Promise.prototype.then = function (fulfilled, rejected, progressed) {
	    var self = this;
	    var deferred = defer();
	    var done = false;   // ensure the untrusted promise makes at most a
	                        // single call to one of the callbacks
	
	    function _fulfilled(value) {
	        try {
	            return typeof fulfilled === "function" ? fulfilled(value) : value;
	        } catch (exception) {
	            return reject(exception);
	        }
	    }
	
	    function _rejected(exception) {
	        if (typeof rejected === "function") {
	            makeStackTraceLong(exception, self);
	            try {
	                return rejected(exception);
	            } catch (newException) {
	                return reject(newException);
	            }
	        }
	        return reject(exception);
	    }
	
	    function _progressed(value) {
	        return typeof progressed === "function" ? progressed(value) : value;
	    }
	
	    nextTick(function () {
	        self.promiseDispatch(function (value) {
	            if (done) {
	                return;
	            }
	            done = true;
	
	            deferred.resolve(_fulfilled(value));
	        }, "when", [function (exception) {
	            if (done) {
	                return;
	            }
	            done = true;
	
	            deferred.resolve(_rejected(exception));
	        }]);
	    });
	
	    // Progress propagator need to be attached in the current tick.
	    self.promiseDispatch(void 0, "when", [void 0, function (value) {
	        var newValue;
	        var threw = false;
	        try {
	            newValue = _progressed(value);
	        } catch (e) {
	            threw = true;
	            if (Q.onerror) {
	                Q.onerror(e);
	            } else {
	                throw e;
	            }
	        }
	
	        if (!threw) {
	            deferred.notify(newValue);
	        }
	    }]);
	
	    return deferred.promise;
	};
	
	/**
	 * Registers an observer on a promise.
	 *
	 * Guarantees:
	 *
	 * 1. that fulfilled and rejected will be called only once.
	 * 2. that either the fulfilled callback or the rejected callback will be
	 *    called, but not both.
	 * 3. that fulfilled and rejected will not be called in this turn.
	 *
	 * @param value      promise or immediate reference to observe
	 * @param fulfilled  function to be called with the fulfilled value
	 * @param rejected   function to be called with the rejection exception
	 * @param progressed function to be called on any progress notifications
	 * @return promise for the return value from the invoked callback
	 */
	Q.when = when;
	function when(value, fulfilled, rejected, progressed) {
	    return Q(value).then(fulfilled, rejected, progressed);
	}
	
	Promise.prototype.thenResolve = function (value) {
	    return this.then(function () { return value; });
	};
	
	Q.thenResolve = function (promise, value) {
	    return Q(promise).thenResolve(value);
	};
	
	Promise.prototype.thenReject = function (reason) {
	    return this.then(function () { throw reason; });
	};
	
	Q.thenReject = function (promise, reason) {
	    return Q(promise).thenReject(reason);
	};
	
	/**
	 * If an object is not a promise, it is as "near" as possible.
	 * If a promise is rejected, it is as "near" as possible too.
	 * If it’s a fulfilled promise, the fulfillment value is nearer.
	 * If it’s a deferred promise and the deferred has been resolved, the
	 * resolution is "nearer".
	 * @param object
	 * @returns most resolved (nearest) form of the object
	 */
	
	// XXX should we re-do this?
	Q.nearer = nearer;
	function nearer(value) {
	    if (isPromise(value)) {
	        var inspected = value.inspect();
	        if (inspected.state === "fulfilled") {
	            return inspected.value;
	        }
	    }
	    return value;
	}
	
	/**
	 * @returns whether the given object is a promise.
	 * Otherwise it is a fulfilled value.
	 */
	Q.isPromise = isPromise;
	function isPromise(object) {
	    return isObject(object) &&
	        typeof object.promiseDispatch === "function" &&
	        typeof object.inspect === "function";
	}
	
	Q.isPromiseAlike = isPromiseAlike;
	function isPromiseAlike(object) {
	    return isObject(object) && typeof object.then === "function";
	}
	
	/**
	 * @returns whether the given object is a pending promise, meaning not
	 * fulfilled or rejected.
	 */
	Q.isPending = isPending;
	function isPending(object) {
	    return isPromise(object) && object.inspect().state === "pending";
	}
	
	Promise.prototype.isPending = function () {
	    return this.inspect().state === "pending";
	};
	
	/**
	 * @returns whether the given object is a value or fulfilled
	 * promise.
	 */
	Q.isFulfilled = isFulfilled;
	function isFulfilled(object) {
	    return !isPromise(object) || object.inspect().state === "fulfilled";
	}
	
	Promise.prototype.isFulfilled = function () {
	    return this.inspect().state === "fulfilled";
	};
	
	/**
	 * @returns whether the given object is a rejected promise.
	 */
	Q.isRejected = isRejected;
	function isRejected(object) {
	    return isPromise(object) && object.inspect().state === "rejected";
	}
	
	Promise.prototype.isRejected = function () {
	    return this.inspect().state === "rejected";
	};
	
	//// BEGIN UNHANDLED REJECTION TRACKING
	
	// This promise library consumes exceptions thrown in handlers so they can be
	// handled by a subsequent promise.  The exceptions get added to this array when
	// they are created, and removed when they are handled.  Note that in ES6 or
	// shimmed environments, this would naturally be a `Set`.
	var unhandledReasons = [];
	var unhandledRejections = [];
	var unhandledReasonsDisplayed = false;
	var trackUnhandledRejections = true;
	function displayUnhandledReasons() {
	    if (
	        !unhandledReasonsDisplayed &&
	        typeof window !== "undefined" &&
	        !window.Touch &&
	        window.console
	    ) {
	        console.warn("[Q] Unhandled rejection reasons (should be empty):",
	                     unhandledReasons);
	    }
	
	    unhandledReasonsDisplayed = true;
	}
	
	function logUnhandledReasons() {
	    for (var i = 0; i < unhandledReasons.length; i++) {
	        var reason = unhandledReasons[i];
	        console.warn("Unhandled rejection reason:", reason);
	    }
	}
	
	function resetUnhandledRejections() {
	    unhandledReasons.length = 0;
	    unhandledRejections.length = 0;
	    unhandledReasonsDisplayed = false;
	
	    if (!trackUnhandledRejections) {
	        trackUnhandledRejections = true;
	
	        // Show unhandled rejection reasons if Node exits without handling an
	        // outstanding rejection.  (Note that Browserify presently produces a
	        // `process` global without the `EventEmitter` `on` method.)
	        if (typeof process !== "undefined" && process.on) {
	            process.on("exit", logUnhandledReasons);
	        }
	    }
	}
	
	function trackRejection(promise, reason) {
	    if (!trackUnhandledRejections) {
	        return;
	    }
	
	    unhandledRejections.push(promise);
	    if (reason && typeof reason.stack !== "undefined") {
	        unhandledReasons.push(reason.stack);
	    } else {
	        unhandledReasons.push("(no stack) " + reason);
	    }
	    displayUnhandledReasons();
	}
	
	function untrackRejection(promise) {
	    if (!trackUnhandledRejections) {
	        return;
	    }
	
	    var at = array_indexOf(unhandledRejections, promise);
	    if (at !== -1) {
	        unhandledRejections.splice(at, 1);
	        unhandledReasons.splice(at, 1);
	    }
	}
	
	Q.resetUnhandledRejections = resetUnhandledRejections;
	
	Q.getUnhandledReasons = function () {
	    // Make a copy so that consumers can't interfere with our internal state.
	    return unhandledReasons.slice();
	};
	
	Q.stopUnhandledRejectionTracking = function () {
	    resetUnhandledRejections();
	    if (typeof process !== "undefined" && process.on) {
	        process.removeListener("exit", logUnhandledReasons);
	    }
	    trackUnhandledRejections = false;
	};
	
	resetUnhandledRejections();
	
	//// END UNHANDLED REJECTION TRACKING
	
	/**
	 * Constructs a rejected promise.
	 * @param reason value describing the failure
	 */
	Q.reject = reject;
	function reject(reason) {
	    var rejection = Promise({
	        "when": function (rejected) {
	            // note that the error has been handled
	            if (rejected) {
	                untrackRejection(this);
	            }
	            return rejected ? rejected(reason) : this;
	        }
	    }, function fallback() {
	        return this;
	    }, function inspect() {
	        return { state: "rejected", reason: reason };
	    });
	
	    // Note that the reason has not been handled.
	    trackRejection(rejection, reason);
	
	    return rejection;
	}
	
	/**
	 * Constructs a fulfilled promise for an immediate reference.
	 * @param value immediate reference
	 */
	Q.fulfill = fulfill;
	function fulfill(value) {
	    return Promise({
	        "when": function () {
	            return value;
	        },
	        "get": function (name) {
	            return value[name];
	        },
	        "set": function (name, rhs) {
	            value[name] = rhs;
	        },
	        "delete": function (name) {
	            delete value[name];
	        },
	        "post": function (name, args) {
	            // Mark Miller proposes that post with no name should apply a
	            // promised function.
	            if (name === null || name === void 0) {
	                return value.apply(void 0, args);
	            } else {
	                return value[name].apply(value, args);
	            }
	        },
	        "apply": function (thisp, args) {
	            return value.apply(thisp, args);
	        },
	        "keys": function () {
	            return object_keys(value);
	        }
	    }, void 0, function inspect() {
	        return { state: "fulfilled", value: value };
	    });
	}
	
	/**
	 * Converts thenables to Q promises.
	 * @param promise thenable promise
	 * @returns a Q promise
	 */
	function coerce(promise) {
	    var deferred = defer();
	    nextTick(function () {
	        try {
	            promise.then(deferred.resolve, deferred.reject, deferred.notify);
	        } catch (exception) {
	            deferred.reject(exception);
	        }
	    });
	    return deferred.promise;
	}
	
	/**
	 * Annotates an object such that it will never be
	 * transferred away from this process over any promise
	 * communication channel.
	 * @param object
	 * @returns promise a wrapping of that object that
	 * additionally responds to the "isDef" message
	 * without a rejection.
	 */
	Q.master = master;
	function master(object) {
	    return Promise({
	        "isDef": function () {}
	    }, function fallback(op, args) {
	        return dispatch(object, op, args);
	    }, function () {
	        return Q(object).inspect();
	    });
	}
	
	/**
	 * Spreads the values of a promised array of arguments into the
	 * fulfillment callback.
	 * @param fulfilled callback that receives variadic arguments from the
	 * promised array
	 * @param rejected callback that receives the exception if the promise
	 * is rejected.
	 * @returns a promise for the return value or thrown exception of
	 * either callback.
	 */
	Q.spread = spread;
	function spread(value, fulfilled, rejected) {
	    return Q(value).spread(fulfilled, rejected);
	}
	
	Promise.prototype.spread = function (fulfilled, rejected) {
	    return this.all().then(function (array) {
	        return fulfilled.apply(void 0, array);
	    }, rejected);
	};
	
	/**
	 * The async function is a decorator for generator functions, turning
	 * them into asynchronous generators.  Although generators are only part
	 * of the newest ECMAScript 6 drafts, this code does not cause syntax
	 * errors in older engines.  This code should continue to work and will
	 * in fact improve over time as the language improves.
	 *
	 * ES6 generators are currently part of V8 version 3.19 with the
	 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
	 * for longer, but under an older Python-inspired form.  This function
	 * works on both kinds of generators.
	 *
	 * Decorates a generator function such that:
	 *  - it may yield promises
	 *  - execution will continue when that promise is fulfilled
	 *  - the value of the yield expression will be the fulfilled value
	 *  - it returns a promise for the return value (when the generator
	 *    stops iterating)
	 *  - the decorated function returns a promise for the return value
	 *    of the generator or the first rejected promise among those
	 *    yielded.
	 *  - if an error is thrown in the generator, it propagates through
	 *    every following yield until it is caught, or until it escapes
	 *    the generator function altogether, and is translated into a
	 *    rejection for the promise returned by the decorated generator.
	 */
	Q.async = async;
	function async(makeGenerator) {
	    return function () {
	        // when verb is "send", arg is a value
	        // when verb is "throw", arg is an exception
	        function continuer(verb, arg) {
	            var result;
	            if (hasES6Generators) {
	                try {
	                    result = generator[verb](arg);
	                } catch (exception) {
	                    return reject(exception);
	                }
	                if (result.done) {
	                    return result.value;
	                } else {
	                    return when(result.value, callback, errback);
	                }
	            } else {
	                // FIXME: Remove this case when SM does ES6 generators.
	                try {
	                    result = generator[verb](arg);
	                } catch (exception) {
	                    if (isStopIteration(exception)) {
	                        return exception.value;
	                    } else {
	                        return reject(exception);
	                    }
	                }
	                return when(result, callback, errback);
	            }
	        }
	        var generator = makeGenerator.apply(this, arguments);
	        var callback = continuer.bind(continuer, "next");
	        var errback = continuer.bind(continuer, "throw");
	        return callback();
	    };
	}
	
	/**
	 * The spawn function is a small wrapper around async that immediately
	 * calls the generator and also ends the promise chain, so that any
	 * unhandled errors are thrown instead of forwarded to the error
	 * handler. This is useful because it's extremely common to run
	 * generators at the top-level to work with libraries.
	 */
	Q.spawn = spawn;
	function spawn(makeGenerator) {
	    Q.done(Q.async(makeGenerator)());
	}
	
	// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
	/**
	 * Throws a ReturnValue exception to stop an asynchronous generator.
	 *
	 * This interface is a stop-gap measure to support generator return
	 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
	 * generators like Chromium 29, just use "return" in your generator
	 * functions.
	 *
	 * @param value the return value for the surrounding generator
	 * @throws ReturnValue exception with the value.
	 * @example
	 * // ES6 style
	 * Q.async(function* () {
	 *      var foo = yield getFooPromise();
	 *      var bar = yield getBarPromise();
	 *      return foo + bar;
	 * })
	 * // Older SpiderMonkey style
	 * Q.async(function () {
	 *      var foo = yield getFooPromise();
	 *      var bar = yield getBarPromise();
	 *      Q.return(foo + bar);
	 * })
	 */
	Q["return"] = _return;
	function _return(value) {
	    throw new QReturnValue(value);
	}
	
	/**
	 * The promised function decorator ensures that any promise arguments
	 * are settled and passed as values (`this` is also settled and passed
	 * as a value).  It will also ensure that the result of a function is
	 * always a promise.
	 *
	 * @example
	 * var add = Q.promised(function (a, b) {
	 *     return a + b;
	 * });
	 * add(Q(a), Q(B));
	 *
	 * @param {function} callback The function to decorate
	 * @returns {function} a function that has been decorated.
	 */
	Q.promised = promised;
	function promised(callback) {
	    return function () {
	        return spread([this, all(arguments)], function (self, args) {
	            return callback.apply(self, args);
	        });
	    };
	}
	
	/**
	 * sends a message to a value in a future turn
	 * @param object* the recipient
	 * @param op the name of the message operation, e.g., "when",
	 * @param args further arguments to be forwarded to the operation
	 * @returns result {Promise} a promise for the result of the operation
	 */
	Q.dispatch = dispatch;
	function dispatch(object, op, args) {
	    return Q(object).dispatch(op, args);
	}
	
	Promise.prototype.dispatch = function (op, args) {
	    var self = this;
	    var deferred = defer();
	    nextTick(function () {
	        self.promiseDispatch(deferred.resolve, op, args);
	    });
	    return deferred.promise;
	};
	
	/**
	 * Gets the value of a property in a future turn.
	 * @param object    promise or immediate reference for target object
	 * @param name      name of property to get
	 * @return promise for the property value
	 */
	Q.get = function (object, key) {
	    return Q(object).dispatch("get", [key]);
	};
	
	Promise.prototype.get = function (key) {
	    return this.dispatch("get", [key]);
	};
	
	/**
	 * Sets the value of a property in a future turn.
	 * @param object    promise or immediate reference for object object
	 * @param name      name of property to set
	 * @param value     new value of property
	 * @return promise for the return value
	 */
	Q.set = function (object, key, value) {
	    return Q(object).dispatch("set", [key, value]);
	};
	
	Promise.prototype.set = function (key, value) {
	    return this.dispatch("set", [key, value]);
	};
	
	/**
	 * Deletes a property in a future turn.
	 * @param object    promise or immediate reference for target object
	 * @param name      name of property to delete
	 * @return promise for the return value
	 */
	Q.del = // XXX legacy
	Q["delete"] = function (object, key) {
	    return Q(object).dispatch("delete", [key]);
	};
	
	Promise.prototype.del = // XXX legacy
	Promise.prototype["delete"] = function (key) {
	    return this.dispatch("delete", [key]);
	};
	
	/**
	 * Invokes a method in a future turn.
	 * @param object    promise or immediate reference for target object
	 * @param name      name of method to invoke
	 * @param value     a value to post, typically an array of
	 *                  invocation arguments for promises that
	 *                  are ultimately backed with `resolve` values,
	 *                  as opposed to those backed with URLs
	 *                  wherein the posted value can be any
	 *                  JSON serializable object.
	 * @return promise for the return value
	 */
	// bound locally because it is used by other methods
	Q.mapply = // XXX As proposed by "Redsandro"
	Q.post = function (object, name, args) {
	    return Q(object).dispatch("post", [name, args]);
	};
	
	Promise.prototype.mapply = // XXX As proposed by "Redsandro"
	Promise.prototype.post = function (name, args) {
	    return this.dispatch("post", [name, args]);
	};
	
	/**
	 * Invokes a method in a future turn.
	 * @param object    promise or immediate reference for target object
	 * @param name      name of method to invoke
	 * @param ...args   array of invocation arguments
	 * @return promise for the return value
	 */
	Q.send = // XXX Mark Miller's proposed parlance
	Q.mcall = // XXX As proposed by "Redsandro"
	Q.invoke = function (object, name /*...args*/) {
	    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
	};
	
	Promise.prototype.send = // XXX Mark Miller's proposed parlance
	Promise.prototype.mcall = // XXX As proposed by "Redsandro"
	Promise.prototype.invoke = function (name /*...args*/) {
	    return this.dispatch("post", [name, array_slice(arguments, 1)]);
	};
	
	/**
	 * Applies the promised function in a future turn.
	 * @param object    promise or immediate reference for target function
	 * @param args      array of application arguments
	 */
	Q.fapply = function (object, args) {
	    return Q(object).dispatch("apply", [void 0, args]);
	};
	
	Promise.prototype.fapply = function (args) {
	    return this.dispatch("apply", [void 0, args]);
	};
	
	/**
	 * Calls the promised function in a future turn.
	 * @param object    promise or immediate reference for target function
	 * @param ...args   array of application arguments
	 */
	Q["try"] =
	Q.fcall = function (object /* ...args*/) {
	    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
	};
	
	Promise.prototype.fcall = function (/*...args*/) {
	    return this.dispatch("apply", [void 0, array_slice(arguments)]);
	};
	
	/**
	 * Binds the promised function, transforming return values into a fulfilled
	 * promise and thrown errors into a rejected one.
	 * @param object    promise or immediate reference for target function
	 * @param ...args   array of application arguments
	 */
	Q.fbind = function (object /*...args*/) {
	    var promise = Q(object);
	    var args = array_slice(arguments, 1);
	    return function fbound() {
	        return promise.dispatch("apply", [
	            this,
	            args.concat(array_slice(arguments))
	        ]);
	    };
	};
	Promise.prototype.fbind = function (/*...args*/) {
	    var promise = this;
	    var args = array_slice(arguments);
	    return function fbound() {
	        return promise.dispatch("apply", [
	            this,
	            args.concat(array_slice(arguments))
	        ]);
	    };
	};
	
	/**
	 * Requests the names of the owned properties of a promised
	 * object in a future turn.
	 * @param object    promise or immediate reference for target object
	 * @return promise for the keys of the eventually settled object
	 */
	Q.keys = function (object) {
	    return Q(object).dispatch("keys", []);
	};
	
	Promise.prototype.keys = function () {
	    return this.dispatch("keys", []);
	};
	
	/**
	 * Turns an array of promises into a promise for an array.  If any of
	 * the promises gets rejected, the whole array is rejected immediately.
	 * @param {Array*} an array (or promise for an array) of values (or
	 * promises for values)
	 * @returns a promise for an array of the corresponding values
	 */
	// By Mark Miller
	// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
	Q.all = all;
	function all(promises) {
	    return when(promises, function (promises) {
	        var countDown = 0;
	        var deferred = defer();
	        array_reduce(promises, function (undefined, promise, index) {
	            var snapshot;
	            if (
	                isPromise(promise) &&
	                (snapshot = promise.inspect()).state === "fulfilled"
	            ) {
	                promises[index] = snapshot.value;
	            } else {
	                ++countDown;
	                when(
	                    promise,
	                    function (value) {
	                        promises[index] = value;
	                        if (--countDown === 0) {
	                            deferred.resolve(promises);
	                        }
	                    },
	                    deferred.reject,
	                    function (progress) {
	                        deferred.notify({ index: index, value: progress });
	                    }
	                );
	            }
	        }, void 0);
	        if (countDown === 0) {
	            deferred.resolve(promises);
	        }
	        return deferred.promise;
	    });
	}
	
	Promise.prototype.all = function () {
	    return all(this);
	};
	
	/**
	 * Waits for all promises to be settled, either fulfilled or
	 * rejected.  This is distinct from `all` since that would stop
	 * waiting at the first rejection.  The promise returned by
	 * `allResolved` will never be rejected.
	 * @param promises a promise for an array (or an array) of promises
	 * (or values)
	 * @return a promise for an array of promises
	 */
	Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
	function allResolved(promises) {
	    return when(promises, function (promises) {
	        promises = array_map(promises, Q);
	        return when(all(array_map(promises, function (promise) {
	            return when(promise, noop, noop);
	        })), function () {
	            return promises;
	        });
	    });
	}
	
	Promise.prototype.allResolved = function () {
	    return allResolved(this);
	};
	
	/**
	 * @see Promise#allSettled
	 */
	Q.allSettled = allSettled;
	function allSettled(promises) {
	    return Q(promises).allSettled();
	}
	
	/**
	 * Turns an array of promises into a promise for an array of their states (as
	 * returned by `inspect`) when they have all settled.
	 * @param {Array[Any*]} values an array (or promise for an array) of values (or
	 * promises for values)
	 * @returns {Array[State]} an array of states for the respective values.
	 */
	Promise.prototype.allSettled = function () {
	    return this.then(function (promises) {
	        return all(array_map(promises, function (promise) {
	            promise = Q(promise);
	            function regardless() {
	                return promise.inspect();
	            }
	            return promise.then(regardless, regardless);
	        }));
	    });
	};
	
	/**
	 * Captures the failure of a promise, giving an oportunity to recover
	 * with a callback.  If the given promise is fulfilled, the returned
	 * promise is fulfilled.
	 * @param {Any*} promise for something
	 * @param {Function} callback to fulfill the returned promise if the
	 * given promise is rejected
	 * @returns a promise for the return value of the callback
	 */
	Q.fail = // XXX legacy
	Q["catch"] = function (object, rejected) {
	    return Q(object).then(void 0, rejected);
	};
	
	Promise.prototype.fail = // XXX legacy
	Promise.prototype["catch"] = function (rejected) {
	    return this.then(void 0, rejected);
	};
	
	/**
	 * Attaches a listener that can respond to progress notifications from a
	 * promise's originating deferred. This listener receives the exact arguments
	 * passed to ``deferred.notify``.
	 * @param {Any*} promise for something
	 * @param {Function} callback to receive any progress notifications
	 * @returns the given promise, unchanged
	 */
	Q.progress = progress;
	function progress(object, progressed) {
	    return Q(object).then(void 0, void 0, progressed);
	}
	
	Promise.prototype.progress = function (progressed) {
	    return this.then(void 0, void 0, progressed);
	};
	
	/**
	 * Provides an opportunity to observe the settling of a promise,
	 * regardless of whether the promise is fulfilled or rejected.  Forwards
	 * the resolution to the returned promise when the callback is done.
	 * The callback can return a promise to defer completion.
	 * @param {Any*} promise
	 * @param {Function} callback to observe the resolution of the given
	 * promise, takes no arguments.
	 * @returns a promise for the resolution of the given promise when
	 * ``fin`` is done.
	 */
	Q.fin = // XXX legacy
	Q["finally"] = function (object, callback) {
	    return Q(object)["finally"](callback);
	};
	
	Promise.prototype.fin = // XXX legacy
	Promise.prototype["finally"] = function (callback) {
	    callback = Q(callback);
	    return this.then(function (value) {
	        return callback.fcall().then(function () {
	            return value;
	        });
	    }, function (reason) {
	        // TODO attempt to recycle the rejection with "this".
	        return callback.fcall().then(function () {
	            throw reason;
	        });
	    });
	};
	
	/**
	 * Terminates a chain of promises, forcing rejections to be
	 * thrown as exceptions.
	 * @param {Any*} promise at the end of a chain of promises
	 * @returns nothing
	 */
	Q.done = function (object, fulfilled, rejected, progress) {
	    return Q(object).done(fulfilled, rejected, progress);
	};
	
	Promise.prototype.done = function (fulfilled, rejected, progress) {
	    var onUnhandledError = function (error) {
	        // forward to a future turn so that ``when``
	        // does not catch it and turn it into a rejection.
	        nextTick(function () {
	            makeStackTraceLong(error, promise);
	            if (Q.onerror) {
	                Q.onerror(error);
	            } else {
	                throw error;
	            }
	        });
	    };
	
	    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
	    var promise = fulfilled || rejected || progress ?
	        this.then(fulfilled, rejected, progress) :
	        this;
	
	    if (typeof process === "object" && process && process.domain) {
	        onUnhandledError = process.domain.bind(onUnhandledError);
	    }
	
	    promise.then(void 0, onUnhandledError);
	};
	
	/**
	 * Causes a promise to be rejected if it does not get fulfilled before
	 * some milliseconds time out.
	 * @param {Any*} promise
	 * @param {Number} milliseconds timeout
	 * @param {String} custom error message (optional)
	 * @returns a promise for the resolution of the given promise if it is
	 * fulfilled before the timeout, otherwise rejected.
	 */
	Q.timeout = function (object, ms, message) {
	    return Q(object).timeout(ms, message);
	};
	
	Promise.prototype.timeout = function (ms, message) {
	    var deferred = defer();
	    var timeoutId = setTimeout(function () {
	        deferred.reject(new Error(message || "Timed out after " + ms + " ms"));
	    }, ms);
	
	    this.then(function (value) {
	        clearTimeout(timeoutId);
	        deferred.resolve(value);
	    }, function (exception) {
	        clearTimeout(timeoutId);
	        deferred.reject(exception);
	    }, deferred.notify);
	
	    return deferred.promise;
	};
	
	/**
	 * Returns a promise for the given value (or promised value), some
	 * milliseconds after it resolved. Passes rejections immediately.
	 * @param {Any*} promise
	 * @param {Number} milliseconds
	 * @returns a promise for the resolution of the given promise after milliseconds
	 * time has elapsed since the resolution of the given promise.
	 * If the given promise rejects, that is passed immediately.
	 */
	Q.delay = function (object, timeout) {
	    if (timeout === void 0) {
	        timeout = object;
	        object = void 0;
	    }
	    return Q(object).delay(timeout);
	};
	
	Promise.prototype.delay = function (timeout) {
	    return this.then(function (value) {
	        var deferred = defer();
	        setTimeout(function () {
	            deferred.resolve(value);
	        }, timeout);
	        return deferred.promise;
	    });
	};
	
	/**
	 * Passes a continuation to a Node function, which is called with the given
	 * arguments provided as an array, and returns a promise.
	 *
	 *      Q.nfapply(FS.readFile, [__filename])
	 *      .then(function (content) {
	 *      })
	 *
	 */
	Q.nfapply = function (callback, args) {
	    return Q(callback).nfapply(args);
	};
	
	Promise.prototype.nfapply = function (args) {
	    var deferred = defer();
	    var nodeArgs = array_slice(args);
	    nodeArgs.push(deferred.makeNodeResolver());
	    this.fapply(nodeArgs).fail(deferred.reject);
	    return deferred.promise;
	};
	
	/**
	 * Passes a continuation to a Node function, which is called with the given
	 * arguments provided individually, and returns a promise.
	 * @example
	 * Q.nfcall(FS.readFile, __filename)
	 * .then(function (content) {
	 * })
	 *
	 */
	Q.nfcall = function (callback /*...args*/) {
	    var args = array_slice(arguments, 1);
	    return Q(callback).nfapply(args);
	};
	
	Promise.prototype.nfcall = function (/*...args*/) {
	    var nodeArgs = array_slice(arguments);
	    var deferred = defer();
	    nodeArgs.push(deferred.makeNodeResolver());
	    this.fapply(nodeArgs).fail(deferred.reject);
	    return deferred.promise;
	};
	
	/**
	 * Wraps a NodeJS continuation passing function and returns an equivalent
	 * version that returns a promise.
	 * @example
	 * Q.nfbind(FS.readFile, __filename)("utf-8")
	 * .then(console.log)
	 * .done()
	 */
	Q.nfbind =
	Q.denodeify = function (callback /*...args*/) {
	    var baseArgs = array_slice(arguments, 1);
	    return function () {
	        var nodeArgs = baseArgs.concat(array_slice(arguments));
	        var deferred = defer();
	        nodeArgs.push(deferred.makeNodeResolver());
	        Q(callback).fapply(nodeArgs).fail(deferred.reject);
	        return deferred.promise;
	    };
	};
	
	Promise.prototype.nfbind =
	Promise.prototype.denodeify = function (/*...args*/) {
	    var args = array_slice(arguments);
	    args.unshift(this);
	    return Q.denodeify.apply(void 0, args);
	};
	
	Q.nbind = function (callback, thisp /*...args*/) {
	    var baseArgs = array_slice(arguments, 2);
	    return function () {
	        var nodeArgs = baseArgs.concat(array_slice(arguments));
	        var deferred = defer();
	        nodeArgs.push(deferred.makeNodeResolver());
	        function bound() {
	            return callback.apply(thisp, arguments);
	        }
	        Q(bound).fapply(nodeArgs).fail(deferred.reject);
	        return deferred.promise;
	    };
	};
	
	Promise.prototype.nbind = function (/*thisp, ...args*/) {
	    var args = array_slice(arguments, 0);
	    args.unshift(this);
	    return Q.nbind.apply(void 0, args);
	};
	
	/**
	 * Calls a method of a Node-style object that accepts a Node-style
	 * callback with a given array of arguments, plus a provided callback.
	 * @param object an object that has the named method
	 * @param {String} name name of the method of object
	 * @param {Array} args arguments to pass to the method; the callback
	 * will be provided by Q and appended to these arguments.
	 * @returns a promise for the value or error
	 */
	Q.nmapply = // XXX As proposed by "Redsandro"
	Q.npost = function (object, name, args) {
	    return Q(object).npost(name, args);
	};
	
	Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
	Promise.prototype.npost = function (name, args) {
	    var nodeArgs = array_slice(args || []);
	    var deferred = defer();
	    nodeArgs.push(deferred.makeNodeResolver());
	    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
	    return deferred.promise;
	};
	
	/**
	 * Calls a method of a Node-style object that accepts a Node-style
	 * callback, forwarding the given variadic arguments, plus a provided
	 * callback argument.
	 * @param object an object that has the named method
	 * @param {String} name name of the method of object
	 * @param ...args arguments to pass to the method; the callback will
	 * be provided by Q and appended to these arguments.
	 * @returns a promise for the value or error
	 */
	Q.nsend = // XXX Based on Mark Miller's proposed "send"
	Q.nmcall = // XXX Based on "Redsandro's" proposal
	Q.ninvoke = function (object, name /*...args*/) {
	    var nodeArgs = array_slice(arguments, 2);
	    var deferred = defer();
	    nodeArgs.push(deferred.makeNodeResolver());
	    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
	    return deferred.promise;
	};
	
	Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
	Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
	Promise.prototype.ninvoke = function (name /*...args*/) {
	    var nodeArgs = array_slice(arguments, 1);
	    var deferred = defer();
	    nodeArgs.push(deferred.makeNodeResolver());
	    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
	    return deferred.promise;
	};
	
	/**
	 * If a function would like to support both Node continuation-passing-style and
	 * promise-returning-style, it can end its internal promise chain with
	 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
	 * elects to use a nodeback, the result will be sent there.  If they do not
	 * pass a nodeback, they will receive the result promise.
	 * @param object a result (or a promise for a result)
	 * @param {Function} nodeback a Node.js-style callback
	 * @returns either the promise or nothing
	 */
	Q.nodeify = nodeify;
	function nodeify(object, nodeback) {
	    return Q(object).nodeify(nodeback);
	}
	
	Promise.prototype.nodeify = function (nodeback) {
	    if (nodeback) {
	        this.then(function (value) {
	            nextTick(function () {
	                nodeback(null, value);
	            });
	        }, function (error) {
	            nextTick(function () {
	                nodeback(error);
	            });
	        });
	    } else {
	        return this;
	    }
	};
	
	// All code before this point will be filtered from stack traces.
	var qEndingLine = captureLine();
	
	return Q;
	
	});
	

}, 'xml2js/lib/xml2js.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'xml2js/lib/xml2js.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'xml2js/lib/xml2js.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'xml2js/lib/xml2js.js';
	var __dirname = 'xml2js/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', 'xml2js/lib/xml2js.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var bom, builder, events, isEmpty, sax,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
	
	  sax = require('sax');
	
	  events = require('events');
	
	  builder = require('xmlbuilder');
	
	  bom = require('./bom');
	
	  isEmpty = function(thing) {
	    return typeof thing === "object" && (thing != null) && Object.keys(thing).length === 0;
	  };
	
	  exports.defaults = {
	    "0.1": {
	      explicitCharkey: false,
	      trim: true,
	      normalize: true,
	      normalizeTags: false,
	      attrkey: "@",
	      charkey: "#",
	      explicitArray: false,
	      ignoreAttrs: false,
	      mergeAttrs: false,
	      explicitRoot: false,
	      validator: null,
	      xmlns: false,
	      explicitChildren: false,
	      childkey: '@@',
	      charsAsChildren: false,
	      async: false,
	      strict: true
	    },
	    "0.2": {
	      explicitCharkey: false,
	      trim: false,
	      normalize: false,
	      normalizeTags: false,
	      attrkey: "$",
	      charkey: "_",
	      explicitArray: true,
	      ignoreAttrs: false,
	      mergeAttrs: false,
	      explicitRoot: true,
	      validator: null,
	      xmlns: false,
	      explicitChildren: false,
	      childkey: '$$',
	      charsAsChildren: false,
	      async: false,
	      strict: true,
	      rootName: 'root',
	      xmldec: {
	        'version': '1.0',
	        'encoding': 'UTF-8',
	        'standalone': true
	      },
	      doctype: null,
	      renderOpts: {
	        'pretty': true,
	        'indent': '  ',
	        'newline': '\n'
	      }
	    }
	  };
	
	  exports.ValidationError = (function(_super) {
	    __extends(ValidationError, _super);
	
	    function ValidationError(message) {
	      this.message = message;
	    }
	
	    return ValidationError;
	
	  })(Error);
	
	  exports.Builder = (function() {
	    function Builder(opts) {
	      var key, value, _ref;
	      this.options = {};
	      _ref = exports.defaults["0.2"];
	      for (key in _ref) {
	        if (!__hasProp.call(_ref, key)) continue;
	        value = _ref[key];
	        this.options[key] = value;
	      }
	      for (key in opts) {
	        if (!__hasProp.call(opts, key)) continue;
	        value = opts[key];
	        this.options[key] = value;
	      }
	    }
	
	    Builder.prototype.buildObject = function(rootObj) {
	      var attrkey, charkey, render, rootElement, rootName;
	      attrkey = this.options.attrkey;
	      charkey = this.options.charkey;
	      if ((Object.keys(rootObj).length === 1) && (this.options.rootName === exports.defaults['0.2'].rootName)) {
	        rootName = Object.keys(rootObj)[0];
	        rootObj = rootObj[rootName];
	      } else {
	        rootName = this.options.rootName;
	      }
	      render = function(element, obj) {
	        var attr, child, entry, index, key, value, _ref, _ref1;
	        if (typeof obj !== 'object') {
	          element.txt(obj);
	        } else {
	          for (key in obj) {
	            if (!__hasProp.call(obj, key)) continue;
	            child = obj[key];
	            if (key === attrkey) {
	              if (typeof child === "object") {
	                for (attr in child) {
	                  value = child[attr];
	                  element = element.att(attr, value);
	                }
	              }
	            } else if (key === charkey) {
	              element = element.txt(child);
	            } else if (typeof child === 'object' && ((child != null ? child.constructor : void 0) != null) && ((child != null ? (_ref = child.constructor) != null ? _ref.name : void 0 : void 0) != null) && (child != null ? (_ref1 = child.constructor) != null ? _ref1.name : void 0 : void 0) === 'Array') {
	              for (index in child) {
	                if (!__hasProp.call(child, index)) continue;
	                entry = child[index];
	                if (typeof entry === 'string') {
	                  element = element.ele(key, entry).up();
	                } else {
	                  element = arguments.callee(element.ele(key), entry).up();
	                }
	              }
	            } else if (typeof child === "object") {
	              element = arguments.callee(element.ele(key), child).up();
	            } else {
	              element = element.ele(key, child.toString()).up();
	            }
	          }
	        }
	        return element;
	      };
	      rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype);
	      return render(rootElement, rootObj).end(this.options.renderOpts);
	    };
	
	    return Builder;
	
	  })();
	
	  exports.Parser = (function(_super) {
	    __extends(Parser, _super);
	
	    function Parser(opts) {
	      this.parseString = __bind(this.parseString, this);
	      this.reset = __bind(this.reset, this);
	      this.assignOrPush = __bind(this.assignOrPush, this);
	      var key, value, _ref;
	      if (!(this instanceof exports.Parser)) {
	        return new exports.Parser(opts);
	      }
	      this.options = {};
	      _ref = exports.defaults["0.2"];
	      for (key in _ref) {
	        if (!__hasProp.call(_ref, key)) continue;
	        value = _ref[key];
	        this.options[key] = value;
	      }
	      for (key in opts) {
	        if (!__hasProp.call(opts, key)) continue;
	        value = opts[key];
	        this.options[key] = value;
	      }
	      if (this.options.xmlns) {
	        this.options.xmlnskey = this.options.attrkey + "ns";
	      }
	      this.reset();
	    }
	
	    Parser.prototype.assignOrPush = function(obj, key, newValue) {
	      if (!(key in obj)) {
	        if (!this.options.explicitArray) {
	          return obj[key] = newValue;
	        } else {
	          return obj[key] = [newValue];
	        }
	      } else {
	        if (!(obj[key] instanceof Array)) {
	          obj[key] = [obj[key]];
	        }
	        return obj[key].push(newValue);
	      }
	    };
	
	    Parser.prototype.reset = function() {
	      var attrkey, charkey, err, ontext, stack,
	        _this = this;
	      this.removeAllListeners();
	      this.saxParser = sax.parser(this.options.strict, {
	        trim: false,
	        normalize: false,
	        xmlns: this.options.xmlns
	      });
	      err = false;
	      this.saxParser.onerror = function(error) {
	        if (!err) {
	          err = true;
	          return _this.emit("error", error);
	        }
	      };
	      this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
	      this.resultObject = null;
	      stack = [];
	      attrkey = this.options.attrkey;
	      charkey = this.options.charkey;
	      this.saxParser.onopentag = function(node) {
	        var key, newValue, obj, _ref;
	        obj = {};
	        obj[charkey] = "";
	        if (!_this.options.ignoreAttrs) {
	          _ref = node.attributes;
	          for (key in _ref) {
	            if (!__hasProp.call(_ref, key)) continue;
	            if (!(attrkey in obj) && !_this.options.mergeAttrs) {
	              obj[attrkey] = {};
	            }
	            newValue = node.attributes[key];
	            if (_this.options.mergeAttrs) {
	              _this.assignOrPush(obj, key, newValue);
	            } else {
	              obj[attrkey][key] = newValue;
	            }
	          }
	        }
	        obj["#name"] = _this.options.normalizeTags ? node.name.toLowerCase() : node.name;
	        if (_this.options.xmlns) {
	          obj[_this.options.xmlnskey] = {
	            uri: node.uri,
	            local: node.local
	          };
	        }
	        return stack.push(obj);
	      };
	      this.saxParser.onclosetag = function() {
	        var cdata, emptyStr, node, nodeName, obj, old, s, xpath;
	        obj = stack.pop();
	        nodeName = obj["#name"];
	        delete obj["#name"];
	        cdata = obj.cdata;
	        delete obj.cdata;
	        s = stack[stack.length - 1];
	        if (obj[charkey].match(/^\s*$/) && !cdata) {
	          emptyStr = obj[charkey];
	          delete obj[charkey];
	        } else {
	          if (_this.options.trim) {
	            obj[charkey] = obj[charkey].trim();
	          }
	          if (_this.options.normalize) {
	            obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
	          }
	          if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
	            obj = obj[charkey];
	          }
	        }
	        if (isEmpty(obj)) {
	          obj = _this.options.emptyTag !== void 0 ? _this.options.emptyTag : emptyStr;
	        }
	        if (_this.options.validator != null) {
	          xpath = "/" + ((function() {
	            var _i, _len, _results;
	            _results = [];
	            for (_i = 0, _len = stack.length; _i < _len; _i++) {
	              node = stack[_i];
	              _results.push(node["#name"]);
	            }
	            return _results;
	          })()).concat(nodeName).join("/");
	          try {
	            obj = _this.options.validator(xpath, s && s[nodeName], obj);
	          } catch (_error) {
	            err = _error;
	            _this.emit("error", err);
	          }
	        }
	        if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === 'object') {
	          node = {};
	          if (_this.options.attrkey in obj) {
	            node[_this.options.attrkey] = obj[_this.options.attrkey];
	            delete obj[_this.options.attrkey];
	          }
	          if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
	            node[_this.options.charkey] = obj[_this.options.charkey];
	            delete obj[_this.options.charkey];
	          }
	          if (Object.getOwnPropertyNames(obj).length > 0) {
	            node[_this.options.childkey] = obj;
	          }
	          obj = node;
	        }
	        if (stack.length > 0) {
	          return _this.assignOrPush(s, nodeName, obj);
	        } else {
	          if (_this.options.explicitRoot) {
	            old = obj;
	            obj = {};
	            obj[nodeName] = old;
	          }
	          _this.resultObject = obj;
	          return _this.emit("end", _this.resultObject);
	        }
	      };
	      ontext = function(text) {
	        var s;
	        s = stack[stack.length - 1];
	        if (s) {
	          s[charkey] += text;
	          return s;
	        }
	      };
	      this.saxParser.ontext = ontext;
	      return this.saxParser.oncdata = function(text) {
	        var s;
	        s = ontext(text);
	        if (s) {
	          return s.cdata = true;
	        }
	      };
	    };
	
	    Parser.prototype.parseString = function(str, cb) {
	      if ((cb != null) && typeof cb === "function") {
	        this.on("end", function(result) {
	          this.reset();
	          if (this.options.async) {
	            return process.nextTick(function() {
	              return cb(null, result);
	            });
	          } else {
	            return cb(null, result);
	          }
	        });
	        this.on("error", function(err) {
	          this.reset();
	          if (this.options.async) {
	            return process.nextTick(function() {
	              return cb(err);
	            });
	          } else {
	            return cb(err);
	          }
	        });
	      }
	      if (str.toString().trim() === '') {
	        this.emit("end", null);
	        return true;
	      }
	      return this.saxParser.write(bom.stripBOM(str.toString()));
	    };
	
	    return Parser;
	
	  })(events.EventEmitter);
	
	  exports.parseString = function(str, a, b) {
	    var cb, options, parser;
	    if (b != null) {
	      if (typeof b === 'function') {
	        cb = b;
	      }
	      if (typeof a === 'object') {
	        options = a;
	      }
	    } else {
	      if (typeof a === 'function') {
	        cb = a;
	      }
	      options = {};
	    }
	    parser = new exports.Parser(options);
	    return parser.parseString(str, cb);
	  };
	
	}).call(this);
	

}, 'sax/lib/sax.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/lib/sax.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/lib/sax.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/lib/sax.js';
	var __dirname = 'sax/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/lib/sax.js'], env: {}};

	/** code **/
	// wrapper for non-node envs
	;(function (sax) {
	
	sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
	sax.SAXParser = SAXParser
	sax.SAXStream = SAXStream
	sax.createStream = createStream
	
	// When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
	// When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
	// since that's the earliest that a buffer overrun could occur.  This way, checks are
	// as rare as required, but as often as necessary to ensure never crossing this bound.
	// Furthermore, buffers are only tested at most once per write(), so passing a very
	// large string into write() might have undesirable effects, but this is manageable by
	// the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
	// edge case, result in creating at most one complete copy of the string passed in.
	// Set to Infinity to have unlimited buffers.
	sax.MAX_BUFFER_LENGTH = 64 * 1024
	
	var buffers = [
	  "comment", "sgmlDecl", "textNode", "tagName", "doctype",
	  "procInstName", "procInstBody", "entity", "attribName",
	  "attribValue", "cdata", "script"
	]
	
	sax.EVENTS = // for discoverability.
	  [ "text"
	  , "processinginstruction"
	  , "sgmldeclaration"
	  , "doctype"
	  , "comment"
	  , "attribute"
	  , "opentag"
	  , "closetag"
	  , "opencdata"
	  , "cdata"
	  , "closecdata"
	  , "error"
	  , "end"
	  , "ready"
	  , "script"
	  , "opennamespace"
	  , "closenamespace"
	  ]
	
	function SAXParser (strict, opt) {
	  if (!(this instanceof SAXParser)) return new SAXParser(strict, opt)
	
	  var parser = this
	  clearBuffers(parser)
	  parser.q = parser.c = ""
	  parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
	  parser.opt = opt || {}
	  parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
	  parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase"
	  parser.tags = []
	  parser.closed = parser.closedRoot = parser.sawRoot = false
	  parser.tag = parser.error = null
	  parser.strict = !!strict
	  parser.noscript = !!(strict || parser.opt.noscript)
	  parser.state = S.BEGIN
	  parser.ENTITIES = Object.create(sax.ENTITIES)
	  parser.attribList = []
	
	  // namespaces form a prototype chain.
	  // it always points at the current tag,
	  // which protos to its parent tag.
	  if (parser.opt.xmlns) parser.ns = Object.create(rootNS)
	
	  // mostly just for error reporting
	  parser.trackPosition = parser.opt.position !== false
	  if (parser.trackPosition) {
	    parser.position = parser.line = parser.column = 0
	  }
	  emit(parser, "onready")
	}
	
	if (!Object.create) Object.create = function (o) {
	  function f () { this.__proto__ = o }
	  f.prototype = o
	  return new f
	}
	
	if (!Object.getPrototypeOf) Object.getPrototypeOf = function (o) {
	  return o.__proto__
	}
	
	if (!Object.keys) Object.keys = function (o) {
	  var a = []
	  for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
	  return a
	}
	
	function checkBufferLength (parser) {
	  var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
	    , maxActual = 0
	  for (var i = 0, l = buffers.length; i < l; i ++) {
	    var len = parser[buffers[i]].length
	    if (len > maxAllowed) {
	      // Text/cdata nodes can get big, and since they're buffered,
	      // we can get here under normal conditions.
	      // Avoid issues by emitting the text node now,
	      // so at least it won't get any bigger.
	      switch (buffers[i]) {
	        case "textNode":
	          closeText(parser)
	        break
	
	        case "cdata":
	          emitNode(parser, "oncdata", parser.cdata)
	          parser.cdata = ""
	        break
	
	        case "script":
	          emitNode(parser, "onscript", parser.script)
	          parser.script = ""
	        break
	
	        default:
	          error(parser, "Max buffer length exceeded: "+buffers[i])
	      }
	    }
	    maxActual = Math.max(maxActual, len)
	  }
	  // schedule the next check for the earliest possible buffer overrun.
	  parser.bufferCheckPosition = (sax.MAX_BUFFER_LENGTH - maxActual)
	                             + parser.position
	}
	
	function clearBuffers (parser) {
	  for (var i = 0, l = buffers.length; i < l; i ++) {
	    parser[buffers[i]] = ""
	  }
	}
	
	SAXParser.prototype =
	  { end: function () { end(this) }
	  , write: write
	  , resume: function () { this.error = null; return this }
	  , close: function () { return this.write(null) }
	  }
	
	try {
	  var Stream = require("stream").Stream
	} catch (ex) {
	  var Stream = function () {}
	}
	
	
	var streamWraps = sax.EVENTS.filter(function (ev) {
	  return ev !== "error" && ev !== "end"
	})
	
	function createStream (strict, opt) {
	  return new SAXStream(strict, opt)
	}
	
	function SAXStream (strict, opt) {
	  if (!(this instanceof SAXStream)) return new SAXStream(strict, opt)
	
	  Stream.apply(this)
	
	  this._parser = new SAXParser(strict, opt)
	  this.writable = true
	  this.readable = true
	
	
	  var me = this
	
	  this._parser.onend = function () {
	    me.emit("end")
	  }
	
	  this._parser.onerror = function (er) {
	    me.emit("error", er)
	
	    // if didn't throw, then means error was handled.
	    // go ahead and clear error, so we can write again.
	    me._parser.error = null
	  }
	
	  this._decoder = null;
	
	  streamWraps.forEach(function (ev) {
	    Object.defineProperty(me, "on" + ev, {
	      get: function () { return me._parser["on" + ev] },
	      set: function (h) {
	        if (!h) {
	          me.removeAllListeners(ev)
	          return me._parser["on"+ev] = h
	        }
	        me.on(ev, h)
	      },
	      enumerable: true,
	      configurable: false
	    })
	  })
	}
	
	SAXStream.prototype = Object.create(Stream.prototype,
	  { constructor: { value: SAXStream } })
	
	SAXStream.prototype.write = function (data) {
	  if (typeof Buffer === 'function' &&
	      typeof Buffer.isBuffer === 'function' &&
	      Buffer.isBuffer(data)) {
	    if (!this._decoder) {
	      var SD = require('string_decoder').StringDecoder
	      this._decoder = new SD('utf8')
	    }
	    data = this._decoder.write(data);
	  }
	
	  this._parser.write(data.toString())
	  this.emit("data", data)
	  return true
	}
	
	SAXStream.prototype.end = function (chunk) {
	  if (chunk && chunk.length) this.write(chunk)
	  else if (this.leftovers) this._parser.write(this.leftovers.toString())
	  this._parser.end()
	  return true
	}
	
	SAXStream.prototype.on = function (ev, handler) {
	  var me = this
	  if (!me._parser["on"+ev] && streamWraps.indexOf(ev) !== -1) {
	    me._parser["on"+ev] = function () {
	      var args = arguments.length === 1 ? [arguments[0]]
	               : Array.apply(null, arguments)
	      args.splice(0, 0, ev)
	      me.emit.apply(me, args)
	    }
	  }
	
	  return Stream.prototype.on.call(me, ev, handler)
	}
	
	
	
	// character classes and tokens
	var whitespace = "\r\n\t "
	  // this really needs to be replaced with character classes.
	  // XML allows all manner of ridiculous numbers and digits.
	  , number = "0124356789"
	  , letter = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
	  // (Letter | "_" | ":")
	  , quote = "'\""
	  , entity = number+letter+"#"
	  , attribEnd = whitespace + ">"
	  , CDATA = "[CDATA["
	  , DOCTYPE = "DOCTYPE"
	  , XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace"
	  , XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/"
	  , rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }
	
	// turn all the string character sets into character class objects.
	whitespace = charClass(whitespace)
	number = charClass(number)
	letter = charClass(letter)
	
	// http://www.w3.org/TR/REC-xml/#NT-NameStartChar
	// This implementation works on strings, a single character at a time
	// as such, it cannot ever support astral-plane characters (10000-EFFFF)
	// without a significant breaking change to either this  parser, or the
	// JavaScript language.  Implementation of an emoji-capable xml parser
	// is left as an exercise for the reader.
	var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/
	
	var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/
	
	quote = charClass(quote)
	entity = charClass(entity)
	attribEnd = charClass(attribEnd)
	
	function charClass (str) {
	  return str.split("").reduce(function (s, c) {
	    s[c] = true
	    return s
	  }, {})
	}
	
	function isRegExp (c) {
	  return Object.prototype.toString.call(c) === '[object RegExp]'
	}
	
	function is (charclass, c) {
	  return isRegExp(charclass) ? !!c.match(charclass) : charclass[c]
	}
	
	function not (charclass, c) {
	  return !is(charclass, c)
	}
	
	var S = 0
	sax.STATE =
	{ BEGIN                     : S++
	, TEXT                      : S++ // general stuff
	, TEXT_ENTITY               : S++ // &amp and such.
	, OPEN_WAKA                 : S++ // <
	, SGML_DECL                 : S++ // <!BLARG
	, SGML_DECL_QUOTED          : S++ // <!BLARG foo "bar
	, DOCTYPE                   : S++ // <!DOCTYPE
	, DOCTYPE_QUOTED            : S++ // <!DOCTYPE "//blah
	, DOCTYPE_DTD               : S++ // <!DOCTYPE "//blah" [ ...
	, DOCTYPE_DTD_QUOTED        : S++ // <!DOCTYPE "//blah" [ "foo
	, COMMENT_STARTING          : S++ // <!-
	, COMMENT                   : S++ // <!--
	, COMMENT_ENDING            : S++ // <!-- blah -
	, COMMENT_ENDED             : S++ // <!-- blah --
	, CDATA                     : S++ // <![CDATA[ something
	, CDATA_ENDING              : S++ // ]
	, CDATA_ENDING_2            : S++ // ]]
	, PROC_INST                 : S++ // <?hi
	, PROC_INST_BODY            : S++ // <?hi there
	, PROC_INST_ENDING          : S++ // <?hi "there" ?
	, OPEN_TAG                  : S++ // <strong
	, OPEN_TAG_SLASH            : S++ // <strong /
	, ATTRIB                    : S++ // <a
	, ATTRIB_NAME               : S++ // <a foo
	, ATTRIB_NAME_SAW_WHITE     : S++ // <a foo _
	, ATTRIB_VALUE              : S++ // <a foo=
	, ATTRIB_VALUE_QUOTED       : S++ // <a foo="bar
	, ATTRIB_VALUE_UNQUOTED     : S++ // <a foo=bar
	, ATTRIB_VALUE_ENTITY_Q     : S++ // <foo bar="&quot;"
	, ATTRIB_VALUE_ENTITY_U     : S++ // <foo bar=&quot;
	, CLOSE_TAG                 : S++ // </a
	, CLOSE_TAG_SAW_WHITE       : S++ // </a   >
	, SCRIPT                    : S++ // <script> ...
	, SCRIPT_ENDING             : S++ // <script> ... <
	}
	
	sax.ENTITIES =
	{ "amp" : "&"
	, "gt" : ">"
	, "lt" : "<"
	, "quot" : "\""
	, "apos" : "'"
	, "AElig" : 198
	, "Aacute" : 193
	, "Acirc" : 194
	, "Agrave" : 192
	, "Aring" : 197
	, "Atilde" : 195
	, "Auml" : 196
	, "Ccedil" : 199
	, "ETH" : 208
	, "Eacute" : 201
	, "Ecirc" : 202
	, "Egrave" : 200
	, "Euml" : 203
	, "Iacute" : 205
	, "Icirc" : 206
	, "Igrave" : 204
	, "Iuml" : 207
	, "Ntilde" : 209
	, "Oacute" : 211
	, "Ocirc" : 212
	, "Ograve" : 210
	, "Oslash" : 216
	, "Otilde" : 213
	, "Ouml" : 214
	, "THORN" : 222
	, "Uacute" : 218
	, "Ucirc" : 219
	, "Ugrave" : 217
	, "Uuml" : 220
	, "Yacute" : 221
	, "aacute" : 225
	, "acirc" : 226
	, "aelig" : 230
	, "agrave" : 224
	, "aring" : 229
	, "atilde" : 227
	, "auml" : 228
	, "ccedil" : 231
	, "eacute" : 233
	, "ecirc" : 234
	, "egrave" : 232
	, "eth" : 240
	, "euml" : 235
	, "iacute" : 237
	, "icirc" : 238
	, "igrave" : 236
	, "iuml" : 239
	, "ntilde" : 241
	, "oacute" : 243
	, "ocirc" : 244
	, "ograve" : 242
	, "oslash" : 248
	, "otilde" : 245
	, "ouml" : 246
	, "szlig" : 223
	, "thorn" : 254
	, "uacute" : 250
	, "ucirc" : 251
	, "ugrave" : 249
	, "uuml" : 252
	, "yacute" : 253
	, "yuml" : 255
	, "copy" : 169
	, "reg" : 174
	, "nbsp" : 160
	, "iexcl" : 161
	, "cent" : 162
	, "pound" : 163
	, "curren" : 164
	, "yen" : 165
	, "brvbar" : 166
	, "sect" : 167
	, "uml" : 168
	, "ordf" : 170
	, "laquo" : 171
	, "not" : 172
	, "shy" : 173
	, "macr" : 175
	, "deg" : 176
	, "plusmn" : 177
	, "sup1" : 185
	, "sup2" : 178
	, "sup3" : 179
	, "acute" : 180
	, "micro" : 181
	, "para" : 182
	, "middot" : 183
	, "cedil" : 184
	, "ordm" : 186
	, "raquo" : 187
	, "frac14" : 188
	, "frac12" : 189
	, "frac34" : 190
	, "iquest" : 191
	, "times" : 215
	, "divide" : 247
	, "OElig" : 338
	, "oelig" : 339
	, "Scaron" : 352
	, "scaron" : 353
	, "Yuml" : 376
	, "fnof" : 402
	, "circ" : 710
	, "tilde" : 732
	, "Alpha" : 913
	, "Beta" : 914
	, "Gamma" : 915
	, "Delta" : 916
	, "Epsilon" : 917
	, "Zeta" : 918
	, "Eta" : 919
	, "Theta" : 920
	, "Iota" : 921
	, "Kappa" : 922
	, "Lambda" : 923
	, "Mu" : 924
	, "Nu" : 925
	, "Xi" : 926
	, "Omicron" : 927
	, "Pi" : 928
	, "Rho" : 929
	, "Sigma" : 931
	, "Tau" : 932
	, "Upsilon" : 933
	, "Phi" : 934
	, "Chi" : 935
	, "Psi" : 936
	, "Omega" : 937
	, "alpha" : 945
	, "beta" : 946
	, "gamma" : 947
	, "delta" : 948
	, "epsilon" : 949
	, "zeta" : 950
	, "eta" : 951
	, "theta" : 952
	, "iota" : 953
	, "kappa" : 954
	, "lambda" : 955
	, "mu" : 956
	, "nu" : 957
	, "xi" : 958
	, "omicron" : 959
	, "pi" : 960
	, "rho" : 961
	, "sigmaf" : 962
	, "sigma" : 963
	, "tau" : 964
	, "upsilon" : 965
	, "phi" : 966
	, "chi" : 967
	, "psi" : 968
	, "omega" : 969
	, "thetasym" : 977
	, "upsih" : 978
	, "piv" : 982
	, "ensp" : 8194
	, "emsp" : 8195
	, "thinsp" : 8201
	, "zwnj" : 8204
	, "zwj" : 8205
	, "lrm" : 8206
	, "rlm" : 8207
	, "ndash" : 8211
	, "mdash" : 8212
	, "lsquo" : 8216
	, "rsquo" : 8217
	, "sbquo" : 8218
	, "ldquo" : 8220
	, "rdquo" : 8221
	, "bdquo" : 8222
	, "dagger" : 8224
	, "Dagger" : 8225
	, "bull" : 8226
	, "hellip" : 8230
	, "permil" : 8240
	, "prime" : 8242
	, "Prime" : 8243
	, "lsaquo" : 8249
	, "rsaquo" : 8250
	, "oline" : 8254
	, "frasl" : 8260
	, "euro" : 8364
	, "image" : 8465
	, "weierp" : 8472
	, "real" : 8476
	, "trade" : 8482
	, "alefsym" : 8501
	, "larr" : 8592
	, "uarr" : 8593
	, "rarr" : 8594
	, "darr" : 8595
	, "harr" : 8596
	, "crarr" : 8629
	, "lArr" : 8656
	, "uArr" : 8657
	, "rArr" : 8658
	, "dArr" : 8659
	, "hArr" : 8660
	, "forall" : 8704
	, "part" : 8706
	, "exist" : 8707
	, "empty" : 8709
	, "nabla" : 8711
	, "isin" : 8712
	, "notin" : 8713
	, "ni" : 8715
	, "prod" : 8719
	, "sum" : 8721
	, "minus" : 8722
	, "lowast" : 8727
	, "radic" : 8730
	, "prop" : 8733
	, "infin" : 8734
	, "ang" : 8736
	, "and" : 8743
	, "or" : 8744
	, "cap" : 8745
	, "cup" : 8746
	, "int" : 8747
	, "there4" : 8756
	, "sim" : 8764
	, "cong" : 8773
	, "asymp" : 8776
	, "ne" : 8800
	, "equiv" : 8801
	, "le" : 8804
	, "ge" : 8805
	, "sub" : 8834
	, "sup" : 8835
	, "nsub" : 8836
	, "sube" : 8838
	, "supe" : 8839
	, "oplus" : 8853
	, "otimes" : 8855
	, "perp" : 8869
	, "sdot" : 8901
	, "lceil" : 8968
	, "rceil" : 8969
	, "lfloor" : 8970
	, "rfloor" : 8971
	, "lang" : 9001
	, "rang" : 9002
	, "loz" : 9674
	, "spades" : 9824
	, "clubs" : 9827
	, "hearts" : 9829
	, "diams" : 9830
	}
	
	Object.keys(sax.ENTITIES).forEach(function (key) {
	    var e = sax.ENTITIES[key]
	    var s = typeof e === 'number' ? String.fromCharCode(e) : e
	    sax.ENTITIES[key] = s
	})
	
	for (var S in sax.STATE) sax.STATE[sax.STATE[S]] = S
	
	// shorthand
	S = sax.STATE
	
	function emit (parser, event, data) {
	  parser[event] && parser[event](data)
	}
	
	function emitNode (parser, nodeType, data) {
	  if (parser.textNode) closeText(parser)
	  emit(parser, nodeType, data)
	}
	
	function closeText (parser) {
	  parser.textNode = textopts(parser.opt, parser.textNode)
	  if (parser.textNode) emit(parser, "ontext", parser.textNode)
	  parser.textNode = ""
	}
	
	function textopts (opt, text) {
	  if (opt.trim) text = text.trim()
	  if (opt.normalize) text = text.replace(/\s+/g, " ")
	  return text
	}
	
	function error (parser, er) {
	  closeText(parser)
	  if (parser.trackPosition) {
	    er += "\nLine: "+parser.line+
	          "\nColumn: "+parser.column+
	          "\nChar: "+parser.c
	  }
	  er = new Error(er)
	  parser.error = er
	  emit(parser, "onerror", er)
	  return parser
	}
	
	function end (parser) {
	  if (!parser.closedRoot) strictFail(parser, "Unclosed root tag")
	  if (parser.state !== S.TEXT) error(parser, "Unexpected end")
	  closeText(parser)
	  parser.c = ""
	  parser.closed = true
	  emit(parser, "onend")
	  SAXParser.call(parser, parser.strict, parser.opt)
	  return parser
	}
	
	function strictFail (parser, message) {
	  if (typeof parser !== 'object' || !(parser instanceof SAXParser))
	    throw new Error('bad call to strictFail');
	  if (parser.strict) error(parser, message)
	}
	
	function newTag (parser) {
	  if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
	  var parent = parser.tags[parser.tags.length - 1] || parser
	    , tag = parser.tag = { name : parser.tagName, attributes : {} }
	
	  // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
	  if (parser.opt.xmlns) tag.ns = parent.ns
	  parser.attribList.length = 0
	}
	
	function qname (name) {
	  var i = name.indexOf(":")
	    , qualName = i < 0 ? [ "", name ] : name.split(":")
	    , prefix = qualName[0]
	    , local = qualName[1]
	
	  // <x "xmlns"="http://foo">
	  if (name === "xmlns") {
	    prefix = "xmlns"
	    local = ""
	  }
	
	  return { prefix: prefix, local: local }
	}
	
	function attrib (parser) {
	  if (!parser.strict) parser.attribName = parser.attribName[parser.looseCase]()
	
	  if (parser.attribList.indexOf(parser.attribName) !== -1 ||
	      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
	    return parser.attribName = parser.attribValue = ""
	  }
	
	  if (parser.opt.xmlns) {
	    var qn = qname(parser.attribName)
	      , prefix = qn.prefix
	      , local = qn.local
	
	    if (prefix === "xmlns") {
	      // namespace binding attribute; push the binding into scope
	      if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
	        strictFail( parser
	                  , "xml: prefix must be bound to " + XML_NAMESPACE + "\n"
	                  + "Actual: " + parser.attribValue )
	      } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
	        strictFail( parser
	                  , "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\n"
	                  + "Actual: " + parser.attribValue )
	      } else {
	        var tag = parser.tag
	          , parent = parser.tags[parser.tags.length - 1] || parser
	        if (tag.ns === parent.ns) {
	          tag.ns = Object.create(parent.ns)
	        }
	        tag.ns[local] = parser.attribValue
	      }
	    }
	
	    // defer onattribute events until all attributes have been seen
	    // so any new bindings can take effect; preserve attribute order
	    // so deferred events can be emitted in document order
	    parser.attribList.push([parser.attribName, parser.attribValue])
	  } else {
	    // in non-xmlns mode, we can emit the event right away
	    parser.tag.attributes[parser.attribName] = parser.attribValue
	    emitNode( parser
	            , "onattribute"
	            , { name: parser.attribName
	              , value: parser.attribValue } )
	  }
	
	  parser.attribName = parser.attribValue = ""
	}
	
	function openTag (parser, selfClosing) {
	  if (parser.opt.xmlns) {
	    // emit namespace binding events
	    var tag = parser.tag
	
	    // add namespace info to tag
	    var qn = qname(parser.tagName)
	    tag.prefix = qn.prefix
	    tag.local = qn.local
	    tag.uri = tag.ns[qn.prefix] || ""
	
	    if (tag.prefix && !tag.uri) {
	      strictFail(parser, "Unbound namespace prefix: "
	                       + JSON.stringify(parser.tagName))
	      tag.uri = qn.prefix
	    }
	
	    var parent = parser.tags[parser.tags.length - 1] || parser
	    if (tag.ns && parent.ns !== tag.ns) {
	      Object.keys(tag.ns).forEach(function (p) {
	        emitNode( parser
	                , "onopennamespace"
	                , { prefix: p , uri: tag.ns[p] } )
	      })
	    }
	
	    // handle deferred onattribute events
	    // Note: do not apply default ns to attributes:
	    //   http://www.w3.org/TR/REC-xml-names/#defaulting
	    for (var i = 0, l = parser.attribList.length; i < l; i ++) {
	      var nv = parser.attribList[i]
	      var name = nv[0]
	        , value = nv[1]
	        , qualName = qname(name)
	        , prefix = qualName.prefix
	        , local = qualName.local
	        , uri = prefix == "" ? "" : (tag.ns[prefix] || "")
	        , a = { name: name
	              , value: value
	              , prefix: prefix
	              , local: local
	              , uri: uri
	              }
	
	      // if there's any attributes with an undefined namespace,
	      // then fail on them now.
	      if (prefix && prefix != "xmlns" && !uri) {
	        strictFail(parser, "Unbound namespace prefix: "
	                         + JSON.stringify(prefix))
	        a.uri = prefix
	      }
	      parser.tag.attributes[name] = a
	      emitNode(parser, "onattribute", a)
	    }
	    parser.attribList.length = 0
	  }
	
	  parser.tag.isSelfClosing = !!selfClosing
	
	  // process the tag
	  parser.sawRoot = true
	  parser.tags.push(parser.tag)
	  emitNode(parser, "onopentag", parser.tag)
	  if (!selfClosing) {
	    // special case for <script> in non-strict mode.
	    if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
	      parser.state = S.SCRIPT
	    } else {
	      parser.state = S.TEXT
	    }
	    parser.tag = null
	    parser.tagName = ""
	  }
	  parser.attribName = parser.attribValue = ""
	  parser.attribList.length = 0
	}
	
	function closeTag (parser) {
	  if (!parser.tagName) {
	    strictFail(parser, "Weird empty close tag.")
	    parser.textNode += "</>"
	    parser.state = S.TEXT
	    return
	  }
	
	  if (parser.script) {
	    if (parser.tagName !== "script") {
	      parser.script += "</" + parser.tagName + ">"
	      parser.tagName = ""
	      parser.state = S.SCRIPT
	      return
	    }
	    emitNode(parser, "onscript", parser.script)
	    parser.script = ""
	  }
	
	  // first make sure that the closing tag actually exists.
	  // <a><b></c></b></a> will close everything, otherwise.
	  var t = parser.tags.length
	  var tagName = parser.tagName
	  if (!parser.strict) tagName = tagName[parser.looseCase]()
	  var closeTo = tagName
	  while (t --) {
	    var close = parser.tags[t]
	    if (close.name !== closeTo) {
	      // fail the first time in strict mode
	      strictFail(parser, "Unexpected close tag")
	    } else break
	  }
	
	  // didn't find it.  we already failed for strict, so just abort.
	  if (t < 0) {
	    strictFail(parser, "Unmatched closing tag: "+parser.tagName)
	    parser.textNode += "</" + parser.tagName + ">"
	    parser.state = S.TEXT
	    return
	  }
	  parser.tagName = tagName
	  var s = parser.tags.length
	  while (s --> t) {
	    var tag = parser.tag = parser.tags.pop()
	    parser.tagName = parser.tag.name
	    emitNode(parser, "onclosetag", parser.tagName)
	
	    var x = {}
	    for (var i in tag.ns) x[i] = tag.ns[i]
	
	    var parent = parser.tags[parser.tags.length - 1] || parser
	    if (parser.opt.xmlns && tag.ns !== parent.ns) {
	      // remove namespace bindings introduced by tag
	      Object.keys(tag.ns).forEach(function (p) {
	        var n = tag.ns[p]
	        emitNode(parser, "onclosenamespace", { prefix: p, uri: n })
	      })
	    }
	  }
	  if (t === 0) parser.closedRoot = true
	  parser.tagName = parser.attribValue = parser.attribName = ""
	  parser.attribList.length = 0
	  parser.state = S.TEXT
	}
	
	function parseEntity (parser) {
	  var entity = parser.entity
	    , entityLC = entity.toLowerCase()
	    , num
	    , numStr = ""
	  if (parser.ENTITIES[entity])
	    return parser.ENTITIES[entity]
	  if (parser.ENTITIES[entityLC])
	    return parser.ENTITIES[entityLC]
	  entity = entityLC
	  if (entity.charAt(0) === "#") {
	    if (entity.charAt(1) === "x") {
	      entity = entity.slice(2)
	      num = parseInt(entity, 16)
	      numStr = num.toString(16)
	    } else {
	      entity = entity.slice(1)
	      num = parseInt(entity, 10)
	      numStr = num.toString(10)
	    }
	  }
	  entity = entity.replace(/^0+/, "")
	  if (numStr.toLowerCase() !== entity) {
	    strictFail(parser, "Invalid character entity")
	    return "&"+parser.entity + ";"
	  }
	  return String.fromCharCode(num)
	}
	
	function write (chunk) {
	  var parser = this
	  if (this.error) throw this.error
	  if (parser.closed) return error(parser,
	    "Cannot write after close. Assign an onready handler.")
	  if (chunk === null) return end(parser)
	  var i = 0, c = ""
	  while (parser.c = c = chunk.charAt(i++)) {
	    if (parser.trackPosition) {
	      parser.position ++
	      if (c === "\n") {
	        parser.line ++
	        parser.column = 0
	      } else parser.column ++
	    }
	    switch (parser.state) {
	
	      case S.BEGIN:
	        if (c === "<") {
	          parser.state = S.OPEN_WAKA
	          parser.startTagPosition = parser.position
	        } else if (not(whitespace,c)) {
	          // have to process this as a text node.
	          // weird, but happens.
	          strictFail(parser, "Non-whitespace before first tag.")
	          parser.textNode = c
	          parser.state = S.TEXT
	        }
	      continue
	
	      case S.TEXT:
	        if (parser.sawRoot && !parser.closedRoot) {
	          var starti = i-1
	          while (c && c!=="<" && c!=="&") {
	            c = chunk.charAt(i++)
	            if (c && parser.trackPosition) {
	              parser.position ++
	              if (c === "\n") {
	                parser.line ++
	                parser.column = 0
	              } else parser.column ++
	            }
	          }
	          parser.textNode += chunk.substring(starti, i-1)
	        }
	        if (c === "<") {
	          parser.state = S.OPEN_WAKA
	          parser.startTagPosition = parser.position
	        } else {
	          if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot))
	            strictFail(parser, "Text data outside of root node.")
	          if (c === "&") parser.state = S.TEXT_ENTITY
	          else parser.textNode += c
	        }
	      continue
	
	      case S.SCRIPT:
	        // only non-strict
	        if (c === "<") {
	          parser.state = S.SCRIPT_ENDING
	        } else parser.script += c
	      continue
	
	      case S.SCRIPT_ENDING:
	        if (c === "/") {
	          parser.state = S.CLOSE_TAG
	        } else {
	          parser.script += "<" + c
	          parser.state = S.SCRIPT
	        }
	      continue
	
	      case S.OPEN_WAKA:
	        // either a /, ?, !, or text is coming next.
	        if (c === "!") {
	          parser.state = S.SGML_DECL
	          parser.sgmlDecl = ""
	        } else if (is(whitespace, c)) {
	          // wait for it...
	        } else if (is(nameStart,c)) {
	          parser.state = S.OPEN_TAG
	          parser.tagName = c
	        } else if (c === "/") {
	          parser.state = S.CLOSE_TAG
	          parser.tagName = ""
	        } else if (c === "?") {
	          parser.state = S.PROC_INST
	          parser.procInstName = parser.procInstBody = ""
	        } else {
	          strictFail(parser, "Unencoded <")
	          // if there was some whitespace, then add that in.
	          if (parser.startTagPosition + 1 < parser.position) {
	            var pad = parser.position - parser.startTagPosition
	            c = new Array(pad).join(" ") + c
	          }
	          parser.textNode += "<" + c
	          parser.state = S.TEXT
	        }
	      continue
	
	      case S.SGML_DECL:
	        if ((parser.sgmlDecl+c).toUpperCase() === CDATA) {
	          emitNode(parser, "onopencdata")
	          parser.state = S.CDATA
	          parser.sgmlDecl = ""
	          parser.cdata = ""
	        } else if (parser.sgmlDecl+c === "--") {
	          parser.state = S.COMMENT
	          parser.comment = ""
	          parser.sgmlDecl = ""
	        } else if ((parser.sgmlDecl+c).toUpperCase() === DOCTYPE) {
	          parser.state = S.DOCTYPE
	          if (parser.doctype || parser.sawRoot) strictFail(parser,
	            "Inappropriately located doctype declaration")
	          parser.doctype = ""
	          parser.sgmlDecl = ""
	        } else if (c === ">") {
	          emitNode(parser, "onsgmldeclaration", parser.sgmlDecl)
	          parser.sgmlDecl = ""
	          parser.state = S.TEXT
	        } else if (is(quote, c)) {
	          parser.state = S.SGML_DECL_QUOTED
	          parser.sgmlDecl += c
	        } else parser.sgmlDecl += c
	      continue
	
	      case S.SGML_DECL_QUOTED:
	        if (c === parser.q) {
	          parser.state = S.SGML_DECL
	          parser.q = ""
	        }
	        parser.sgmlDecl += c
	      continue
	
	      case S.DOCTYPE:
	        if (c === ">") {
	          parser.state = S.TEXT
	          emitNode(parser, "ondoctype", parser.doctype)
	          parser.doctype = true // just remember that we saw it.
	        } else {
	          parser.doctype += c
	          if (c === "[") parser.state = S.DOCTYPE_DTD
	          else if (is(quote, c)) {
	            parser.state = S.DOCTYPE_QUOTED
	            parser.q = c
	          }
	        }
	      continue
	
	      case S.DOCTYPE_QUOTED:
	        parser.doctype += c
	        if (c === parser.q) {
	          parser.q = ""
	          parser.state = S.DOCTYPE
	        }
	      continue
	
	      case S.DOCTYPE_DTD:
	        parser.doctype += c
	        if (c === "]") parser.state = S.DOCTYPE
	        else if (is(quote,c)) {
	          parser.state = S.DOCTYPE_DTD_QUOTED
	          parser.q = c
	        }
	      continue
	
	      case S.DOCTYPE_DTD_QUOTED:
	        parser.doctype += c
	        if (c === parser.q) {
	          parser.state = S.DOCTYPE_DTD
	          parser.q = ""
	        }
	      continue
	
	      case S.COMMENT:
	        if (c === "-") parser.state = S.COMMENT_ENDING
	        else parser.comment += c
	      continue
	
	      case S.COMMENT_ENDING:
	        if (c === "-") {
	          parser.state = S.COMMENT_ENDED
	          parser.comment = textopts(parser.opt, parser.comment)
	          if (parser.comment) emitNode(parser, "oncomment", parser.comment)
	          parser.comment = ""
	        } else {
	          parser.comment += "-" + c
	          parser.state = S.COMMENT
	        }
	      continue
	
	      case S.COMMENT_ENDED:
	        if (c !== ">") {
	          strictFail(parser, "Malformed comment")
	          // allow <!-- blah -- bloo --> in non-strict mode,
	          // which is a comment of " blah -- bloo "
	          parser.comment += "--" + c
	          parser.state = S.COMMENT
	        } else parser.state = S.TEXT
	      continue
	
	      case S.CDATA:
	        if (c === "]") parser.state = S.CDATA_ENDING
	        else parser.cdata += c
	      continue
	
	      case S.CDATA_ENDING:
	        if (c === "]") parser.state = S.CDATA_ENDING_2
	        else {
	          parser.cdata += "]" + c
	          parser.state = S.CDATA
	        }
	      continue
	
	      case S.CDATA_ENDING_2:
	        if (c === ">") {
	          if (parser.cdata) emitNode(parser, "oncdata", parser.cdata)
	          emitNode(parser, "onclosecdata")
	          parser.cdata = ""
	          parser.state = S.TEXT
	        } else if (c === "]") {
	          parser.cdata += "]"
	        } else {
	          parser.cdata += "]]" + c
	          parser.state = S.CDATA
	        }
	      continue
	
	      case S.PROC_INST:
	        if (c === "?") parser.state = S.PROC_INST_ENDING
	        else if (is(whitespace, c)) parser.state = S.PROC_INST_BODY
	        else parser.procInstName += c
	      continue
	
	      case S.PROC_INST_BODY:
	        if (!parser.procInstBody && is(whitespace, c)) continue
	        else if (c === "?") parser.state = S.PROC_INST_ENDING
	        else parser.procInstBody += c
	      continue
	
	      case S.PROC_INST_ENDING:
	        if (c === ">") {
	          emitNode(parser, "onprocessinginstruction", {
	            name : parser.procInstName,
	            body : parser.procInstBody
	          })
	          parser.procInstName = parser.procInstBody = ""
	          parser.state = S.TEXT
	        } else {
	          parser.procInstBody += "?" + c
	          parser.state = S.PROC_INST_BODY
	        }
	      continue
	
	      case S.OPEN_TAG:
	        if (is(nameBody, c)) parser.tagName += c
	        else {
	          newTag(parser)
	          if (c === ">") openTag(parser)
	          else if (c === "/") parser.state = S.OPEN_TAG_SLASH
	          else {
	            if (not(whitespace, c)) strictFail(
	              parser, "Invalid character in tag name")
	            parser.state = S.ATTRIB
	          }
	        }
	      continue
	
	      case S.OPEN_TAG_SLASH:
	        if (c === ">") {
	          openTag(parser, true)
	          closeTag(parser)
	        } else {
	          strictFail(parser, "Forward-slash in opening tag not followed by >")
	          parser.state = S.ATTRIB
	        }
	      continue
	
	      case S.ATTRIB:
	        // haven't read the attribute name yet.
	        if (is(whitespace, c)) continue
	        else if (c === ">") openTag(parser)
	        else if (c === "/") parser.state = S.OPEN_TAG_SLASH
	        else if (is(nameStart, c)) {
	          parser.attribName = c
	          parser.attribValue = ""
	          parser.state = S.ATTRIB_NAME
	        } else strictFail(parser, "Invalid attribute name")
	      continue
	
	      case S.ATTRIB_NAME:
	        if (c === "=") parser.state = S.ATTRIB_VALUE
	        else if (c === ">") {
	          strictFail(parser, "Attribute without value")
	          parser.attribValue = parser.attribName
	          attrib(parser)
	          openTag(parser)
	        }
	        else if (is(whitespace, c)) parser.state = S.ATTRIB_NAME_SAW_WHITE
	        else if (is(nameBody, c)) parser.attribName += c
	        else strictFail(parser, "Invalid attribute name")
	      continue
	
	      case S.ATTRIB_NAME_SAW_WHITE:
	        if (c === "=") parser.state = S.ATTRIB_VALUE
	        else if (is(whitespace, c)) continue
	        else {
	          strictFail(parser, "Attribute without value")
	          parser.tag.attributes[parser.attribName] = ""
	          parser.attribValue = ""
	          emitNode(parser, "onattribute",
	                   { name : parser.attribName, value : "" })
	          parser.attribName = ""
	          if (c === ">") openTag(parser)
	          else if (is(nameStart, c)) {
	            parser.attribName = c
	            parser.state = S.ATTRIB_NAME
	          } else {
	            strictFail(parser, "Invalid attribute name")
	            parser.state = S.ATTRIB
	          }
	        }
	      continue
	
	      case S.ATTRIB_VALUE:
	        if (is(whitespace, c)) continue
	        else if (is(quote, c)) {
	          parser.q = c
	          parser.state = S.ATTRIB_VALUE_QUOTED
	        } else {
	          strictFail(parser, "Unquoted attribute value")
	          parser.state = S.ATTRIB_VALUE_UNQUOTED
	          parser.attribValue = c
	        }
	      continue
	
	      case S.ATTRIB_VALUE_QUOTED:
	        if (c !== parser.q) {
	          if (c === "&") parser.state = S.ATTRIB_VALUE_ENTITY_Q
	          else parser.attribValue += c
	          continue
	        }
	        attrib(parser)
	        parser.q = ""
	        parser.state = S.ATTRIB
	      continue
	
	      case S.ATTRIB_VALUE_UNQUOTED:
	        if (not(attribEnd,c)) {
	          if (c === "&") parser.state = S.ATTRIB_VALUE_ENTITY_U
	          else parser.attribValue += c
	          continue
	        }
	        attrib(parser)
	        if (c === ">") openTag(parser)
	        else parser.state = S.ATTRIB
	      continue
	
	      case S.CLOSE_TAG:
	        if (!parser.tagName) {
	          if (is(whitespace, c)) continue
	          else if (not(nameStart, c)) {
	            if (parser.script) {
	              parser.script += "</" + c
	              parser.state = S.SCRIPT
	            } else {
	              strictFail(parser, "Invalid tagname in closing tag.")
	            }
	          } else parser.tagName = c
	        }
	        else if (c === ">") closeTag(parser)
	        else if (is(nameBody, c)) parser.tagName += c
	        else if (parser.script) {
	          parser.script += "</" + parser.tagName
	          parser.tagName = ""
	          parser.state = S.SCRIPT
	        } else {
	          if (not(whitespace, c)) strictFail(parser,
	            "Invalid tagname in closing tag")
	          parser.state = S.CLOSE_TAG_SAW_WHITE
	        }
	      continue
	
	      case S.CLOSE_TAG_SAW_WHITE:
	        if (is(whitespace, c)) continue
	        if (c === ">") closeTag(parser)
	        else strictFail(parser, "Invalid characters in closing tag")
	      continue
	
	      case S.TEXT_ENTITY:
	      case S.ATTRIB_VALUE_ENTITY_Q:
	      case S.ATTRIB_VALUE_ENTITY_U:
	        switch(parser.state) {
	          case S.TEXT_ENTITY:
	            var returnState = S.TEXT, buffer = "textNode"
	          break
	
	          case S.ATTRIB_VALUE_ENTITY_Q:
	            var returnState = S.ATTRIB_VALUE_QUOTED, buffer = "attribValue"
	          break
	
	          case S.ATTRIB_VALUE_ENTITY_U:
	            var returnState = S.ATTRIB_VALUE_UNQUOTED, buffer = "attribValue"
	          break
	        }
	        if (c === ";") {
	          parser[buffer] += parseEntity(parser)
	          parser.entity = ""
	          parser.state = returnState
	        }
	        else if (is(entity, c)) parser.entity += c
	        else {
	          strictFail(parser, "Invalid character entity")
	          parser[buffer] += "&" + parser.entity + c
	          parser.entity = ""
	          parser.state = returnState
	        }
	      continue
	
	      default:
	        throw new Error(parser, "Unknown state: " + parser.state)
	    }
	  } // while
	  // cdata blocks can get very big under normal conditions. emit and move on.
	  // if (parser.state === S.CDATA && parser.cdata) {
	  //   emitNode(parser, "oncdata", parser.cdata)
	  //   parser.cdata = ""
	  // }
	  if (parser.position >= parser.bufferCheckPosition) checkBufferLength(parser)
	  return parser
	}
	
	})(typeof exports === "undefined" ? sax = {} : exports)
	

}, 'xmlbuilder/lib/index.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'xmlbuilder/lib/index.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'xmlbuilder/lib/index.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'xmlbuilder/lib/index.js';
	var __dirname = 'xmlbuilder/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', 'xmlbuilder/lib/index.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.1
	(function() {
	  var XMLBuilder;
	
	  XMLBuilder = require('./XMLBuilder');
	
	  module.exports.create = function(name, xmldec, doctype, options) {
	    return new XMLBuilder(name, xmldec, doctype, options).root();
	  };
	
	}).call(this);
	

}, 'xmlbuilder/lib/XMLBuilder.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'xmlbuilder/lib/XMLBuilder.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'xmlbuilder/lib/XMLBuilder.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'xmlbuilder/lib/XMLBuilder.js';
	var __dirname = 'xmlbuilder/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', 'xmlbuilder/lib/XMLBuilder.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.1
	(function() {
	  var XMLBuilder, XMLFragment, XMLStringifier, _;
	
	  _ = require('underscore');
	
	  XMLFragment = require('./XMLFragment');
	
	  XMLStringifier = require('./XMLStringifier');
	
	  XMLBuilder = (function() {
	
	    function XMLBuilder(name, xmldec, doctype, options) {
	      var child, decatts, docatts, root;
	      if (name == null) {
	        throw new Error("Root element needs a name");
	      }
	      this.children = [];
	      this.rootObject = null;
	      options = _.extend({
	        'version': '1.0'
	      }, xmldec, doctype, options);
	      this.stringify = new XMLStringifier(options);
	      name = this.stringify.eleName(name);
	      if (!(options != null ? options.headless : void 0)) {
	        decatts = {};
	        if (options.version != null) {
	          decatts.version = this.stringify.xmlVersion(options.version);
	        }
	        if (options.encoding != null) {
	          decatts.encoding = this.stringify.xmlEncoding(options.encoding);
	        }
	        if (options.standalone != null) {
	          decatts.standalone = this.stringify.xmlStandalone(options.standalone);
	        }
	        child = new XMLFragment(this, '?xml', decatts);
	        this.children.push(child);
	        docatts = {};
	        if (options.ext != null) {
	          docatts.ext = this.stringify.xmlExternalSubset(options.ext);
	        }
	        if (!_.isEmpty(docatts)) {
	          docatts.name = name;
	          child = new XMLFragment(this, '!DOCTYPE', docatts);
	          this.children.push(child);
	        }
	      }
	      root = new XMLFragment(this, name, {});
	      root.isRoot = true;
	      root.documentObject = this;
	      this.children.push(root);
	      this.rootObject = root;
	    }
	
	    XMLBuilder.prototype.root = function() {
	      return this.rootObject;
	    };
	
	    XMLBuilder.prototype.end = function(options) {
	      return toString(options);
	    };
	
	    XMLBuilder.prototype.toString = function(options) {
	      var child, r, _i, _len, _ref;
	      r = '';
	      _ref = this.children;
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        child = _ref[_i];
	        r += child.toString(options);
	      }
	      return r;
	    };
	
	    return XMLBuilder;
	
	  })();
	
	  module.exports = XMLBuilder;
	
	}).call(this);
	

}, 'underscore/underscore.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'underscore/underscore.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'underscore/underscore.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'underscore/underscore.js';
	var __dirname = 'underscore';
	var process = {cwd: function() {return '/';}, argv: ['node', 'underscore/underscore.js'], env: {}};

	/** code **/
	//     Underscore.js 1.5.2
	//     http://underscorejs.org
	//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Underscore may be freely distributed under the MIT license.
	
	(function() {
	
	  // Baseline setup
	  // --------------
	
	  // Establish the root object, `window` in the browser, or `exports` on the server.
	  var root = this;
	
	  // Save the previous value of the `_` variable.
	  var previousUnderscore = root._;
	
	  // Establish the object that gets returned to break out of a loop iteration.
	  var breaker = {};
	
	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
	
	  // Create quick reference variables for speed access to core prototypes.
	  var
	    push             = ArrayProto.push,
	    slice            = ArrayProto.slice,
	    concat           = ArrayProto.concat,
	    toString         = ObjProto.toString,
	    hasOwnProperty   = ObjProto.hasOwnProperty;
	
	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var
	    nativeForEach      = ArrayProto.forEach,
	    nativeMap          = ArrayProto.map,
	    nativeReduce       = ArrayProto.reduce,
	    nativeReduceRight  = ArrayProto.reduceRight,
	    nativeFilter       = ArrayProto.filter,
	    nativeEvery        = ArrayProto.every,
	    nativeSome         = ArrayProto.some,
	    nativeIndexOf      = ArrayProto.indexOf,
	    nativeLastIndexOf  = ArrayProto.lastIndexOf,
	    nativeIsArray      = Array.isArray,
	    nativeKeys         = Object.keys,
	    nativeBind         = FuncProto.bind;
	
	  // Create a safe reference to the Underscore object for use below.
	  var _ = function(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  };
	
	  // Export the Underscore object for **Node.js**, with
	  // backwards-compatibility for the old `require()` API. If we're in
	  // the browser, add `_` as a global object via a string identifier,
	  // for Closure Compiler "advanced" mode.
	  if (typeof exports !== 'undefined') {
	    if (typeof module !== 'undefined' && module.exports) {
	      exports = module.exports = _;
	    }
	    exports._ = _;
	  } else {
	    root._ = _;
	  }
	
	  // Current version.
	  _.VERSION = '1.5.2';
	
	  // Collection Functions
	  // --------------------
	
	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles objects with the built-in `forEach`, arrays, and raw objects.
	  // Delegates to **ECMAScript 5**'s native `forEach` if available.
	  var each = _.each = _.forEach = function(obj, iterator, context) {
	    if (obj == null) return;
	    if (nativeForEach && obj.forEach === nativeForEach) {
	      obj.forEach(iterator, context);
	    } else if (obj.length === +obj.length) {
	      for (var i = 0, length = obj.length; i < length; i++) {
	        if (iterator.call(context, obj[i], i, obj) === breaker) return;
	      }
	    } else {
	      var keys = _.keys(obj);
	      for (var i = 0, length = keys.length; i < length; i++) {
	        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
	      }
	    }
	  };
	
	  // Return the results of applying the iterator to each element.
	  // Delegates to **ECMAScript 5**'s native `map` if available.
	  _.map = _.collect = function(obj, iterator, context) {
	    var results = [];
	    if (obj == null) return results;
	    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
	    each(obj, function(value, index, list) {
	      results.push(iterator.call(context, value, index, list));
	    });
	    return results;
	  };
	
	  var reduceError = 'Reduce of empty array with no initial value';
	
	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
	  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
	    var initial = arguments.length > 2;
	    if (obj == null) obj = [];
	    if (nativeReduce && obj.reduce === nativeReduce) {
	      if (context) iterator = _.bind(iterator, context);
	      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
	    }
	    each(obj, function(value, index, list) {
	      if (!initial) {
	        memo = value;
	        initial = true;
	      } else {
	        memo = iterator.call(context, memo, value, index, list);
	      }
	    });
	    if (!initial) throw new TypeError(reduceError);
	    return memo;
	  };
	
	  // The right-associative version of reduce, also known as `foldr`.
	  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
	  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
	    var initial = arguments.length > 2;
	    if (obj == null) obj = [];
	    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
	      if (context) iterator = _.bind(iterator, context);
	      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
	    }
	    var length = obj.length;
	    if (length !== +length) {
	      var keys = _.keys(obj);
	      length = keys.length;
	    }
	    each(obj, function(value, index, list) {
	      index = keys ? keys[--length] : --length;
	      if (!initial) {
	        memo = obj[index];
	        initial = true;
	      } else {
	        memo = iterator.call(context, memo, obj[index], index, list);
	      }
	    });
	    if (!initial) throw new TypeError(reduceError);
	    return memo;
	  };
	
	  // Return the first value which passes a truth test. Aliased as `detect`.
	  _.find = _.detect = function(obj, iterator, context) {
	    var result;
	    any(obj, function(value, index, list) {
	      if (iterator.call(context, value, index, list)) {
	        result = value;
	        return true;
	      }
	    });
	    return result;
	  };
	
	  // Return all the elements that pass a truth test.
	  // Delegates to **ECMAScript 5**'s native `filter` if available.
	  // Aliased as `select`.
	  _.filter = _.select = function(obj, iterator, context) {
	    var results = [];
	    if (obj == null) return results;
	    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
	    each(obj, function(value, index, list) {
	      if (iterator.call(context, value, index, list)) results.push(value);
	    });
	    return results;
	  };
	
	  // Return all the elements for which a truth test fails.
	  _.reject = function(obj, iterator, context) {
	    return _.filter(obj, function(value, index, list) {
	      return !iterator.call(context, value, index, list);
	    }, context);
	  };
	
	  // Determine whether all of the elements match a truth test.
	  // Delegates to **ECMAScript 5**'s native `every` if available.
	  // Aliased as `all`.
	  _.every = _.all = function(obj, iterator, context) {
	    iterator || (iterator = _.identity);
	    var result = true;
	    if (obj == null) return result;
	    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
	    each(obj, function(value, index, list) {
	      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
	    });
	    return !!result;
	  };
	
	  // Determine if at least one element in the object matches a truth test.
	  // Delegates to **ECMAScript 5**'s native `some` if available.
	  // Aliased as `any`.
	  var any = _.some = _.any = function(obj, iterator, context) {
	    iterator || (iterator = _.identity);
	    var result = false;
	    if (obj == null) return result;
	    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
	    each(obj, function(value, index, list) {
	      if (result || (result = iterator.call(context, value, index, list))) return breaker;
	    });
	    return !!result;
	  };
	
	  // Determine if the array or object contains a given value (using `===`).
	  // Aliased as `include`.
	  _.contains = _.include = function(obj, target) {
	    if (obj == null) return false;
	    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
	    return any(obj, function(value) {
	      return value === target;
	    });
	  };
	
	  // Invoke a method (with arguments) on every item in a collection.
	  _.invoke = function(obj, method) {
	    var args = slice.call(arguments, 2);
	    var isFunc = _.isFunction(method);
	    return _.map(obj, function(value) {
	      return (isFunc ? method : value[method]).apply(value, args);
	    });
	  };
	
	  // Convenience version of a common use case of `map`: fetching a property.
	  _.pluck = function(obj, key) {
	    return _.map(obj, function(value){ return value[key]; });
	  };
	
	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  _.where = function(obj, attrs, first) {
	    if (_.isEmpty(attrs)) return first ? void 0 : [];
	    return _[first ? 'find' : 'filter'](obj, function(value) {
	      for (var key in attrs) {
	        if (attrs[key] !== value[key]) return false;
	      }
	      return true;
	    });
	  };
	
	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  _.findWhere = function(obj, attrs) {
	    return _.where(obj, attrs, true);
	  };
	
	  // Return the maximum element or (element-based computation).
	  // Can't optimize arrays of integers longer than 65,535 elements.
	  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
	  _.max = function(obj, iterator, context) {
	    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
	      return Math.max.apply(Math, obj);
	    }
	    if (!iterator && _.isEmpty(obj)) return -Infinity;
	    var result = {computed : -Infinity, value: -Infinity};
	    each(obj, function(value, index, list) {
	      var computed = iterator ? iterator.call(context, value, index, list) : value;
	      computed > result.computed && (result = {value : value, computed : computed});
	    });
	    return result.value;
	  };
	
	  // Return the minimum element (or element-based computation).
	  _.min = function(obj, iterator, context) {
	    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
	      return Math.min.apply(Math, obj);
	    }
	    if (!iterator && _.isEmpty(obj)) return Infinity;
	    var result = {computed : Infinity, value: Infinity};
	    each(obj, function(value, index, list) {
	      var computed = iterator ? iterator.call(context, value, index, list) : value;
	      computed < result.computed && (result = {value : value, computed : computed});
	    });
	    return result.value;
	  };
	
	  // Shuffle an array, using the modern version of the 
	  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
	  _.shuffle = function(obj) {
	    var rand;
	    var index = 0;
	    var shuffled = [];
	    each(obj, function(value) {
	      rand = _.random(index++);
	      shuffled[index - 1] = shuffled[rand];
	      shuffled[rand] = value;
	    });
	    return shuffled;
	  };
	
	  // Sample **n** random values from an array.
	  // If **n** is not specified, returns a single random element from the array.
	  // The internal `guard` argument allows it to work with `map`.
	  _.sample = function(obj, n, guard) {
	    if (arguments.length < 2 || guard) {
	      return obj[_.random(obj.length - 1)];
	    }
	    return _.shuffle(obj).slice(0, Math.max(0, n));
	  };
	
	  // An internal function to generate lookup iterators.
	  var lookupIterator = function(value) {
	    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
	  };
	
	  // Sort the object's values by a criterion produced by an iterator.
	  _.sortBy = function(obj, value, context) {
	    var iterator = lookupIterator(value);
	    return _.pluck(_.map(obj, function(value, index, list) {
	      return {
	        value: value,
	        index: index,
	        criteria: iterator.call(context, value, index, list)
	      };
	    }).sort(function(left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index - right.index;
	    }), 'value');
	  };
	
	  // An internal function used for aggregate "group by" operations.
	  var group = function(behavior) {
	    return function(obj, value, context) {
	      var result = {};
	      var iterator = value == null ? _.identity : lookupIterator(value);
	      each(obj, function(value, index) {
	        var key = iterator.call(context, value, index, obj);
	        behavior(result, key, value);
	      });
	      return result;
	    };
	  };
	
	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  _.groupBy = group(function(result, key, value) {
	    (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
	  });
	
	  // Indexes the object's values by a criterion, similar to `groupBy`, but for
	  // when you know that your index values will be unique.
	  _.indexBy = group(function(result, key, value) {
	    result[key] = value;
	  });
	
	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  _.countBy = group(function(result, key) {
	    _.has(result, key) ? result[key]++ : result[key] = 1;
	  });
	
	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  _.sortedIndex = function(array, obj, iterator, context) {
	    iterator = iterator == null ? _.identity : lookupIterator(iterator);
	    var value = iterator.call(context, obj);
	    var low = 0, high = array.length;
	    while (low < high) {
	      var mid = (low + high) >>> 1;
	      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
	    }
	    return low;
	  };
	
	  // Safely create a real, live array from anything iterable.
	  _.toArray = function(obj) {
	    if (!obj) return [];
	    if (_.isArray(obj)) return slice.call(obj);
	    if (obj.length === +obj.length) return _.map(obj, _.identity);
	    return _.values(obj);
	  };
	
	  // Return the number of elements in an object.
	  _.size = function(obj) {
	    if (obj == null) return 0;
	    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
	  };
	
	  // Array Functions
	  // ---------------
	
	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. Aliased as `head` and `take`. The **guard** check
	  // allows it to work with `_.map`.
	  _.first = _.head = _.take = function(array, n, guard) {
	    if (array == null) return void 0;
	    return (n == null) || guard ? array[0] : slice.call(array, 0, n);
	  };
	
	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N. The **guard** check allows it to work with
	  // `_.map`.
	  _.initial = function(array, n, guard) {
	    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
	  };
	
	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array. The **guard** check allows it to work with `_.map`.
	  _.last = function(array, n, guard) {
	    if (array == null) return void 0;
	    if ((n == null) || guard) {
	      return array[array.length - 1];
	    } else {
	      return slice.call(array, Math.max(array.length - n, 0));
	    }
	  };
	
	  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
	  // Especially useful on the arguments object. Passing an **n** will return
	  // the rest N values in the array. The **guard**
	  // check allows it to work with `_.map`.
	  _.rest = _.tail = _.drop = function(array, n, guard) {
	    return slice.call(array, (n == null) || guard ? 1 : n);
	  };
	
	  // Trim out all falsy values from an array.
	  _.compact = function(array) {
	    return _.filter(array, _.identity);
	  };
	
	  // Internal implementation of a recursive `flatten` function.
	  var flatten = function(input, shallow, output) {
	    if (shallow && _.every(input, _.isArray)) {
	      return concat.apply(output, input);
	    }
	    each(input, function(value) {
	      if (_.isArray(value) || _.isArguments(value)) {
	        shallow ? push.apply(output, value) : flatten(value, shallow, output);
	      } else {
	        output.push(value);
	      }
	    });
	    return output;
	  };
	
	  // Flatten out an array, either recursively (by default), or just one level.
	  _.flatten = function(array, shallow) {
	    return flatten(array, shallow, []);
	  };
	
	  // Return a version of the array that does not contain the specified value(s).
	  _.without = function(array) {
	    return _.difference(array, slice.call(arguments, 1));
	  };
	
	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // Aliased as `unique`.
	  _.uniq = _.unique = function(array, isSorted, iterator, context) {
	    if (_.isFunction(isSorted)) {
	      context = iterator;
	      iterator = isSorted;
	      isSorted = false;
	    }
	    var initial = iterator ? _.map(array, iterator, context) : array;
	    var results = [];
	    var seen = [];
	    each(initial, function(value, index) {
	      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
	        seen.push(value);
	        results.push(array[index]);
	      }
	    });
	    return results;
	  };
	
	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  _.union = function() {
	    return _.uniq(_.flatten(arguments, true));
	  };
	
	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  _.intersection = function(array) {
	    var rest = slice.call(arguments, 1);
	    return _.filter(_.uniq(array), function(item) {
	      return _.every(rest, function(other) {
	        return _.indexOf(other, item) >= 0;
	      });
	    });
	  };
	
	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  _.difference = function(array) {
	    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
	    return _.filter(array, function(value){ return !_.contains(rest, value); });
	  };
	
	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  _.zip = function() {
	    var length = _.max(_.pluck(arguments, "length").concat(0));
	    var results = new Array(length);
	    for (var i = 0; i < length; i++) {
	      results[i] = _.pluck(arguments, '' + i);
	    }
	    return results;
	  };
	
	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values.
	  _.object = function(list, values) {
	    if (list == null) return {};
	    var result = {};
	    for (var i = 0, length = list.length; i < length; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  };
	
	  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
	  // we need this function. Return the position of the first occurrence of an
	  // item in an array, or -1 if the item is not included in the array.
	  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  _.indexOf = function(array, item, isSorted) {
	    if (array == null) return -1;
	    var i = 0, length = array.length;
	    if (isSorted) {
	      if (typeof isSorted == 'number') {
	        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
	      } else {
	        i = _.sortedIndex(array, item);
	        return array[i] === item ? i : -1;
	      }
	    }
	    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
	    for (; i < length; i++) if (array[i] === item) return i;
	    return -1;
	  };
	
	  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
	  _.lastIndexOf = function(array, item, from) {
	    if (array == null) return -1;
	    var hasIndex = from != null;
	    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
	      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
	    }
	    var i = (hasIndex ? from : array.length);
	    while (i--) if (array[i] === item) return i;
	    return -1;
	  };
	
	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](http://docs.python.org/library/functions.html#range).
	  _.range = function(start, stop, step) {
	    if (arguments.length <= 1) {
	      stop = start || 0;
	      start = 0;
	    }
	    step = arguments[2] || 1;
	
	    var length = Math.max(Math.ceil((stop - start) / step), 0);
	    var idx = 0;
	    var range = new Array(length);
	
	    while(idx < length) {
	      range[idx++] = start;
	      start += step;
	    }
	
	    return range;
	  };
	
	  // Function (ahem) Functions
	  // ------------------
	
	  // Reusable constructor function for prototype setting.
	  var ctor = function(){};
	
	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  _.bind = function(func, context) {
	    var args, bound;
	    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
	    if (!_.isFunction(func)) throw new TypeError;
	    args = slice.call(arguments, 2);
	    return bound = function() {
	      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
	      ctor.prototype = func.prototype;
	      var self = new ctor;
	      ctor.prototype = null;
	      var result = func.apply(self, args.concat(slice.call(arguments)));
	      if (Object(result) === result) return result;
	      return self;
	    };
	  };
	
	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context.
	  _.partial = function(func) {
	    var args = slice.call(arguments, 1);
	    return function() {
	      return func.apply(this, args.concat(slice.call(arguments)));
	    };
	  };
	
	  // Bind all of an object's methods to that object. Useful for ensuring that
	  // all callbacks defined on an object belong to it.
	  _.bindAll = function(obj) {
	    var funcs = slice.call(arguments, 1);
	    if (funcs.length === 0) throw new Error("bindAll must be passed function names");
	    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
	    return obj;
	  };
	
	  // Memoize an expensive function by storing its results.
	  _.memoize = function(func, hasher) {
	    var memo = {};
	    hasher || (hasher = _.identity);
	    return function() {
	      var key = hasher.apply(this, arguments);
	      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
	    };
	  };
	
	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  _.delay = function(func, wait) {
	    var args = slice.call(arguments, 2);
	    return setTimeout(function(){ return func.apply(null, args); }, wait);
	  };
	
	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  _.defer = function(func) {
	    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
	  };
	
	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time. Normally, the throttled function will run
	  // as much as it can, without ever going more than once per `wait` duration;
	  // but if you'd like to disable the execution on the leading edge, pass
	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
	  _.throttle = function(func, wait, options) {
	    var context, args, result;
	    var timeout = null;
	    var previous = 0;
	    options || (options = {});
	    var later = function() {
	      previous = options.leading === false ? 0 : new Date;
	      timeout = null;
	      result = func.apply(context, args);
	    };
	    return function() {
	      var now = new Date;
	      if (!previous && options.leading === false) previous = now;
	      var remaining = wait - (now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0) {
	        clearTimeout(timeout);
	        timeout = null;
	        previous = now;
	        result = func.apply(context, args);
	      } else if (!timeout && options.trailing !== false) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };
	  };
	
	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  _.debounce = function(func, wait, immediate) {
	    var timeout, args, context, timestamp, result;
	    return function() {
	      context = this;
	      args = arguments;
	      timestamp = new Date();
	      var later = function() {
	        var last = (new Date()) - timestamp;
	        if (last < wait) {
	          timeout = setTimeout(later, wait - last);
	        } else {
	          timeout = null;
	          if (!immediate) result = func.apply(context, args);
	        }
	      };
	      var callNow = immediate && !timeout;
	      if (!timeout) {
	        timeout = setTimeout(later, wait);
	      }
	      if (callNow) result = func.apply(context, args);
	      return result;
	    };
	  };
	
	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  _.once = function(func) {
	    var ran = false, memo;
	    return function() {
	      if (ran) return memo;
	      ran = true;
	      memo = func.apply(this, arguments);
	      func = null;
	      return memo;
	    };
	  };
	
	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  _.wrap = function(func, wrapper) {
	    return function() {
	      var args = [func];
	      push.apply(args, arguments);
	      return wrapper.apply(this, args);
	    };
	  };
	
	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  _.compose = function() {
	    var funcs = arguments;
	    return function() {
	      var args = arguments;
	      for (var i = funcs.length - 1; i >= 0; i--) {
	        args = [funcs[i].apply(this, args)];
	      }
	      return args[0];
	    };
	  };
	
	  // Returns a function that will only be executed after being called N times.
	  _.after = function(times, func) {
	    return function() {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  };
	
	  // Object Functions
	  // ----------------
	
	  // Retrieve the names of an object's properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`
	  _.keys = nativeKeys || function(obj) {
	    if (obj !== Object(obj)) throw new TypeError('Invalid object');
	    var keys = [];
	    for (var key in obj) if (_.has(obj, key)) keys.push(key);
	    return keys;
	  };
	
	  // Retrieve the values of an object's properties.
	  _.values = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var values = new Array(length);
	    for (var i = 0; i < length; i++) {
	      values[i] = obj[keys[i]];
	    }
	    return values;
	  };
	
	  // Convert an object into a list of `[key, value]` pairs.
	  _.pairs = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var pairs = new Array(length);
	    for (var i = 0; i < length; i++) {
	      pairs[i] = [keys[i], obj[keys[i]]];
	    }
	    return pairs;
	  };
	
	  // Invert the keys and values of an object. The values must be serializable.
	  _.invert = function(obj) {
	    var result = {};
	    var keys = _.keys(obj);
	    for (var i = 0, length = keys.length; i < length; i++) {
	      result[obj[keys[i]]] = keys[i];
	    }
	    return result;
	  };
	
	  // Return a sorted list of the function names available on the object.
	  // Aliased as `methods`
	  _.functions = _.methods = function(obj) {
	    var names = [];
	    for (var key in obj) {
	      if (_.isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  };
	
	  // Extend a given object with all the properties in passed-in object(s).
	  _.extend = function(obj) {
	    each(slice.call(arguments, 1), function(source) {
	      if (source) {
	        for (var prop in source) {
	          obj[prop] = source[prop];
	        }
	      }
	    });
	    return obj;
	  };
	
	  // Return a copy of the object only containing the whitelisted properties.
	  _.pick = function(obj) {
	    var copy = {};
	    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
	    each(keys, function(key) {
	      if (key in obj) copy[key] = obj[key];
	    });
	    return copy;
	  };
	
	   // Return a copy of the object without the blacklisted properties.
	  _.omit = function(obj) {
	    var copy = {};
	    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
	    for (var key in obj) {
	      if (!_.contains(keys, key)) copy[key] = obj[key];
	    }
	    return copy;
	  };
	
	  // Fill in a given object with default properties.
	  _.defaults = function(obj) {
	    each(slice.call(arguments, 1), function(source) {
	      if (source) {
	        for (var prop in source) {
	          if (obj[prop] === void 0) obj[prop] = source[prop];
	        }
	      }
	    });
	    return obj;
	  };
	
	  // Create a (shallow-cloned) duplicate of an object.
	  _.clone = function(obj) {
	    if (!_.isObject(obj)) return obj;
	    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
	  };
	
	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  _.tap = function(obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  };
	
	  // Internal recursive comparison function for `isEqual`.
	  var eq = function(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
	    if (a === b) return a !== 0 || 1 / a == 1 / b;
	    // A strict comparison is necessary because `null == undefined`.
	    if (a == null || b == null) return a === b;
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className != toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, dates, and booleans are compared by value.
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return a == String(b);
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
	        // other numeric values.
	        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a == +b;
	      // RegExps are compared by their source patterns and flags.
	      case '[object RegExp]':
	        return a.source == b.source &&
	               a.global == b.global &&
	               a.multiline == b.multiline &&
	               a.ignoreCase == b.ignoreCase;
	    }
	    if (typeof a != 'object' || typeof b != 'object') return false;
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] == a) return bStack[length] == b;
	    }
	    // Objects with different constructors are not equivalent, but `Object`s
	    // from different frames are.
	    var aCtor = a.constructor, bCtor = b.constructor;
	    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
	                             _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
	      return false;
	    }
	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);
	    var size = 0, result = true;
	    // Recursively compare objects and arrays.
	    if (className == '[object Array]') {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      size = a.length;
	      result = size == b.length;
	      if (result) {
	        // Deep compare the contents, ignoring non-numeric properties.
	        while (size--) {
	          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
	        }
	      }
	    } else {
	      // Deep compare objects.
	      for (var key in a) {
	        if (_.has(a, key)) {
	          // Count the expected number of properties.
	          size++;
	          // Deep compare each member.
	          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
	        }
	      }
	      // Ensure that both objects contain the same number of properties.
	      if (result) {
	        for (key in b) {
	          if (_.has(b, key) && !(size--)) break;
	        }
	        result = !size;
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return result;
	  };
	
	  // Perform a deep comparison to check if two objects are equal.
	  _.isEqual = function(a, b) {
	    return eq(a, b, [], []);
	  };
	
	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  _.isEmpty = function(obj) {
	    if (obj == null) return true;
	    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
	    for (var key in obj) if (_.has(obj, key)) return false;
	    return true;
	  };
	
	  // Is a given value a DOM element?
	  _.isElement = function(obj) {
	    return !!(obj && obj.nodeType === 1);
	  };
	
	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  _.isArray = nativeIsArray || function(obj) {
	    return toString.call(obj) == '[object Array]';
	  };
	
	  // Is a given variable an object?
	  _.isObject = function(obj) {
	    return obj === Object(obj);
	  };
	
	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
	  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
	    _['is' + name] = function(obj) {
	      return toString.call(obj) == '[object ' + name + ']';
	    };
	  });
	
	  // Define a fallback version of the method in browsers (ahem, IE), where
	  // there isn't any inspectable "Arguments" type.
	  if (!_.isArguments(arguments)) {
	    _.isArguments = function(obj) {
	      return !!(obj && _.has(obj, 'callee'));
	    };
	  }
	
	  // Optimize `isFunction` if appropriate.
	  if (typeof (/./) !== 'function') {
	    _.isFunction = function(obj) {
	      return typeof obj === 'function';
	    };
	  }
	
	  // Is a given object a finite number?
	  _.isFinite = function(obj) {
	    return isFinite(obj) && !isNaN(parseFloat(obj));
	  };
	
	  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
	  _.isNaN = function(obj) {
	    return _.isNumber(obj) && obj != +obj;
	  };
	
	  // Is a given value a boolean?
	  _.isBoolean = function(obj) {
	    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
	  };
	
	  // Is a given value equal to null?
	  _.isNull = function(obj) {
	    return obj === null;
	  };
	
	  // Is a given variable undefined?
	  _.isUndefined = function(obj) {
	    return obj === void 0;
	  };
	
	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  _.has = function(obj, key) {
	    return hasOwnProperty.call(obj, key);
	  };
	
	  // Utility Functions
	  // -----------------
	
	  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
	  // previous owner. Returns a reference to the Underscore object.
	  _.noConflict = function() {
	    root._ = previousUnderscore;
	    return this;
	  };
	
	  // Keep the identity function around for default iterators.
	  _.identity = function(value) {
	    return value;
	  };
	
	  // Run a function **n** times.
	  _.times = function(n, iterator, context) {
	    var accum = Array(Math.max(0, n));
	    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
	    return accum;
	  };
	
	  // Return a random integer between min and max (inclusive).
	  _.random = function(min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  };
	
	  // List of HTML entities for escaping.
	  var entityMap = {
	    escape: {
	      '&': '&amp;',
	      '<': '&lt;',
	      '>': '&gt;',
	      '"': '&quot;',
	      "'": '&#x27;'
	    }
	  };
	  entityMap.unescape = _.invert(entityMap.escape);
	
	  // Regexes containing the keys and values listed immediately above.
	  var entityRegexes = {
	    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
	    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
	  };
	
	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  _.each(['escape', 'unescape'], function(method) {
	    _[method] = function(string) {
	      if (string == null) return '';
	      return ('' + string).replace(entityRegexes[method], function(match) {
	        return entityMap[method][match];
	      });
	    };
	  });
	
	  // If the value of the named `property` is a function then invoke it with the
	  // `object` as context; otherwise, return it.
	  _.result = function(object, property) {
	    if (object == null) return void 0;
	    var value = object[property];
	    return _.isFunction(value) ? value.call(object) : value;
	  };
	
	  // Add your own custom functions to the Underscore object.
	  _.mixin = function(obj) {
	    each(_.functions(obj), function(name) {
	      var func = _[name] = obj[name];
	      _.prototype[name] = function() {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return result.call(this, func.apply(_, args));
	      };
	    });
	  };
	
	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  _.uniqueId = function(prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  };
	
	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  _.templateSettings = {
	    evaluate    : /<%([\s\S]+?)%>/g,
	    interpolate : /<%=([\s\S]+?)%>/g,
	    escape      : /<%-([\s\S]+?)%>/g
	  };
	
	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;
	
	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'":      "'",
	    '\\':     '\\',
	    '\r':     'r',
	    '\n':     'n',
	    '\t':     't',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };
	
	  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
	
	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  _.template = function(text, data, settings) {
	    var render;
	    settings = _.defaults({}, settings, _.templateSettings);
	
	    // Combine delimiters into one regular expression via alternation.
	    var matcher = new RegExp([
	      (settings.escape || noMatch).source,
	      (settings.interpolate || noMatch).source,
	      (settings.evaluate || noMatch).source
	    ].join('|') + '|$', 'g');
	
	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset)
	        .replace(escaper, function(match) { return '\\' + escapes[match]; });
	
	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      }
	      if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      }
	      if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }
	      index = offset + match.length;
	      return match;
	    });
	    source += "';\n";
	
	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';
	
	    source = "var __t,__p='',__j=Array.prototype.join," +
	      "print=function(){__p+=__j.call(arguments,'');};\n" +
	      source + "return __p;\n";
	
	    try {
	      render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }
	
	    if (data) return render(data, _);
	    var template = function(data) {
	      return render.call(this, data, _);
	    };
	
	    // Provide the compiled function source as a convenience for precompilation.
	    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';
	
	    return template;
	  };
	
	  // Add a "chain" function, which will delegate to the wrapper.
	  _.chain = function(obj) {
	    return _(obj).chain();
	  };
	
	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.
	
	  // Helper function to continue chaining intermediate results.
	  var result = function(obj) {
	    return this._chain ? _(obj).chain() : obj;
	  };
	
	  // Add all of the Underscore functions to the wrapper object.
	  _.mixin(_);
	
	  // Add all mutator Array functions to the wrapper.
	  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
	      return result.call(this, obj);
	    };
	  });
	
	  // Add all accessor Array functions to the wrapper.
	  each(['concat', 'join', 'slice'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      return result.call(this, method.apply(this._wrapped, arguments));
	    };
	  });
	
	  _.extend(_.prototype, {
	
	    // Start chaining a wrapped Underscore object.
	    chain: function() {
	      this._chain = true;
	      return this;
	    },
	
	    // Extracts the result from a wrapped and chained object.
	    value: function() {
	      return this._wrapped;
	    }
	
	  });
	
	}).call(this);
	

}, 'xmlbuilder/lib/XMLFragment.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'xmlbuilder/lib/XMLFragment.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'xmlbuilder/lib/XMLFragment.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'xmlbuilder/lib/XMLFragment.js';
	var __dirname = 'xmlbuilder/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', 'xmlbuilder/lib/XMLFragment.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.1
	(function() {
	  var XMLFragment, _,
	    __hasProp = {}.hasOwnProperty;
	
	  _ = require('underscore');
	
	  XMLFragment = (function() {
	
	    function XMLFragment(parent, name, attributes, text) {
	      this.isRoot = false;
	      this.documentObject = null;
	      this.parent = parent;
	      this.name = name;
	      this.attributes = attributes;
	      this.value = text;
	      this.children = [];
	      this.instructions = [];
	      this.stringify = parent.stringify;
	    }
	
	    XMLFragment.prototype.element = function(name, attributes, text) {
	      var atts, child, key, val, _ref, _ref1;
	      if (name == null) {
	        throw new Error("Missing element name");
	      }
	      name = this.stringify.eleName(name);
	      if (attributes == null) {
	        attributes = {};
	      }
	      if (_.isString(attributes) && _.isObject(text)) {
	        _ref = [text, attributes], attributes = _ref[0], text = _ref[1];
	      } else if (_.isString(attributes)) {
	        _ref1 = [{}, attributes], attributes = _ref1[0], text = _ref1[1];
	      }
	      atts = {};
	      for (key in attributes) {
	        if (!__hasProp.call(attributes, key)) continue;
	        val = attributes[key];
	        key = this.stringify.attName(key);
	        val = this.stringify.attValue(val);
	        if ((key != null) && (val != null)) {
	          atts[key] = val;
	        }
	      }
	      child = new XMLFragment(this, name, atts);
	      if (text != null) {
	        text = this.stringify.eleText(text);
	        child.raw(text);
	      }
	      this.children.push(child);
	      return child;
	    };
	
	    XMLFragment.prototype.insertBefore = function(name, attributes, text) {
	      var atts, child, i, key, val, _ref, _ref1;
	      if (this.isRoot) {
	        throw new Error("Cannot insert elements at root level");
	      }
	      if (name == null) {
	        throw new Error("Missing element name");
	      }
	      name = this.stringify.eleName(name);
	      if (attributes == null) {
	        attributes = {};
	      }
	      if (_.isString(attributes) && _.isObject(text)) {
	        _ref = [text, attributes], attributes = _ref[0], text = _ref[1];
	      } else if (_.isString(attributes)) {
	        _ref1 = [{}, attributes], attributes = _ref1[0], text = _ref1[1];
	      }
	      atts = {};
	      for (key in attributes) {
	        if (!__hasProp.call(attributes, key)) continue;
	        val = attributes[key];
	        key = this.stringify.attName(key);
	        val = this.stringify.attValue(val);
	        if ((key != null) && (val != null)) {
	          atts[key] = val;
	        }
	      }
	      child = new XMLFragment(this.parent, name, atts);
	      if (text != null) {
	        text = this.stringify.eleText(text);
	        child.raw(text);
	      }
	      i = this.parent.children.indexOf(this);
	      this.parent.children.splice(i, 0, child);
	      return child;
	    };
	
	    XMLFragment.prototype.insertAfter = function(name, attributes, text) {
	      var atts, child, i, key, val, _ref, _ref1;
	      if (this.isRoot) {
	        throw new Error("Cannot insert elements at root level");
	      }
	      if (name == null) {
	        throw new Error("Missing element name");
	      }
	      name = this.stringify.eleName(name);
	      if (attributes == null) {
	        attributes = {};
	      }
	      if (_.isString(attributes) && _.isObject(text)) {
	        _ref = [text, attributes], attributes = _ref[0], text = _ref[1];
	      } else if (_.isString(attributes)) {
	        _ref1 = [{}, attributes], attributes = _ref1[0], text = _ref1[1];
	      }
	      atts = {};
	      for (key in attributes) {
	        if (!__hasProp.call(attributes, key)) continue;
	        val = attributes[key];
	        key = this.stringify.attName(key);
	        val = this.stringify.attValue(val);
	        if ((key != null) && (val != null)) {
	          atts[key] = val;
	        }
	      }
	      child = new XMLFragment(this.parent, name, atts);
	      if (text != null) {
	        text = this.stringify.eleText(text);
	        child.raw(text);
	      }
	      i = this.parent.children.indexOf(this);
	      this.parent.children.splice(i + 1, 0, child);
	      return child;
	    };
	
	    XMLFragment.prototype.remove = function() {
	      var i, _ref;
	      if (this.isRoot) {
	        throw new Error("Cannot remove the root element");
	      }
	      i = this.parent.children.indexOf(this);
	      [].splice.apply(this.parent.children, [i, i - i + 1].concat(_ref = [])), _ref;
	      return this.parent;
	    };
	
	    XMLFragment.prototype.text = function(value) {
	      var child;
	      if (value == null) {
	        throw new Error("Missing element text");
	      }
	      value = this.stringify.eleText(value);
	      child = new XMLFragment(this, '', {}, value);
	      this.children.push(child);
	      return this;
	    };
	
	    XMLFragment.prototype.cdata = function(value) {
	      var child;
	      if (value == null) {
	        throw new Error("Missing CDATA text");
	      }
	      value = this.stringify.cdata(value);
	      child = new XMLFragment(this, '', {}, value);
	      this.children.push(child);
	      return this;
	    };
	
	    XMLFragment.prototype.comment = function(value) {
	      var child;
	      if (value == null) {
	        throw new Error("Missing comment text");
	      }
	      value = this.stringify.comment(value);
	      child = new XMLFragment(this, '', {}, value);
	      this.children.push(child);
	      return this;
	    };
	
	    XMLFragment.prototype.raw = function(value) {
	      var child;
	      if (value == null) {
	        throw new Error("Missing raw text");
	      }
	      value = this.stringify.raw(value);
	      child = new XMLFragment(this, '', {}, value);
	      this.children.push(child);
	      return this;
	    };
	
	    XMLFragment.prototype.up = function() {
	      if (this.isRoot) {
	        throw new Error("This node has no parent. Use doc() if you need to get the document object.");
	      }
	      return this.parent;
	    };
	
	    XMLFragment.prototype.root = function() {
	      var child;
	      if (this.isRoot) {
	        return this;
	      }
	      child = this.parent;
	      while (!child.isRoot) {
	        child = child.parent;
	      }
	      return child;
	    };
	
	    XMLFragment.prototype.document = function() {
	      return this.root().documentObject;
	    };
	
	    XMLFragment.prototype.end = function(options) {
	      return this.document().toString(options);
	    };
	
	    XMLFragment.prototype.prev = function() {
	      var i;
	      if (this.isRoot) {
	        throw new Error("Root node has no siblings");
	      }
	      i = this.parent.children.indexOf(this);
	      if (i < 1) {
	        throw new Error("Already at the first node");
	      }
	      return this.parent.children[i - 1];
	    };
	
	    XMLFragment.prototype.next = function() {
	      var i;
	      if (this.isRoot) {
	        throw new Error("Root node has no siblings");
	      }
	      i = this.parent.children.indexOf(this);
	      if (i === -1 || i === this.parent.children.length - 1) {
	        throw new Error("Already at the last node");
	      }
	      return this.parent.children[i + 1];
	    };
	
	    XMLFragment.prototype.clone = function(deep) {
	      var clonedSelf;
	      clonedSelf = new XMLFragment(this.parent, this.name, this.attributes, this.value);
	      if (deep) {
	        this.children.forEach(function(child) {
	          var clonedChild;
	          clonedChild = child.clone(deep);
	          clonedChild.parent = clonedSelf;
	          return clonedSelf.children.push(clonedChild);
	        });
	      }
	      return clonedSelf;
	    };
	
	    XMLFragment.prototype.importXMLBuilder = function(xmlbuilder) {
	      var clonedRoot;
	      clonedRoot = xmlbuilder.root().clone(true);
	      clonedRoot.parent = this;
	      this.children.push(clonedRoot);
	      clonedRoot.isRoot = false;
	      return this;
	    };
	
	    XMLFragment.prototype.attribute = function(name, value) {
	      var _ref;
	      if (name == null) {
	        throw new Error("Missing attribute name");
	      }
	      if (value == null) {
	        throw new Error("Missing attribute value");
	      }
	      name = this.stringify.attName(name);
	      value = this.stringify.attValue(value);
	      if ((_ref = this.attributes) == null) {
	        this.attributes = {};
	      }
	      this.attributes[name] = value;
	      return this;
	    };
	
	    XMLFragment.prototype.removeAttribute = function(name) {
	      if (name == null) {
	        throw new Error("Missing attribute name");
	      }
	      name = this.stringify.attName(name);
	      delete this.attributes[name];
	      return this;
	    };
	
	    XMLFragment.prototype.instruction = function(target, value) {
	      var pi;
	      if (target == null) {
	        throw new Error("Missing instruction target");
	      }
	      if (value == null) {
	        value = '';
	      }
	      target = this.stringify.insTarget(target);
	      value = this.stringify.insValue(value);
	      pi = target;
	      if (value) {
	        pi += ' ';
	      }
	      pi += value;
	      this.instructions.push(pi);
	      return this;
	    };
	
	    XMLFragment.prototype.toString = function(options, level) {
	      var attName, attValue, child, indent, instruction, newline, pretty, r, space, _i, _j, _len, _len1, _ref, _ref1, _ref2;
	      pretty = (options != null) && options.pretty || false;
	      indent = (options != null) && options.indent || '  ';
	      newline = (options != null) && options.newline || '\n';
	      level || (level = 0);
	      space = new Array(level + 1).join(indent);
	      r = '';
	      _ref = this.instructions;
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        instruction = _ref[_i];
	        if (pretty) {
	          r += space;
	        }
	        r += '<?' + instruction + '?>';
	        if (pretty) {
	          r += newline;
	        }
	      }
	      if (pretty) {
	        r += space;
	      }
	      if (this.value == null) {
	        r += '<' + this.name;
	      } else {
	        r += '' + this.value;
	      }
	      _ref1 = this.attributes;
	      for (attName in _ref1) {
	        if (!__hasProp.call(_ref1, attName)) continue;
	        attValue = _ref1[attName];
	        if (this.name === '!DOCTYPE') {
	          r += ' ' + attValue;
	        } else {
	          r += ' ' + attName + '="' + attValue + '"';
	        }
	      }
	      if (this.children.length === 0) {
	        if (this.value == null) {
	          r += this.name === '?xml' ? '?>' : this.name === '!DOCTYPE' ? '>' : '/>';
	        }
	        if (pretty) {
	          r += newline;
	        }
	      } else if (pretty && this.children.length === 1 && (this.children[0].value != null)) {
	        r += '>';
	        r += this.children[0].value;
	        r += '</' + this.name + '>';
	        r += newline;
	      } else {
	        r += '>';
	        if (pretty) {
	          r += newline;
	        }
	        _ref2 = this.children;
	        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
	          child = _ref2[_j];
	          r += child.toString(options, level + 1);
	        }
	        if (pretty) {
	          r += space;
	        }
	        r += '</' + this.name + '>';
	        if (pretty) {
	          r += newline;
	        }
	      }
	      return r;
	    };
	
	    XMLFragment.prototype.ele = function(name, attributes, text) {
	      return this.element(name, attributes, text);
	    };
	
	    XMLFragment.prototype.txt = function(value) {
	      return this.text(value);
	    };
	
	    XMLFragment.prototype.dat = function(value) {
	      return this.cdata(value);
	    };
	
	    XMLFragment.prototype.att = function(name, value) {
	      return this.attribute(name, value);
	    };
	
	    XMLFragment.prototype.com = function(value) {
	      return this.comment(value);
	    };
	
	    XMLFragment.prototype.ins = function(target, value) {
	      return this.instruction(target, value);
	    };
	
	    XMLFragment.prototype.doc = function() {
	      return this.document();
	    };
	
	    XMLFragment.prototype.e = function(name, attributes, text) {
	      return this.element(name, attributes, text);
	    };
	
	    XMLFragment.prototype.t = function(value) {
	      return this.text(value);
	    };
	
	    XMLFragment.prototype.d = function(value) {
	      return this.cdata(value);
	    };
	
	    XMLFragment.prototype.a = function(name, value) {
	      return this.attribute(name, value);
	    };
	
	    XMLFragment.prototype.c = function(value) {
	      return this.comment(value);
	    };
	
	    XMLFragment.prototype.i = function(target, value) {
	      return this.instruction(target, value);
	    };
	
	    XMLFragment.prototype.r = function(value) {
	      return this.raw(value);
	    };
	
	    XMLFragment.prototype.u = function() {
	      return this.up();
	    };
	
	    return XMLFragment;
	
	  })();
	
	  module.exports = XMLFragment;
	
	}).call(this);
	

}, 'xmlbuilder/lib/XMLStringifier.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'xmlbuilder/lib/XMLStringifier.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'xmlbuilder/lib/XMLStringifier.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'xmlbuilder/lib/XMLStringifier.js';
	var __dirname = 'xmlbuilder/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', 'xmlbuilder/lib/XMLStringifier.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.1
	(function() {
	  var XMLStringifier,
	    _this = this,
	    __hasProp = {}.hasOwnProperty;
	
	  XMLStringifier = (function() {
	
	    function XMLStringifier(options) {
	      var key, value, _ref,
	        _this = this;
	      this.assertLegalChar = function(str) {
	        return XMLStringifier.prototype.assertLegalChar.apply(_this, arguments);
	      };
	      this.allowSurrogateChars = options != null ? options.allowSurrogateChars : void 0;
	      _ref = (options != null ? options.stringify : void 0) || {};
	      for (key in _ref) {
	        if (!__hasProp.call(_ref, key)) continue;
	        value = _ref[key];
	        this[key] = value;
	      }
	    }
	
	    XMLStringifier.prototype.eleName = function(val) {
	      val = '' + val || '';
	      return this.assertLegalChar(val);
	    };
	
	    XMLStringifier.prototype.eleText = function(val) {
	      val = '' + val || '';
	      return this.assertLegalChar(this.escape(val));
	    };
	
	    XMLStringifier.prototype.cdata = function(val) {
	      val = '' + val || '';
	      if (val.match(/]]>/)) {
	        throw new Error("Invalid CDATA text: " + val);
	      }
	      val = this.assertLegalChar(val);
	      return '<![CDATA[' + val + ']]>';
	    };
	
	    XMLStringifier.prototype.comment = function(val) {
	      val = '' + val || '';
	      if (val.match(/--/)) {
	        throw new Error("Comment text cannot contain double-hypen: " + val);
	      }
	      val = this.assertLegalChar(this.escape(val));
	      return '<!-- ' + val + ' -->';
	    };
	
	    XMLStringifier.prototype.raw = function(val) {
	      return '' + val || '';
	    };
	
	    XMLStringifier.prototype.attName = function(val) {
	      return '' + val || '';
	    };
	
	    XMLStringifier.prototype.attValue = function(val) {
	      val = '' + val || '';
	      return this.escape(val);
	    };
	
	    XMLStringifier.prototype.insTarget = function(val) {
	      return '' + val || '';
	    };
	
	    XMLStringifier.prototype.insValue = function(val) {
	      val = '' + val || '';
	      if (val.match(/\?>/)) {
	        throw new Error("Invalid processing instruction value: " + val);
	      }
	      return val;
	    };
	
	    XMLStringifier.prototype.xmlVersion = function(val) {
	      val = '' + val || '';
	      if (!val.match(/1\.[0-9]+/)) {
	        throw new Error("Invalid version number: " + val);
	      }
	      return val;
	    };
	
	    XMLStringifier.prototype.xmlEncoding = function(val) {
	      val = '' + val || '';
	      if (!val.match(/[A-Za-z](?:[A-Za-z0-9._-]|-)*/)) {
	        throw new Error("Invalid encoding: " + options.val);
	      }
	      return val;
	    };
	
	    XMLStringifier.prototype.xmlStandalone = function(val) {
	      if (val) {
	        return "yes";
	      } else {
	        return "no";
	      }
	    };
	
	    XMLStringifier.prototype.xmlExternalSubset = function(val) {
	      return '' + val || '';
	    };
	
	    XMLStringifier.prototype.assertLegalChar = function(str) {
	      var chars, chr;
	      if (this.allowSurrogateChars) {
	        chars = /[\u0000-\u0008\u000B-\u000C\u000E-\u001F\uFFFE-\uFFFF]/;
	      } else {
	        chars = /[\u0000-\u0008\u000B-\u000C\u000E-\u001F\uD800-\uDFFF\uFFFE-\uFFFF]/;
	      }
	      chr = str.match(chars);
	      if (chr) {
	        throw new Error("Invalid character (" + chr + ") in string: " + str + " at index " + chr.index);
	      }
	      return str;
	    };
	
	    XMLStringifier.prototype.escape = function(str) {
	      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/'/g, '&apos;').replace(/"/g, '&quot;');
	    };
	
	    return XMLStringifier;
	
	  })();
	
	  module.exports = XMLStringifier;
	
	}).call(this);
	

}, 'xml2js/lib/bom.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'xml2js/lib/bom.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'xml2js/lib/bom.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'xml2js/lib/bom.js';
	var __dirname = 'xml2js/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', 'xml2js/lib/bom.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var xml2js;
	
	  xml2js = require('../lib/xml2js');
	
	  exports.stripBOM = function(str) {
	    if (str[0] === '\uFEFF') {
	      return str.substring(1);
	    } else {
	      return str;
	    }
	  };
	
	}).call(this);
	

}, 'moment/moment.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'moment/moment.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'moment/moment.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'moment/moment.js';
	var __dirname = 'moment';
	var process = {cwd: function() {return '/';}, argv: ['node', 'moment/moment.js'], env: {}};

	/** code **/
	//! moment.js
	//! version : 2.4.0
	//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
	//! license : MIT
	//! momentjs.com
	
	(function (undefined) {
	
	    /************************************
	        Constants
	    ************************************/
	
	    var moment,
	        VERSION = "2.4.0",
	        round = Math.round,
	        i,
	
	        YEAR = 0,
	        MONTH = 1,
	        DATE = 2,
	        HOUR = 3,
	        MINUTE = 4,
	        SECOND = 5,
	        MILLISECOND = 6,
	
	        // internal storage for language config files
	        languages = {},
	
	        // check for nodeJS
	        hasModule = (typeof module !== 'undefined' && module.exports),
	
	        // ASP.NET json date format regex
	        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
	        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,
	
	        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
	        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
	        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,
	
	        // format tokens
	        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
	        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,
	
	        // parsing token regexes
	        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
	        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
	        parseTokenThreeDigits = /\d{3}/, // 000 - 999
	        parseTokenFourDigits = /\d{1,4}/, // 0 - 9999
	        parseTokenSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
	        parseTokenDigits = /\d+/, // nonzero number of digits
	        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
	        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/i, // +00:00 -00:00 +0000 -0000 or Z
	        parseTokenT = /T/i, // T (ISO seperator)
	        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
	
	        // preliminary iso regex
	        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000)
	        isoRegex = /^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d:?\d\d|Z)?)?$/,
	
	        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',
	
	        isoDates = [
	            'YYYY-MM-DD',
	            'GGGG-[W]WW',
	            'GGGG-[W]WW-E',
	            'YYYY-DDD'
	        ],
	
	        // iso time formats and regexes
	        isoTimes = [
	            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d{1,3}/],
	            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
	            ['HH:mm', /(T| )\d\d:\d\d/],
	            ['HH', /(T| )\d\d/]
	        ],
	
	        // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
	        parseTimezoneChunker = /([\+\-]|\d\d)/gi,
	
	        // getter and setter names
	        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
	        unitMillisecondFactors = {
	            'Milliseconds' : 1,
	            'Seconds' : 1e3,
	            'Minutes' : 6e4,
	            'Hours' : 36e5,
	            'Days' : 864e5,
	            'Months' : 2592e6,
	            'Years' : 31536e6
	        },
	
	        unitAliases = {
	            ms : 'millisecond',
	            s : 'second',
	            m : 'minute',
	            h : 'hour',
	            d : 'day',
	            D : 'date',
	            w : 'week',
	            W : 'isoWeek',
	            M : 'month',
	            y : 'year',
	            DDD : 'dayOfYear',
	            e : 'weekday',
	            E : 'isoWeekday',
	            gg: 'weekYear',
	            GG: 'isoWeekYear'
	        },
	
	        camelFunctions = {
	            dayofyear : 'dayOfYear',
	            isoweekday : 'isoWeekday',
	            isoweek : 'isoWeek',
	            weekyear : 'weekYear',
	            isoweekyear : 'isoWeekYear'
	        },
	
	        // format function strings
	        formatFunctions = {},
	
	        // tokens to ordinalize and pad
	        ordinalizeTokens = 'DDD w W M D d'.split(' '),
	        paddedTokens = 'M D H h m s w W'.split(' '),
	
	        formatTokenFunctions = {
	            M    : function () {
	                return this.month() + 1;
	            },
	            MMM  : function (format) {
	                return this.lang().monthsShort(this, format);
	            },
	            MMMM : function (format) {
	                return this.lang().months(this, format);
	            },
	            D    : function () {
	                return this.date();
	            },
	            DDD  : function () {
	                return this.dayOfYear();
	            },
	            d    : function () {
	                return this.day();
	            },
	            dd   : function (format) {
	                return this.lang().weekdaysMin(this, format);
	            },
	            ddd  : function (format) {
	                return this.lang().weekdaysShort(this, format);
	            },
	            dddd : function (format) {
	                return this.lang().weekdays(this, format);
	            },
	            w    : function () {
	                return this.week();
	            },
	            W    : function () {
	                return this.isoWeek();
	            },
	            YY   : function () {
	                return leftZeroFill(this.year() % 100, 2);
	            },
	            YYYY : function () {
	                return leftZeroFill(this.year(), 4);
	            },
	            YYYYY : function () {
	                return leftZeroFill(this.year(), 5);
	            },
	            gg   : function () {
	                return leftZeroFill(this.weekYear() % 100, 2);
	            },
	            gggg : function () {
	                return this.weekYear();
	            },
	            ggggg : function () {
	                return leftZeroFill(this.weekYear(), 5);
	            },
	            GG   : function () {
	                return leftZeroFill(this.isoWeekYear() % 100, 2);
	            },
	            GGGG : function () {
	                return this.isoWeekYear();
	            },
	            GGGGG : function () {
	                return leftZeroFill(this.isoWeekYear(), 5);
	            },
	            e : function () {
	                return this.weekday();
	            },
	            E : function () {
	                return this.isoWeekday();
	            },
	            a    : function () {
	                return this.lang().meridiem(this.hours(), this.minutes(), true);
	            },
	            A    : function () {
	                return this.lang().meridiem(this.hours(), this.minutes(), false);
	            },
	            H    : function () {
	                return this.hours();
	            },
	            h    : function () {
	                return this.hours() % 12 || 12;
	            },
	            m    : function () {
	                return this.minutes();
	            },
	            s    : function () {
	                return this.seconds();
	            },
	            S    : function () {
	                return toInt(this.milliseconds() / 100);
	            },
	            SS   : function () {
	                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
	            },
	            SSS  : function () {
	                return leftZeroFill(this.milliseconds(), 3);
	            },
	            SSSS : function () {
	                return leftZeroFill(this.milliseconds(), 3);
	            },
	            Z    : function () {
	                var a = -this.zone(),
	                    b = "+";
	                if (a < 0) {
	                    a = -a;
	                    b = "-";
	                }
	                return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
	            },
	            ZZ   : function () {
	                var a = -this.zone(),
	                    b = "+";
	                if (a < 0) {
	                    a = -a;
	                    b = "-";
	                }
	                return b + leftZeroFill(toInt(10 * a / 6), 4);
	            },
	            z : function () {
	                return this.zoneAbbr();
	            },
	            zz : function () {
	                return this.zoneName();
	            },
	            X    : function () {
	                return this.unix();
	            }
	        },
	
	        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];
	
	    function padToken(func, count) {
	        return function (a) {
	            return leftZeroFill(func.call(this, a), count);
	        };
	    }
	    function ordinalizeToken(func, period) {
	        return function (a) {
	            return this.lang().ordinal(func.call(this, a), period);
	        };
	    }
	
	    while (ordinalizeTokens.length) {
	        i = ordinalizeTokens.pop();
	        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
	    }
	    while (paddedTokens.length) {
	        i = paddedTokens.pop();
	        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
	    }
	    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);
	
	
	    /************************************
	        Constructors
	    ************************************/
	
	    function Language() {
	
	    }
	
	    // Moment prototype object
	    function Moment(config) {
	        checkOverflow(config);
	        extend(this, config);
	    }
	
	    // Duration Constructor
	    function Duration(duration) {
	        var normalizedInput = normalizeObjectUnits(duration),
	            years = normalizedInput.year || 0,
	            months = normalizedInput.month || 0,
	            weeks = normalizedInput.week || 0,
	            days = normalizedInput.day || 0,
	            hours = normalizedInput.hour || 0,
	            minutes = normalizedInput.minute || 0,
	            seconds = normalizedInput.second || 0,
	            milliseconds = normalizedInput.millisecond || 0;
	
	        // store reference to input for deterministic cloning
	        this._input = duration;
	
	        // representation for dateAddRemove
	        this._milliseconds = +milliseconds +
	            seconds * 1e3 + // 1000
	            minutes * 6e4 + // 1000 * 60
	            hours * 36e5; // 1000 * 60 * 60
	        // Because of dateAddRemove treats 24 hours as different from a
	        // day when working around DST, we need to store them separately
	        this._days = +days +
	            weeks * 7;
	        // It is impossible translate months into days without knowing
	        // which months you are are talking about, so we have to store
	        // it separately.
	        this._months = +months +
	            years * 12;
	
	        this._data = {};
	
	        this._bubble();
	    }
	
	    /************************************
	        Helpers
	    ************************************/
	
	
	    function extend(a, b) {
	        for (var i in b) {
	            if (b.hasOwnProperty(i)) {
	                a[i] = b[i];
	            }
	        }
	
	        if (b.hasOwnProperty("toString")) {
	            a.toString = b.toString;
	        }
	
	        if (b.hasOwnProperty("valueOf")) {
	            a.valueOf = b.valueOf;
	        }
	
	        return a;
	    }
	
	    function absRound(number) {
	        if (number < 0) {
	            return Math.ceil(number);
	        } else {
	            return Math.floor(number);
	        }
	    }
	
	    // left zero fill a number
	    // see http://jsperf.com/left-zero-filling for performance comparison
	    function leftZeroFill(number, targetLength) {
	        var output = number + '';
	        while (output.length < targetLength) {
	            output = '0' + output;
	        }
	        return output;
	    }
	
	    // helper function for _.addTime and _.subtractTime
	    function addOrSubtractDurationFromMoment(mom, duration, isAdding, ignoreUpdateOffset) {
	        var milliseconds = duration._milliseconds,
	            days = duration._days,
	            months = duration._months,
	            minutes,
	            hours;
	
	        if (milliseconds) {
	            mom._d.setTime(+mom._d + milliseconds * isAdding);
	        }
	        // store the minutes and hours so we can restore them
	        if (days || months) {
	            minutes = mom.minute();
	            hours = mom.hour();
	        }
	        if (days) {
	            mom.date(mom.date() + days * isAdding);
	        }
	        if (months) {
	            mom.month(mom.month() + months * isAdding);
	        }
	        if (milliseconds && !ignoreUpdateOffset) {
	            moment.updateOffset(mom);
	        }
	        // restore the minutes and hours after possibly changing dst
	        if (days || months) {
	            mom.minute(minutes);
	            mom.hour(hours);
	        }
	    }
	
	    // check if is an array
	    function isArray(input) {
	        return Object.prototype.toString.call(input) === '[object Array]';
	    }
	
	    function isDate(input) {
	        return  Object.prototype.toString.call(input) === '[object Date]' ||
	                input instanceof Date;
	    }
	
	    // compare two arrays, return the number of differences
	    function compareArrays(array1, array2, dontConvert) {
	        var len = Math.min(array1.length, array2.length),
	            lengthDiff = Math.abs(array1.length - array2.length),
	            diffs = 0,
	            i;
	        for (i = 0; i < len; i++) {
	            if ((dontConvert && array1[i] !== array2[i]) ||
	                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
	                diffs++;
	            }
	        }
	        return diffs + lengthDiff;
	    }
	
	    function normalizeUnits(units) {
	        if (units) {
	            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
	            units = unitAliases[units] || camelFunctions[lowered] || lowered;
	        }
	        return units;
	    }
	
	    function normalizeObjectUnits(inputObject) {
	        var normalizedInput = {},
	            normalizedProp,
	            prop,
	            index;
	
	        for (prop in inputObject) {
	            if (inputObject.hasOwnProperty(prop)) {
	                normalizedProp = normalizeUnits(prop);
	                if (normalizedProp) {
	                    normalizedInput[normalizedProp] = inputObject[prop];
	                }
	            }
	        }
	
	        return normalizedInput;
	    }
	
	    function makeList(field) {
	        var count, setter;
	
	        if (field.indexOf('week') === 0) {
	            count = 7;
	            setter = 'day';
	        }
	        else if (field.indexOf('month') === 0) {
	            count = 12;
	            setter = 'month';
	        }
	        else {
	            return;
	        }
	
	        moment[field] = function (format, index) {
	            var i, getter,
	                method = moment.fn._lang[field],
	                results = [];
	
	            if (typeof format === 'number') {
	                index = format;
	                format = undefined;
	            }
	
	            getter = function (i) {
	                var m = moment().utc().set(setter, i);
	                return method.call(moment.fn._lang, m, format || '');
	            };
	
	            if (index != null) {
	                return getter(index);
	            }
	            else {
	                for (i = 0; i < count; i++) {
	                    results.push(getter(i));
	                }
	                return results;
	            }
	        };
	    }
	
	    function toInt(argumentForCoercion) {
	        var coercedNumber = +argumentForCoercion,
	            value = 0;
	
	        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
	            if (coercedNumber >= 0) {
	                value = Math.floor(coercedNumber);
	            } else {
	                value = Math.ceil(coercedNumber);
	            }
	        }
	
	        return value;
	    }
	
	    function daysInMonth(year, month) {
	        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
	    }
	
	    function daysInYear(year) {
	        return isLeapYear(year) ? 366 : 365;
	    }
	
	    function isLeapYear(year) {
	        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
	    }
	
	    function checkOverflow(m) {
	        var overflow;
	        if (m._a && m._pf.overflow === -2) {
	            overflow =
	                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
	                m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
	                m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR :
	                m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
	                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
	                m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
	                -1;
	
	            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
	                overflow = DATE;
	            }
	
	            m._pf.overflow = overflow;
	        }
	    }
	
	    function initializeParsingFlags(config) {
	        config._pf = {
	            empty : false,
	            unusedTokens : [],
	            unusedInput : [],
	            overflow : -2,
	            charsLeftOver : 0,
	            nullInput : false,
	            invalidMonth : null,
	            invalidFormat : false,
	            userInvalidated : false,
	            iso: false
	        };
	    }
	
	    function isValid(m) {
	        if (m._isValid == null) {
	            m._isValid = !isNaN(m._d.getTime()) &&
	                m._pf.overflow < 0 &&
	                !m._pf.empty &&
	                !m._pf.invalidMonth &&
	                !m._pf.nullInput &&
	                !m._pf.invalidFormat &&
	                !m._pf.userInvalidated;
	
	            if (m._strict) {
	                m._isValid = m._isValid &&
	                    m._pf.charsLeftOver === 0 &&
	                    m._pf.unusedTokens.length === 0;
	            }
	        }
	        return m._isValid;
	    }
	
	    function normalizeLanguage(key) {
	        return key ? key.toLowerCase().replace('_', '-') : key;
	    }
	
	    /************************************
	        Languages
	    ************************************/
	
	
	    extend(Language.prototype, {
	
	        set : function (config) {
	            var prop, i;
	            for (i in config) {
	                prop = config[i];
	                if (typeof prop === 'function') {
	                    this[i] = prop;
	                } else {
	                    this['_' + i] = prop;
	                }
	            }
	        },
	
	        _months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
	        months : function (m) {
	            return this._months[m.month()];
	        },
	
	        _monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
	        monthsShort : function (m) {
	            return this._monthsShort[m.month()];
	        },
	
	        monthsParse : function (monthName) {
	            var i, mom, regex;
	
	            if (!this._monthsParse) {
	                this._monthsParse = [];
	            }
	
	            for (i = 0; i < 12; i++) {
	                // make the regex if we don't have it already
	                if (!this._monthsParse[i]) {
	                    mom = moment.utc([2000, i]);
	                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
	                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
	                }
	                // test the regex
	                if (this._monthsParse[i].test(monthName)) {
	                    return i;
	                }
	            }
	        },
	
	        _weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
	        weekdays : function (m) {
	            return this._weekdays[m.day()];
	        },
	
	        _weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
	        weekdaysShort : function (m) {
	            return this._weekdaysShort[m.day()];
	        },
	
	        _weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
	        weekdaysMin : function (m) {
	            return this._weekdaysMin[m.day()];
	        },
	
	        weekdaysParse : function (weekdayName) {
	            var i, mom, regex;
	
	            if (!this._weekdaysParse) {
	                this._weekdaysParse = [];
	            }
	
	            for (i = 0; i < 7; i++) {
	                // make the regex if we don't have it already
	                if (!this._weekdaysParse[i]) {
	                    mom = moment([2000, 1]).day(i);
	                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
	                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
	                }
	                // test the regex
	                if (this._weekdaysParse[i].test(weekdayName)) {
	                    return i;
	                }
	            }
	        },
	
	        _longDateFormat : {
	            LT : "h:mm A",
	            L : "MM/DD/YYYY",
	            LL : "MMMM D YYYY",
	            LLL : "MMMM D YYYY LT",
	            LLLL : "dddd, MMMM D YYYY LT"
	        },
	        longDateFormat : function (key) {
	            var output = this._longDateFormat[key];
	            if (!output && this._longDateFormat[key.toUpperCase()]) {
	                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
	                    return val.slice(1);
	                });
	                this._longDateFormat[key] = output;
	            }
	            return output;
	        },
	
	        isPM : function (input) {
	            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
	            // Using charAt should be more compatible.
	            return ((input + '').toLowerCase().charAt(0) === 'p');
	        },
	
	        _meridiemParse : /[ap]\.?m?\.?/i,
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? 'pm' : 'PM';
	            } else {
	                return isLower ? 'am' : 'AM';
	            }
	        },
	
	        _calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        calendar : function (key, mom) {
	            var output = this._calendar[key];
	            return typeof output === 'function' ? output.apply(mom) : output;
	        },
	
	        _relativeTime : {
	            future : "in %s",
	            past : "%s ago",
	            s : "a few seconds",
	            m : "a minute",
	            mm : "%d minutes",
	            h : "an hour",
	            hh : "%d hours",
	            d : "a day",
	            dd : "%d days",
	            M : "a month",
	            MM : "%d months",
	            y : "a year",
	            yy : "%d years"
	        },
	        relativeTime : function (number, withoutSuffix, string, isFuture) {
	            var output = this._relativeTime[string];
	            return (typeof output === 'function') ?
	                output(number, withoutSuffix, string, isFuture) :
	                output.replace(/%d/i, number);
	        },
	        pastFuture : function (diff, output) {
	            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
	            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
	        },
	
	        ordinal : function (number) {
	            return this._ordinal.replace("%d", number);
	        },
	        _ordinal : "%d",
	
	        preparse : function (string) {
	            return string;
	        },
	
	        postformat : function (string) {
	            return string;
	        },
	
	        week : function (mom) {
	            return weekOfYear(mom, this._week.dow, this._week.doy).week;
	        },
	
	        _week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        },
	
	        _invalidDate: 'Invalid date',
	        invalidDate: function () {
	            return this._invalidDate;
	        }
	    });
	
	    // Loads a language definition into the `languages` cache.  The function
	    // takes a key and optionally values.  If not in the browser and no values
	    // are provided, it will load the language file module.  As a convenience,
	    // this function also returns the language values.
	    function loadLang(key, values) {
	        values.abbr = key;
	        if (!languages[key]) {
	            languages[key] = new Language();
	        }
	        languages[key].set(values);
	        return languages[key];
	    }
	
	    // Remove a language from the `languages` cache. Mostly useful in tests.
	    function unloadLang(key) {
	        delete languages[key];
	    }
	
	    // Determines which language definition to use and returns it.
	    //
	    // With no parameters, it will return the global language.  If you
	    // pass in a language key, such as 'en', it will return the
	    // definition for 'en', so long as 'en' has already been loaded using
	    // moment.lang.
	    function getLangDefinition(key) {
	        var i = 0, j, lang, next, split,
	            get = function (k) {
	                if (!languages[k] && hasModule) {
	                    try {
	                        require('./lang/' + k);
	                    } catch (e) { }
	                }
	                return languages[k];
	            };
	
	        if (!key) {
	            return moment.fn._lang;
	        }
	
	        if (!isArray(key)) {
	            //short-circuit everything else
	            lang = get(key);
	            if (lang) {
	                return lang;
	            }
	            key = [key];
	        }
	
	        //pick the language from the array
	        //try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
	        //substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
	        while (i < key.length) {
	            split = normalizeLanguage(key[i]).split('-');
	            j = split.length;
	            next = normalizeLanguage(key[i + 1]);
	            next = next ? next.split('-') : null;
	            while (j > 0) {
	                lang = get(split.slice(0, j).join('-'));
	                if (lang) {
	                    return lang;
	                }
	                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
	                    //the next array item is better than a shallower substring of this one
	                    break;
	                }
	                j--;
	            }
	            i++;
	        }
	        return moment.fn._lang;
	    }
	
	    /************************************
	        Formatting
	    ************************************/
	
	
	    function removeFormattingTokens(input) {
	        if (input.match(/\[[\s\S]/)) {
	            return input.replace(/^\[|\]$/g, "");
	        }
	        return input.replace(/\\/g, "");
	    }
	
	    function makeFormatFunction(format) {
	        var array = format.match(formattingTokens), i, length;
	
	        for (i = 0, length = array.length; i < length; i++) {
	            if (formatTokenFunctions[array[i]]) {
	                array[i] = formatTokenFunctions[array[i]];
	            } else {
	                array[i] = removeFormattingTokens(array[i]);
	            }
	        }
	
	        return function (mom) {
	            var output = "";
	            for (i = 0; i < length; i++) {
	                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
	            }
	            return output;
	        };
	    }
	
	    // format date using native date object
	    function formatMoment(m, format) {
	
	        if (!m.isValid()) {
	            return m.lang().invalidDate();
	        }
	
	        format = expandFormat(format, m.lang());
	
	        if (!formatFunctions[format]) {
	            formatFunctions[format] = makeFormatFunction(format);
	        }
	
	        return formatFunctions[format](m);
	    }
	
	    function expandFormat(format, lang) {
	        var i = 5;
	
	        function replaceLongDateFormatTokens(input) {
	            return lang.longDateFormat(input) || input;
	        }
	
	        localFormattingTokens.lastIndex = 0;
	        while (i >= 0 && localFormattingTokens.test(format)) {
	            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
	            localFormattingTokens.lastIndex = 0;
	            i -= 1;
	        }
	
	        return format;
	    }
	
	
	    /************************************
	        Parsing
	    ************************************/
	
	
	    // get the regex to find the next token
	    function getParseRegexForToken(token, config) {
	        var a;
	        switch (token) {
	        case 'DDDD':
	            return parseTokenThreeDigits;
	        case 'YYYY':
	        case 'GGGG':
	        case 'gggg':
	            return parseTokenFourDigits;
	        case 'YYYYY':
	        case 'GGGGG':
	        case 'ggggg':
	            return parseTokenSixDigits;
	        case 'S':
	        case 'SS':
	        case 'SSS':
	        case 'DDD':
	            return parseTokenOneToThreeDigits;
	        case 'MMM':
	        case 'MMMM':
	        case 'dd':
	        case 'ddd':
	        case 'dddd':
	            return parseTokenWord;
	        case 'a':
	        case 'A':
	            return getLangDefinition(config._l)._meridiemParse;
	        case 'X':
	            return parseTokenTimestampMs;
	        case 'Z':
	        case 'ZZ':
	            return parseTokenTimezone;
	        case 'T':
	            return parseTokenT;
	        case 'SSSS':
	            return parseTokenDigits;
	        case 'MM':
	        case 'DD':
	        case 'YY':
	        case 'GG':
	        case 'gg':
	        case 'HH':
	        case 'hh':
	        case 'mm':
	        case 'ss':
	        case 'M':
	        case 'D':
	        case 'd':
	        case 'H':
	        case 'h':
	        case 'm':
	        case 's':
	        case 'w':
	        case 'ww':
	        case 'W':
	        case 'WW':
	        case 'e':
	        case 'E':
	            return parseTokenOneOrTwoDigits;
	        default :
	            a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), "i"));
	            return a;
	        }
	    }
	
	    function timezoneMinutesFromString(string) {
	        var tzchunk = (parseTokenTimezone.exec(string) || [])[0],
	            parts = (tzchunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
	            minutes = +(parts[1] * 60) + toInt(parts[2]);
	
	        return parts[0] === '+' ? -minutes : minutes;
	    }
	
	    // function to convert string input to date
	    function addTimeToArrayFromToken(token, input, config) {
	        var a, datePartArray = config._a;
	
	        switch (token) {
	        // MONTH
	        case 'M' : // fall through to MM
	        case 'MM' :
	            if (input != null) {
	                datePartArray[MONTH] = toInt(input) - 1;
	            }
	            break;
	        case 'MMM' : // fall through to MMMM
	        case 'MMMM' :
	            a = getLangDefinition(config._l).monthsParse(input);
	            // if we didn't find a month name, mark the date as invalid.
	            if (a != null) {
	                datePartArray[MONTH] = a;
	            } else {
	                config._pf.invalidMonth = input;
	            }
	            break;
	        // DAY OF MONTH
	        case 'D' : // fall through to DD
	        case 'DD' :
	            if (input != null) {
	                datePartArray[DATE] = toInt(input);
	            }
	            break;
	        // DAY OF YEAR
	        case 'DDD' : // fall through to DDDD
	        case 'DDDD' :
	            if (input != null) {
	                config._dayOfYear = toInt(input);
	            }
	
	            break;
	        // YEAR
	        case 'YY' :
	            datePartArray[YEAR] = toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
	            break;
	        case 'YYYY' :
	        case 'YYYYY' :
	            datePartArray[YEAR] = toInt(input);
	            break;
	        // AM / PM
	        case 'a' : // fall through to A
	        case 'A' :
	            config._isPm = getLangDefinition(config._l).isPM(input);
	            break;
	        // 24 HOUR
	        case 'H' : // fall through to hh
	        case 'HH' : // fall through to hh
	        case 'h' : // fall through to hh
	        case 'hh' :
	            datePartArray[HOUR] = toInt(input);
	            break;
	        // MINUTE
	        case 'm' : // fall through to mm
	        case 'mm' :
	            datePartArray[MINUTE] = toInt(input);
	            break;
	        // SECOND
	        case 's' : // fall through to ss
	        case 'ss' :
	            datePartArray[SECOND] = toInt(input);
	            break;
	        // MILLISECOND
	        case 'S' :
	        case 'SS' :
	        case 'SSS' :
	        case 'SSSS' :
	            datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
	            break;
	        // UNIX TIMESTAMP WITH MS
	        case 'X':
	            config._d = new Date(parseFloat(input) * 1000);
	            break;
	        // TIMEZONE
	        case 'Z' : // fall through to ZZ
	        case 'ZZ' :
	            config._useUTC = true;
	            config._tzm = timezoneMinutesFromString(input);
	            break;
	        case 'w':
	        case 'ww':
	        case 'W':
	        case 'WW':
	        case 'd':
	        case 'dd':
	        case 'ddd':
	        case 'dddd':
	        case 'e':
	        case 'E':
	            token = token.substr(0, 1);
	            /* falls through */
	        case 'gg':
	        case 'gggg':
	        case 'GG':
	        case 'GGGG':
	        case 'GGGGG':
	            token = token.substr(0, 2);
	            if (input) {
	                config._w = config._w || {};
	                config._w[token] = input;
	            }
	            break;
	        }
	    }
	
	    // convert an array to a date.
	    // the array should mirror the parameters below
	    // note: all values past the year are optional and will default to the lowest possible value.
	    // [year, month, day , hour, minute, second, millisecond]
	    function dateFromConfig(config) {
	        var i, date, input = [], currentDate,
	            yearToUse, fixYear, w, temp, lang, weekday, week;
	
	        if (config._d) {
	            return;
	        }
	
	        currentDate = currentDateArray(config);
	
	        //compute day of the year from weeks and weekdays
	        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
	            fixYear = function (val) {
	                return val ?
	                  (val.length < 3 ? (parseInt(val, 10) > 68 ? '19' + val : '20' + val) : val) :
	                  (config._a[YEAR] == null ? moment().weekYear() : config._a[YEAR]);
	            };
	
	            w = config._w;
	            if (w.GG != null || w.W != null || w.E != null) {
	                temp = dayOfYearFromWeeks(fixYear(w.GG), w.W || 1, w.E, 4, 1);
	            }
	            else {
	                lang = getLangDefinition(config._l);
	                weekday = w.d != null ?  parseWeekday(w.d, lang) :
	                  (w.e != null ?  parseInt(w.e, 10) + lang._week.dow : 0);
	
	                week = parseInt(w.w, 10) || 1;
	
	                //if we're parsing 'd', then the low day numbers may be next week
	                if (w.d != null && weekday < lang._week.dow) {
	                    week++;
	                }
	
	                temp = dayOfYearFromWeeks(fixYear(w.gg), week, weekday, lang._week.doy, lang._week.dow);
	            }
	
	            config._a[YEAR] = temp.year;
	            config._dayOfYear = temp.dayOfYear;
	        }
	
	        //if the day of the year is set, figure out what it is
	        if (config._dayOfYear) {
	            yearToUse = config._a[YEAR] == null ? currentDate[YEAR] : config._a[YEAR];
	
	            if (config._dayOfYear > daysInYear(yearToUse)) {
	                config._pf._overflowDayOfYear = true;
	            }
	
	            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
	            config._a[MONTH] = date.getUTCMonth();
	            config._a[DATE] = date.getUTCDate();
	        }
	
	        // Default to current date.
	        // * if no year, month, day of month are given, default to today
	        // * if day of month is given, default month and year
	        // * if month is given, default only year
	        // * if year is given, don't default anything
	        for (i = 0; i < 3 && config._a[i] == null; ++i) {
	            config._a[i] = input[i] = currentDate[i];
	        }
	
	        // Zero out whatever was not defaulted, including time
	        for (; i < 7; i++) {
	            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
	        }
	
	        // add the offsets to the time to be parsed so that we can have a clean array for checking isValid
	        input[HOUR] += toInt((config._tzm || 0) / 60);
	        input[MINUTE] += toInt((config._tzm || 0) % 60);
	
	        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
	    }
	
	    function dateFromObject(config) {
	        var normalizedInput;
	
	        if (config._d) {
	            return;
	        }
	
	        normalizedInput = normalizeObjectUnits(config._i);
	        config._a = [
	            normalizedInput.year,
	            normalizedInput.month,
	            normalizedInput.day,
	            normalizedInput.hour,
	            normalizedInput.minute,
	            normalizedInput.second,
	            normalizedInput.millisecond
	        ];
	
	        dateFromConfig(config);
	    }
	
	    function currentDateArray(config) {
	        var now = new Date();
	        if (config._useUTC) {
	            return [
	                now.getUTCFullYear(),
	                now.getUTCMonth(),
	                now.getUTCDate()
	            ];
	        } else {
	            return [now.getFullYear(), now.getMonth(), now.getDate()];
	        }
	    }
	
	    // date from string and format string
	    function makeDateFromStringAndFormat(config) {
	
	        config._a = [];
	        config._pf.empty = true;
	
	        // This array is used to make a Date, either with `new Date` or `Date.UTC`
	        var lang = getLangDefinition(config._l),
	            string = '' + config._i,
	            i, parsedInput, tokens, token, skipped,
	            stringLength = string.length,
	            totalParsedInputLength = 0;
	
	        tokens = expandFormat(config._f, lang).match(formattingTokens) || [];
	
	        for (i = 0; i < tokens.length; i++) {
	            token = tokens[i];
	            parsedInput = (getParseRegexForToken(token, config).exec(string) || [])[0];
	            if (parsedInput) {
	                skipped = string.substr(0, string.indexOf(parsedInput));
	                if (skipped.length > 0) {
	                    config._pf.unusedInput.push(skipped);
	                }
	                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
	                totalParsedInputLength += parsedInput.length;
	            }
	            // don't parse if it's not a known token
	            if (formatTokenFunctions[token]) {
	                if (parsedInput) {
	                    config._pf.empty = false;
	                }
	                else {
	                    config._pf.unusedTokens.push(token);
	                }
	                addTimeToArrayFromToken(token, parsedInput, config);
	            }
	            else if (config._strict && !parsedInput) {
	                config._pf.unusedTokens.push(token);
	            }
	        }
	
	        // add remaining unparsed input length to the string
	        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
	        if (string.length > 0) {
	            config._pf.unusedInput.push(string);
	        }
	
	        // handle am pm
	        if (config._isPm && config._a[HOUR] < 12) {
	            config._a[HOUR] += 12;
	        }
	        // if is 12 am, change hours to 0
	        if (config._isPm === false && config._a[HOUR] === 12) {
	            config._a[HOUR] = 0;
	        }
	
	        dateFromConfig(config);
	        checkOverflow(config);
	    }
	
	    function unescapeFormat(s) {
	        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
	            return p1 || p2 || p3 || p4;
	        });
	    }
	
	    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
	    function regexpEscape(s) {
	        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	    }
	
	    // date from string and array of format strings
	    function makeDateFromStringAndArray(config) {
	        var tempConfig,
	            bestMoment,
	
	            scoreToBeat,
	            i,
	            currentScore;
	
	        if (config._f.length === 0) {
	            config._pf.invalidFormat = true;
	            config._d = new Date(NaN);
	            return;
	        }
	
	        for (i = 0; i < config._f.length; i++) {
	            currentScore = 0;
	            tempConfig = extend({}, config);
	            initializeParsingFlags(tempConfig);
	            tempConfig._f = config._f[i];
	            makeDateFromStringAndFormat(tempConfig);
	
	            if (!isValid(tempConfig)) {
	                continue;
	            }
	
	            // if there is any input that was not parsed add a penalty for that format
	            currentScore += tempConfig._pf.charsLeftOver;
	
	            //or tokens
	            currentScore += tempConfig._pf.unusedTokens.length * 10;
	
	            tempConfig._pf.score = currentScore;
	
	            if (scoreToBeat == null || currentScore < scoreToBeat) {
	                scoreToBeat = currentScore;
	                bestMoment = tempConfig;
	            }
	        }
	
	        extend(config, bestMoment || tempConfig);
	    }
	
	    // date from iso format
	    function makeDateFromString(config) {
	        var i,
	            string = config._i,
	            match = isoRegex.exec(string);
	
	        if (match) {
	            config._pf.iso = true;
	            for (i = 4; i > 0; i--) {
	                if (match[i]) {
	                    // match[5] should be "T" or undefined
	                    config._f = isoDates[i - 1] + (match[6] || " ");
	                    break;
	                }
	            }
	            for (i = 0; i < 4; i++) {
	                if (isoTimes[i][1].exec(string)) {
	                    config._f += isoTimes[i][0];
	                    break;
	                }
	            }
	            if (parseTokenTimezone.exec(string)) {
	                config._f += "Z";
	            }
	            makeDateFromStringAndFormat(config);
	        }
	        else {
	            config._d = new Date(string);
	        }
	    }
	
	    function makeDateFromInput(config) {
	        var input = config._i,
	            matched = aspNetJsonRegex.exec(input);
	
	        if (input === undefined) {
	            config._d = new Date();
	        } else if (matched) {
	            config._d = new Date(+matched[1]);
	        } else if (typeof input === 'string') {
	            makeDateFromString(config);
	        } else if (isArray(input)) {
	            config._a = input.slice(0);
	            dateFromConfig(config);
	        } else if (isDate(input)) {
	            config._d = new Date(+input);
	        } else if (typeof(input) === 'object') {
	            dateFromObject(config);
	        } else {
	            config._d = new Date(input);
	        }
	    }
	
	    function makeDate(y, m, d, h, M, s, ms) {
	        //can't just apply() to create a date:
	        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
	        var date = new Date(y, m, d, h, M, s, ms);
	
	        //the date constructor doesn't accept years < 1970
	        if (y < 1970) {
	            date.setFullYear(y);
	        }
	        return date;
	    }
	
	    function makeUTCDate(y) {
	        var date = new Date(Date.UTC.apply(null, arguments));
	        if (y < 1970) {
	            date.setUTCFullYear(y);
	        }
	        return date;
	    }
	
	    function parseWeekday(input, language) {
	        if (typeof input === 'string') {
	            if (!isNaN(input)) {
	                input = parseInt(input, 10);
	            }
	            else {
	                input = language.weekdaysParse(input);
	                if (typeof input !== 'number') {
	                    return null;
	                }
	            }
	        }
	        return input;
	    }
	
	    /************************************
	        Relative Time
	    ************************************/
	
	
	    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
	    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
	        return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	    }
	
	    function relativeTime(milliseconds, withoutSuffix, lang) {
	        var seconds = round(Math.abs(milliseconds) / 1000),
	            minutes = round(seconds / 60),
	            hours = round(minutes / 60),
	            days = round(hours / 24),
	            years = round(days / 365),
	            args = seconds < 45 && ['s', seconds] ||
	                minutes === 1 && ['m'] ||
	                minutes < 45 && ['mm', minutes] ||
	                hours === 1 && ['h'] ||
	                hours < 22 && ['hh', hours] ||
	                days === 1 && ['d'] ||
	                days <= 25 && ['dd', days] ||
	                days <= 45 && ['M'] ||
	                days < 345 && ['MM', round(days / 30)] ||
	                years === 1 && ['y'] || ['yy', years];
	        args[2] = withoutSuffix;
	        args[3] = milliseconds > 0;
	        args[4] = lang;
	        return substituteTimeAgo.apply({}, args);
	    }
	
	
	    /************************************
	        Week of Year
	    ************************************/
	
	
	    // firstDayOfWeek       0 = sun, 6 = sat
	    //                      the day of the week that starts the week
	    //                      (usually sunday or monday)
	    // firstDayOfWeekOfYear 0 = sun, 6 = sat
	    //                      the first week is the week that contains the first
	    //                      of this day of the week
	    //                      (eg. ISO weeks use thursday (4))
	    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
	        var end = firstDayOfWeekOfYear - firstDayOfWeek,
	            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
	            adjustedMoment;
	
	
	        if (daysToDayOfWeek > end) {
	            daysToDayOfWeek -= 7;
	        }
	
	        if (daysToDayOfWeek < end - 7) {
	            daysToDayOfWeek += 7;
	        }
	
	        adjustedMoment = moment(mom).add('d', daysToDayOfWeek);
	        return {
	            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
	            year: adjustedMoment.year()
	        };
	    }
	
	    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
	    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
	        var d = new Date(Date.UTC(year, 0)).getUTCDay(),
	            daysToAdd, dayOfYear;
	
	        weekday = weekday != null ? weekday : firstDayOfWeek;
	        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0);
	        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;
	
	        return {
	            year: dayOfYear > 0 ? year : year - 1,
	            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
	        };
	    }
	
	    /************************************
	        Top Level Functions
	    ************************************/
	
	    function makeMoment(config) {
	        var input = config._i,
	            format = config._f;
	
	        if (typeof config._pf === 'undefined') {
	            initializeParsingFlags(config);
	        }
	
	        if (input === null) {
	            return moment.invalid({nullInput: true});
	        }
	
	        if (typeof input === 'string') {
	            config._i = input = getLangDefinition().preparse(input);
	        }
	
	        if (moment.isMoment(input)) {
	            config = extend({}, input);
	
	            config._d = new Date(+input._d);
	        } else if (format) {
	            if (isArray(format)) {
	                makeDateFromStringAndArray(config);
	            } else {
	                makeDateFromStringAndFormat(config);
	            }
	        } else {
	            makeDateFromInput(config);
	        }
	
	        return new Moment(config);
	    }
	
	    moment = function (input, format, lang, strict) {
	        if (typeof(lang) === "boolean") {
	            strict = lang;
	            lang = undefined;
	        }
	        return makeMoment({
	            _i : input,
	            _f : format,
	            _l : lang,
	            _strict : strict,
	            _isUTC : false
	        });
	    };
	
	    // creating with utc
	    moment.utc = function (input, format, lang, strict) {
	        var m;
	
	        if (typeof(lang) === "boolean") {
	            strict = lang;
	            lang = undefined;
	        }
	        m = makeMoment({
	            _useUTC : true,
	            _isUTC : true,
	            _l : lang,
	            _i : input,
	            _f : format,
	            _strict : strict
	        }).utc();
	
	        return m;
	    };
	
	    // creating with unix timestamp (in seconds)
	    moment.unix = function (input) {
	        return moment(input * 1000);
	    };
	
	    // duration
	    moment.duration = function (input, key) {
	        var isDuration = moment.isDuration(input),
	            isNumber = (typeof input === 'number'),
	            duration = (isDuration ? input._input : (isNumber ? {} : input)),
	            // matching against regexp is expensive, do it on demand
	            match = null,
	            sign,
	            ret,
	            parseIso,
	            timeEmpty,
	            dateTimeEmpty;
	
	        if (isNumber) {
	            if (key) {
	                duration[key] = input;
	            } else {
	                duration.milliseconds = input;
	            }
	        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
	            sign = (match[1] === "-") ? -1 : 1;
	            duration = {
	                y: 0,
	                d: toInt(match[DATE]) * sign,
	                h: toInt(match[HOUR]) * sign,
	                m: toInt(match[MINUTE]) * sign,
	                s: toInt(match[SECOND]) * sign,
	                ms: toInt(match[MILLISECOND]) * sign
	            };
	        } else if (!!(match = isoDurationRegex.exec(input))) {
	            sign = (match[1] === "-") ? -1 : 1;
	            parseIso = function (inp) {
	                // We'd normally use ~~inp for this, but unfortunately it also
	                // converts floats to ints.
	                // inp may be undefined, so careful calling replace on it.
	                var res = inp && parseFloat(inp.replace(',', '.'));
	                // apply sign while we're at it
	                return (isNaN(res) ? 0 : res) * sign;
	            };
	            duration = {
	                y: parseIso(match[2]),
	                M: parseIso(match[3]),
	                d: parseIso(match[4]),
	                h: parseIso(match[5]),
	                m: parseIso(match[6]),
	                s: parseIso(match[7]),
	                w: parseIso(match[8])
	            };
	        }
	
	        ret = new Duration(duration);
	
	        if (isDuration && input.hasOwnProperty('_lang')) {
	            ret._lang = input._lang;
	        }
	
	        return ret;
	    };
	
	    // version number
	    moment.version = VERSION;
	
	    // default format
	    moment.defaultFormat = isoFormat;
	
	    // This function will be called whenever a moment is mutated.
	    // It is intended to keep the offset in sync with the timezone.
	    moment.updateOffset = function () {};
	
	    // This function will load languages and then set the global language.  If
	    // no arguments are passed in, it will simply return the current global
	    // language key.
	    moment.lang = function (key, values) {
	        var r;
	        if (!key) {
	            return moment.fn._lang._abbr;
	        }
	        if (values) {
	            loadLang(normalizeLanguage(key), values);
	        } else if (values === null) {
	            unloadLang(key);
	            key = 'en';
	        } else if (!languages[key]) {
	            getLangDefinition(key);
	        }
	        r = moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key);
	        return r._abbr;
	    };
	
	    // returns language data
	    moment.langData = function (key) {
	        if (key && key._lang && key._lang._abbr) {
	            key = key._lang._abbr;
	        }
	        return getLangDefinition(key);
	    };
	
	    // compare moment object
	    moment.isMoment = function (obj) {
	        return obj instanceof Moment;
	    };
	
	    // for typechecking Duration objects
	    moment.isDuration = function (obj) {
	        return obj instanceof Duration;
	    };
	
	    for (i = lists.length - 1; i >= 0; --i) {
	        makeList(lists[i]);
	    }
	
	    moment.normalizeUnits = function (units) {
	        return normalizeUnits(units);
	    };
	
	    moment.invalid = function (flags) {
	        var m = moment.utc(NaN);
	        if (flags != null) {
	            extend(m._pf, flags);
	        }
	        else {
	            m._pf.userInvalidated = true;
	        }
	
	        return m;
	    };
	
	    moment.parseZone = function (input) {
	        return moment(input).parseZone();
	    };
	
	    /************************************
	        Moment Prototype
	    ************************************/
	
	
	    extend(moment.fn = Moment.prototype, {
	
	        clone : function () {
	            return moment(this);
	        },
	
	        valueOf : function () {
	            return +this._d + ((this._offset || 0) * 60000);
	        },
	
	        unix : function () {
	            return Math.floor(+this / 1000);
	        },
	
	        toString : function () {
	            return this.clone().lang('en').format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
	        },
	
	        toDate : function () {
	            return this._offset ? new Date(+this) : this._d;
	        },
	
	        toISOString : function () {
	            return formatMoment(moment(this).utc(), 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	        },
	
	        toArray : function () {
	            var m = this;
	            return [
	                m.year(),
	                m.month(),
	                m.date(),
	                m.hours(),
	                m.minutes(),
	                m.seconds(),
	                m.milliseconds()
	            ];
	        },
	
	        isValid : function () {
	            return isValid(this);
	        },
	
	        isDSTShifted : function () {
	
	            if (this._a) {
	                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
	            }
	
	            return false;
	        },
	
	        parsingFlags : function () {
	            return extend({}, this._pf);
	        },
	
	        invalidAt: function () {
	            return this._pf.overflow;
	        },
	
	        utc : function () {
	            return this.zone(0);
	        },
	
	        local : function () {
	            this.zone(0);
	            this._isUTC = false;
	            return this;
	        },
	
	        format : function (inputString) {
	            var output = formatMoment(this, inputString || moment.defaultFormat);
	            return this.lang().postformat(output);
	        },
	
	        add : function (input, val) {
	            var dur;
	            // switch args to support add('s', 1) and add(1, 's')
	            if (typeof input === 'string') {
	                dur = moment.duration(+val, input);
	            } else {
	                dur = moment.duration(input, val);
	            }
	            addOrSubtractDurationFromMoment(this, dur, 1);
	            return this;
	        },
	
	        subtract : function (input, val) {
	            var dur;
	            // switch args to support subtract('s', 1) and subtract(1, 's')
	            if (typeof input === 'string') {
	                dur = moment.duration(+val, input);
	            } else {
	                dur = moment.duration(input, val);
	            }
	            addOrSubtractDurationFromMoment(this, dur, -1);
	            return this;
	        },
	
	        diff : function (input, units, asFloat) {
	            var that = this._isUTC ? moment(input).zone(this._offset || 0) : moment(input).local(),
	                zoneDiff = (this.zone() - that.zone()) * 6e4,
	                diff, output;
	
	            units = normalizeUnits(units);
	
	            if (units === 'year' || units === 'month') {
	                // average number of days in the months in the given dates
	                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
	                // difference in months
	                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
	                // adjust by taking difference in days, average number of days
	                // and dst in the given months.
	                output += ((this - moment(this).startOf('month')) -
	                        (that - moment(that).startOf('month'))) / diff;
	                // same as above but with zones, to negate all dst
	                output -= ((this.zone() - moment(this).startOf('month').zone()) -
	                        (that.zone() - moment(that).startOf('month').zone())) * 6e4 / diff;
	                if (units === 'year') {
	                    output = output / 12;
	                }
	            } else {
	                diff = (this - that);
	                output = units === 'second' ? diff / 1e3 : // 1000
	                    units === 'minute' ? diff / 6e4 : // 1000 * 60
	                    units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
	                    units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
	                    units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
	                    diff;
	            }
	            return asFloat ? output : absRound(output);
	        },
	
	        from : function (time, withoutSuffix) {
	            return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix);
	        },
	
	        fromNow : function (withoutSuffix) {
	            return this.from(moment(), withoutSuffix);
	        },
	
	        calendar : function () {
	            var diff = this.diff(moment().zone(this.zone()).startOf('day'), 'days', true),
	                format = diff < -6 ? 'sameElse' :
	                diff < -1 ? 'lastWeek' :
	                diff < 0 ? 'lastDay' :
	                diff < 1 ? 'sameDay' :
	                diff < 2 ? 'nextDay' :
	                diff < 7 ? 'nextWeek' : 'sameElse';
	            return this.format(this.lang().calendar(format, this));
	        },
	
	        isLeapYear : function () {
	            return isLeapYear(this.year());
	        },
	
	        isDST : function () {
	            return (this.zone() < this.clone().month(0).zone() ||
	                this.zone() < this.clone().month(5).zone());
	        },
	
	        day : function (input) {
	            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
	            if (input != null) {
	                input = parseWeekday(input, this.lang());
	                return this.add({ d : input - day });
	            } else {
	                return day;
	            }
	        },
	
	        month : function (input) {
	            var utc = this._isUTC ? 'UTC' : '',
	                dayOfMonth;
	
	            if (input != null) {
	                if (typeof input === 'string') {
	                    input = this.lang().monthsParse(input);
	                    if (typeof input !== 'number') {
	                        return this;
	                    }
	                }
	
	                dayOfMonth = this.date();
	                this.date(1);
	                this._d['set' + utc + 'Month'](input);
	                this.date(Math.min(dayOfMonth, this.daysInMonth()));
	
	                moment.updateOffset(this);
	                return this;
	            } else {
	                return this._d['get' + utc + 'Month']();
	            }
	        },
	
	        startOf: function (units) {
	            units = normalizeUnits(units);
	            // the following switch intentionally omits break keywords
	            // to utilize falling through the cases.
	            switch (units) {
	            case 'year':
	                this.month(0);
	                /* falls through */
	            case 'month':
	                this.date(1);
	                /* falls through */
	            case 'week':
	            case 'isoWeek':
	            case 'day':
	                this.hours(0);
	                /* falls through */
	            case 'hour':
	                this.minutes(0);
	                /* falls through */
	            case 'minute':
	                this.seconds(0);
	                /* falls through */
	            case 'second':
	                this.milliseconds(0);
	                /* falls through */
	            }
	
	            // weeks are a special case
	            if (units === 'week') {
	                this.weekday(0);
	            } else if (units === 'isoWeek') {
	                this.isoWeekday(1);
	            }
	
	            return this;
	        },
	
	        endOf: function (units) {
	            units = normalizeUnits(units);
	            return this.startOf(units).add((units === 'isoWeek' ? 'week' : units), 1).subtract('ms', 1);
	        },
	
	        isAfter: function (input, units) {
	            units = typeof units !== 'undefined' ? units : 'millisecond';
	            return +this.clone().startOf(units) > +moment(input).startOf(units);
	        },
	
	        isBefore: function (input, units) {
	            units = typeof units !== 'undefined' ? units : 'millisecond';
	            return +this.clone().startOf(units) < +moment(input).startOf(units);
	        },
	
	        isSame: function (input, units) {
	            units = typeof units !== 'undefined' ? units : 'millisecond';
	            return +this.clone().startOf(units) === +moment(input).startOf(units);
	        },
	
	        min: function (other) {
	            other = moment.apply(null, arguments);
	            return other < this ? this : other;
	        },
	
	        max: function (other) {
	            other = moment.apply(null, arguments);
	            return other > this ? this : other;
	        },
	
	        zone : function (input) {
	            var offset = this._offset || 0;
	            if (input != null) {
	                if (typeof input === "string") {
	                    input = timezoneMinutesFromString(input);
	                }
	                if (Math.abs(input) < 16) {
	                    input = input * 60;
	                }
	                this._offset = input;
	                this._isUTC = true;
	                if (offset !== input) {
	                    addOrSubtractDurationFromMoment(this, moment.duration(offset - input, 'm'), 1, true);
	                }
	            } else {
	                return this._isUTC ? offset : this._d.getTimezoneOffset();
	            }
	            return this;
	        },
	
	        zoneAbbr : function () {
	            return this._isUTC ? "UTC" : "";
	        },
	
	        zoneName : function () {
	            return this._isUTC ? "Coordinated Universal Time" : "";
	        },
	
	        parseZone : function () {
	            if (typeof this._i === 'string') {
	                this.zone(this._i);
	            }
	            return this;
	        },
	
	        hasAlignedHourOffset : function (input) {
	            if (!input) {
	                input = 0;
	            }
	            else {
	                input = moment(input).zone();
	            }
	
	            return (this.zone() - input) % 60 === 0;
	        },
	
	        daysInMonth : function () {
	            return daysInMonth(this.year(), this.month());
	        },
	
	        dayOfYear : function (input) {
	            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
	            return input == null ? dayOfYear : this.add("d", (input - dayOfYear));
	        },
	
	        weekYear : function (input) {
	            var year = weekOfYear(this, this.lang()._week.dow, this.lang()._week.doy).year;
	            return input == null ? year : this.add("y", (input - year));
	        },
	
	        isoWeekYear : function (input) {
	            var year = weekOfYear(this, 1, 4).year;
	            return input == null ? year : this.add("y", (input - year));
	        },
	
	        week : function (input) {
	            var week = this.lang().week(this);
	            return input == null ? week : this.add("d", (input - week) * 7);
	        },
	
	        isoWeek : function (input) {
	            var week = weekOfYear(this, 1, 4).week;
	            return input == null ? week : this.add("d", (input - week) * 7);
	        },
	
	        weekday : function (input) {
	            var weekday = (this.day() + 7 - this.lang()._week.dow) % 7;
	            return input == null ? weekday : this.add("d", input - weekday);
	        },
	
	        isoWeekday : function (input) {
	            // behaves the same as moment#day except
	            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
	            // as a setter, sunday should belong to the previous week.
	            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
	        },
	
	        get : function (units) {
	            units = normalizeUnits(units);
	            return this[units]();
	        },
	
	        set : function (units, value) {
	            units = normalizeUnits(units);
	            if (typeof this[units] === 'function') {
	                this[units](value);
	            }
	            return this;
	        },
	
	        // If passed a language key, it will set the language for this
	        // instance.  Otherwise, it will return the language configuration
	        // variables for this instance.
	        lang : function (key) {
	            if (key === undefined) {
	                return this._lang;
	            } else {
	                this._lang = getLangDefinition(key);
	                return this;
	            }
	        }
	    });
	
	    // helper for adding shortcuts
	    function makeGetterAndSetter(name, key) {
	        moment.fn[name] = moment.fn[name + 's'] = function (input) {
	            var utc = this._isUTC ? 'UTC' : '';
	            if (input != null) {
	                this._d['set' + utc + key](input);
	                moment.updateOffset(this);
	                return this;
	            } else {
	                return this._d['get' + utc + key]();
	            }
	        };
	    }
	
	    // loop through and add shortcuts (Month, Date, Hours, Minutes, Seconds, Milliseconds)
	    for (i = 0; i < proxyGettersAndSetters.length; i ++) {
	        makeGetterAndSetter(proxyGettersAndSetters[i].toLowerCase().replace(/s$/, ''), proxyGettersAndSetters[i]);
	    }
	
	    // add shortcut for year (uses different syntax than the getter/setter 'year' == 'FullYear')
	    makeGetterAndSetter('year', 'FullYear');
	
	    // add plural methods
	    moment.fn.days = moment.fn.day;
	    moment.fn.months = moment.fn.month;
	    moment.fn.weeks = moment.fn.week;
	    moment.fn.isoWeeks = moment.fn.isoWeek;
	
	    // add aliased format methods
	    moment.fn.toJSON = moment.fn.toISOString;
	
	    /************************************
	        Duration Prototype
	    ************************************/
	
	
	    extend(moment.duration.fn = Duration.prototype, {
	
	        _bubble : function () {
	            var milliseconds = this._milliseconds,
	                days = this._days,
	                months = this._months,
	                data = this._data,
	                seconds, minutes, hours, years;
	
	            // The following code bubbles up values, see the tests for
	            // examples of what that means.
	            data.milliseconds = milliseconds % 1000;
	
	            seconds = absRound(milliseconds / 1000);
	            data.seconds = seconds % 60;
	
	            minutes = absRound(seconds / 60);
	            data.minutes = minutes % 60;
	
	            hours = absRound(minutes / 60);
	            data.hours = hours % 24;
	
	            days += absRound(hours / 24);
	            data.days = days % 30;
	
	            months += absRound(days / 30);
	            data.months = months % 12;
	
	            years = absRound(months / 12);
	            data.years = years;
	        },
	
	        weeks : function () {
	            return absRound(this.days() / 7);
	        },
	
	        valueOf : function () {
	            return this._milliseconds +
	              this._days * 864e5 +
	              (this._months % 12) * 2592e6 +
	              toInt(this._months / 12) * 31536e6;
	        },
	
	        humanize : function (withSuffix) {
	            var difference = +this,
	                output = relativeTime(difference, !withSuffix, this.lang());
	
	            if (withSuffix) {
	                output = this.lang().pastFuture(difference, output);
	            }
	
	            return this.lang().postformat(output);
	        },
	
	        add : function (input, val) {
	            // supports only 2.0-style add(1, 's') or add(moment)
	            var dur = moment.duration(input, val);
	
	            this._milliseconds += dur._milliseconds;
	            this._days += dur._days;
	            this._months += dur._months;
	
	            this._bubble();
	
	            return this;
	        },
	
	        subtract : function (input, val) {
	            var dur = moment.duration(input, val);
	
	            this._milliseconds -= dur._milliseconds;
	            this._days -= dur._days;
	            this._months -= dur._months;
	
	            this._bubble();
	
	            return this;
	        },
	
	        get : function (units) {
	            units = normalizeUnits(units);
	            return this[units.toLowerCase() + 's']();
	        },
	
	        as : function (units) {
	            units = normalizeUnits(units);
	            return this['as' + units.charAt(0).toUpperCase() + units.slice(1) + 's']();
	        },
	
	        lang : moment.fn.lang,
	
	        toIsoString : function () {
	            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
	            var years = Math.abs(this.years()),
	                months = Math.abs(this.months()),
	                days = Math.abs(this.days()),
	                hours = Math.abs(this.hours()),
	                minutes = Math.abs(this.minutes()),
	                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);
	
	            if (!this.asSeconds()) {
	                // this is the same as C#'s (Noda) and python (isodate)...
	                // but not other JS (goog.date)
	                return 'P0D';
	            }
	
	            return (this.asSeconds() < 0 ? '-' : '') +
	                'P' +
	                (years ? years + 'Y' : '') +
	                (months ? months + 'M' : '') +
	                (days ? days + 'D' : '') +
	                ((hours || minutes || seconds) ? 'T' : '') +
	                (hours ? hours + 'H' : '') +
	                (minutes ? minutes + 'M' : '') +
	                (seconds ? seconds + 'S' : '');
	        }
	    });
	
	    function makeDurationGetter(name) {
	        moment.duration.fn[name] = function () {
	            return this._data[name];
	        };
	    }
	
	    function makeDurationAsGetter(name, factor) {
	        moment.duration.fn['as' + name] = function () {
	            return +this / factor;
	        };
	    }
	
	    for (i in unitMillisecondFactors) {
	        if (unitMillisecondFactors.hasOwnProperty(i)) {
	            makeDurationAsGetter(i, unitMillisecondFactors[i]);
	            makeDurationGetter(i.toLowerCase());
	        }
	    }
	
	    makeDurationAsGetter('Weeks', 6048e5);
	    moment.duration.fn.asMonths = function () {
	        return (+this - this.years() * 31536e6) / 2592e6 + this.years() * 12;
	    };
	
	
	    /************************************
	        Default Lang
	    ************************************/
	
	
	    // Set default language, other languages will inherit from English.
	    moment.lang('en', {
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (toInt(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        }
	    });
	
	    /* EMBED_LANGUAGES */
	
	    /************************************
	        Exposing Moment
	    ************************************/
	
	    function makeGlobal(deprecate) {
	        var warned = false, local_moment = moment;
	        /*global ender:false */
	        if (typeof ender !== 'undefined') {
	            return;
	        }
	        // here, `this` means `window` in the browser, or `global` on the server
	        // add `moment` as a global object via a string identifier,
	        // for Closure Compiler "advanced" mode
	        if (deprecate) {
	            this.moment = function () {
	                if (!warned && console && console.warn) {
	                    warned = true;
	                    console.warn(
	                            "Accessing Moment through the global scope is " +
	                            "deprecated, and will be removed in an upcoming " +
	                            "release.");
	                }
	                return local_moment.apply(null, arguments);
	            };
	        } else {
	            this['moment'] = moment;
	        }
	    }
	
	    // CommonJS module is defined
	    if (hasModule) {
	        module.exports = moment;
	        makeGlobal(true);
	    } else if (typeof define === "function" && define.amd) {
	        define("moment", function (require, exports, module) {
	            if (module.config().noGlobal !== true) {
	                // If user provided noGlobal, he is aware of global
	                makeGlobal(module.config().noGlobal === undefined);
	            }
	
	            return moment;
	        });
	    } else {
	        makeGlobal();
	    }
	}).call(this);
	

}, 'browser-http/Helpers.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'browser-http/Helpers.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'browser-http/Helpers.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'browser-http/Helpers.js';
	var __dirname = 'browser-http';
	var process = {cwd: function() {return '/';}, argv: ['node', 'browser-http/Helpers.js'], env: {}};

	/** code **/
	module.exports = require('./lib/Helpers');

}, 'browser-http/lib/Helpers.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'browser-http/lib/Helpers.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'browser-http/lib/Helpers.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'browser-http/lib/Helpers.js';
	var __dirname = 'browser-http/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', 'browser-http/lib/Helpers.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var Helpers;
	
	  Helpers = (function() {
	    function Helpers() {}
	
	    Helpers.urlencode = function(param) {
	      param = (param + '').toString();
	      return encodeURIComponent(param).replace(/!/g, '%21').replace(/'/g, '%27').replace(/\(/g, '%28').replace(/\)/g, '%29').replace(/\*/g, '%2A').replace(/\~/g, '%7E').replace(/%20/g, '+');
	    };
	
	    Helpers.buildQuery = function(params) {
	      var add, buildParams, key, result, value, _i, _len;
	      result = [];
	      add = function(key, value) {
	        value = typeof value === 'function' ? value() : (value === null ? '' : value);
	        return result.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
	      };
	      buildParams = function(key, value) {
	        var i, k, v, _i, _len, _results, _results1;
	        if (Object.prototype.toString.call(value) === '[object Array]') {
	          _results = [];
	          for (i = _i = 0, _len = value.length; _i < _len; i = ++_i) {
	            v = value[i];
	            if (/\[\]$/.test(key) === true) {
	              _results.push(add(key, v));
	            } else {
	              _results.push(buildParams(key + '[' + (typeof v === 'object' ? i : '') + ']', v));
	            }
	          }
	          return _results;
	        } else if (Object.prototype.toString.call(value) === '[object Object]') {
	          _results1 = [];
	          for (k in value) {
	            v = value[k];
	            _results1.push(buildParams(key + '[' + k + ']', v));
	          }
	          return _results1;
	        } else {
	          return add(key, value);
	        }
	      };
	      if (Object.prototype.toString.call(params) === '[object Array]') {
	        for (key = _i = 0, _len = params.length; _i < _len; key = ++_i) {
	          value = params[key];
	          add(key, value);
	        }
	      } else {
	        for (key in params) {
	          value = params[key];
	          buildParams(key, value);
	        }
	      }
	      return result.join('&').replace(/%20/g, '+');
	    };
	
	    return Helpers;
	
	  })();
	
	  module.exports = Helpers;
	
	}).call(this);
	

}, 'browser-http/lib/Http.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'browser-http/lib/Http.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'browser-http/lib/Http.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'browser-http/lib/Http.js';
	var __dirname = 'browser-http/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', 'browser-http/lib/Http.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var EventEmitter, Http, Q, Queue, Request,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    __slice = [].slice;
	
	  Request = require('./Request');
	
	  Queue = require('./Queue');
	
	  Q = require('q');
	
	  EventEmitter = require('events').EventEmitter;
	
	  Http = (function(_super) {
	    __extends(Http, _super);
	
	    Http.prototype.extensions = null;
	
	    Http.prototype.queue = null;
	
	    Http.prototype.useQueue = true;
	
	    function Http() {
	      var _this = this;
	      Http.__super__.constructor.apply(this, arguments);
	      this.extensions = {};
	      this.queue = new Queue;
	      this.on('send', function() {
	        var args;
	        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
	        return _this.callExtensions('send', args);
	      });
	      this.on('afterSend', function() {
	        var args;
	        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
	        return _this.callExtensions('afterSend', args);
	      });
	      this.on('complete', function() {
	        var args;
	        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
	        return _this.callExtensions('complete', args);
	      });
	      this.on('error', function() {
	        var args;
	        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
	        return _this.callExtensions('error', args);
	      });
	      this.on('success', function() {
	        var args;
	        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
	        return _this.callExtensions('success', args);
	      });
	    }
	
	    Http.prototype.createRequest = function(url, type, data, jsonp) {
	      return new Request(url, type, data, jsonp);
	    };
	
	    Http.prototype.request = function(url, options) {
	      var deferred, request,
	        _this = this;
	      if (options == null) {
	        options = {};
	      }
	      if (typeof options.type === 'undefined') {
	        options.type = 'GET';
	      }
	      if (typeof options.data === 'undefined') {
	        options.data = null;
	      }
	      if (typeof options.jsonp === 'undefined') {
	        options.jsonp = false;
	      }
	      request = this.createRequest(url, options.type, options.data, options.jsonp);
	      request.on('send', function(response, request) {
	        return _this.emit('send', response, request);
	      });
	      request.on('success', function(response, request) {
	        return _this.emit('success', response, request);
	      });
	      request.on('error', function(error, response, request) {
	        return _this.emit('error', response, request);
	      });
	      request.on('complete', function(response, request) {
	        return _this.emit('complete', response, request);
	      });
	      if (this.useQueue) {
	        deferred = Q.defer();
	        this.queue.add(request, function() {
	          return request.send().then(function(response) {
	            _this.queue.next();
	            return deferred.resolve(response);
	          }).fail(function(err) {
	            _this.queue.next();
	            return deferred.reject(err);
	          });
	        });
	        this.queue.run();
	        return deferred.promise;
	      } else {
	        return request.send();
	      }
	    };
	
	    Http.prototype.get = function(url, options) {
	      if (options == null) {
	        options = {};
	      }
	      options.type = 'GET';
	      return this.request(url, options);
	    };
	
	    Http.prototype.post = function(url, options) {
	      if (options == null) {
	        options = {};
	      }
	      options.type = 'POST';
	      return this.request(url, options);
	    };
	
	    Http.prototype.put = function(url, options) {
	      if (options == null) {
	        options = {};
	      }
	      options.type = 'PUT';
	      return this.request(url, options);
	    };
	
	    Http.prototype["delete"] = function(url, options) {
	      if (options == null) {
	        options = {};
	      }
	      options.type = 'DELETE';
	      return this.request(url, options);
	    };
	
	    Http.prototype.getJson = function(url, options) {
	      if (options == null) {
	        options = {};
	      }
	      return this.request(url, options).then(function(response) {
	        if (typeof response.data === 'string') {
	          response.data = JSON.parse(response.data);
	        }
	        return Q.resolve(response);
	      });
	    };
	
	    Http.prototype.postJson = function(url, options) {
	      if (options == null) {
	        options = {};
	      }
	      options.type = 'POST';
	      return this.request(url, options).then(function(response) {
	        if (typeof response.data === 'string') {
	          response.data = JSON.parse(response.data);
	        }
	        return Q.resolve(response);
	      });
	    };
	
	    Http.prototype.jsonp = function(url, options) {
	      if (options == null) {
	        options = {};
	      }
	      if (typeof options.jsonp === 'undefined') {
	        options.jsonp = true;
	      }
	      return this.get(url, options);
	    };
	
	    Http.prototype.isHistoryApiSupported = function() {
	      return window.history && window.history.pushState && window.history.replaceState && !navigator.userAgent.match(/((iPod|iPhone|iPad).+\bOS\s+[1-4]|WebApps\/.+CFNetwork)/);
	    };
	
	    Http.prototype.addExtension = function(name, fns) {
	      this.extensions[name] = fns;
	      return this;
	    };
	
	    Http.prototype.removeExtension = function(name) {
	      if (typeof this.extensions[name] === 'undefined') {
	        throw new Error('Extension ' + name + ' does not exists');
	      }
	      delete this.extensions[name];
	      return this;
	    };
	
	    Http.prototype.callExtensions = function(event, args) {
	      var ext, name, _ref, _results;
	      _ref = this.extensions;
	      _results = [];
	      for (name in _ref) {
	        ext = _ref[name];
	        if (typeof ext[event] !== 'undefined') {
	          _results.push(ext[event].apply(ext[event], args));
	        } else {
	          _results.push(void 0);
	        }
	      }
	      return _results;
	    };
	
	    return Http;
	
	  })(EventEmitter);
	
	  module.exports = new Http;
	
	}).call(this);
	

}, 'browser-http/lib/Request.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'browser-http/lib/Request.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'browser-http/lib/Request.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'browser-http/lib/Request.js';
	var __dirname = 'browser-http/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', 'browser-http/lib/Request.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var EventEmitter, Request, Xhr,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
	
	  Xhr = require('./Xhr');
	
	  EventEmitter = require('events').EventEmitter;
	
	  Request = (function(_super) {
	    __extends(Request, _super);
	
	    Request.prototype.url = null;
	
	    Request.prototype.type = 'GET';
	
	    Request.prototype.data = null;
	
	    Request.prototype.jsonp = null;
	
	    Request.prototype.xhr = null;
	
	    Request.prototype.response = null;
	
	    function Request(url, type, data, jsonp) {
	      var _this = this;
	      this.url = url;
	      this.type = type != null ? type : 'GET';
	      this.data = data != null ? data : null;
	      this.jsonp = jsonp != null ? jsonp : false;
	      Request.__super__.constructor.apply(this, arguments);
	      this.xhr = this.createXhr(this.url, this.type, this.data, this.jsonp);
	      this.response = this.xhr.response;
	      this.xhr.on('send', function() {
	        return _this.emit('send', _this.response, _this);
	      });
	      this.xhr.on('afterSend', function() {
	        return _this.emit('afterSend', _this.response, _this);
	      });
	      this.xhr.on('success', function() {
	        _this.emit('success', _this.response, _this);
	        return _this.emit('complete', _this.response, _this);
	      });
	      this.xhr.on('error', function(err) {
	        _this.emit('error', err, _this.response, _this);
	        return _this.emit('complete', _this.response, _this);
	      });
	    }
	
	    Request.prototype.createXhr = function(url, type, data, jsonp) {
	      return new Xhr(url, type, data, jsonp);
	    };
	
	    Request.prototype.setHeader = function(name, value) {
	      return this.xhr.setHeader(name, value);
	    };
	
	    Request.prototype.send = function() {
	      return this.xhr.send();
	    };
	
	    Request.prototype.abort = function() {
	      return this.xhr.abort();
	    };
	
	    Request.prototype.getHeaders = function() {
	      return this.xhr.getHeaders();
	    };
	
	    Request.prototype.getHeader = function(name) {
	      return this.xhr.getHeader(name);
	    };
	
	    Request.prototype.setHeader = function(name, value) {
	      return this.xhr.setHeader(name, value);
	    };
	
	    Request.prototype.setMimeType = function(mime) {
	      return this.xhr.setMimeType(mime);
	    };
	
	    return Request;
	
	  })(EventEmitter);
	
	  module.exports = Request;
	
	}).call(this);
	

}, 'browser-http/lib/Xhr.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'browser-http/lib/Xhr.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'browser-http/lib/Xhr.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'browser-http/lib/Xhr.js';
	var __dirname = 'browser-http/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', 'browser-http/lib/Xhr.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var EventEmitter, Helpers, Q, Response, Xhr,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
	
	  Helpers = require('./Helpers');
	
	  Response = require('./Response');
	
	  EventEmitter = require('events').EventEmitter;
	
	  Q = require('q');
	
	  Xhr = (function(_super) {
	    __extends(Xhr, _super);
	
	    Xhr.JSONP_METHOD_PREFIX = '__browser_http_jsonp_callback_';
	
	    Xhr.COUNTER = 0;
	
	    Xhr.prototype.xhr = null;
	
	    Xhr.prototype.response = null;
	
	    Xhr.prototype.url = null;
	
	    Xhr.prototype.type = 'GET';
	
	    Xhr.prototype.data = null;
	
	    Xhr.prototype.jsonp = false;
	
	    function Xhr(url, type, data, jsonp) {
	      var method, _ref,
	        _this = this;
	      this.url = url;
	      this.type = type != null ? type : 'GET';
	      this.data = data != null ? data : null;
	      this.jsonp = jsonp != null ? jsonp : false;
	      this.response = new Response;
	      Xhr.COUNTER++;
	      this.type = this.type.toUpperCase();
	      if ((_ref = this.type) !== 'GET' && _ref !== 'POST' && _ref !== 'PUT' && _ref !== 'DELETE') {
	        throw new Error("Http request: type must be GET, POST, PUT or DELETE, " + this.type + " given");
	      }
	      if (this.jsonp !== false) {
	        if (this.jsonp === true) {
	          this.jsonp = 'callback';
	        }
	        method = Xhr.JSONP_METHOD_PREFIX + Xhr.COUNTER;
	        this.url += this.url.indexOf('?') !== -1 ? '&' : '?';
	        this.url += this.jsonp + '=' + method;
	        window[method] = function(data) {
	          return _this.response.data = data;
	        };
	      }
	      if (this.data !== null) {
	        this.data = Helpers.buildQuery(this.data);
	        if (type !== 'POST') {
	          this.url += this.url.indexOf('?') !== -1 ? '&' : '?';
	          this.url += this.data;
	        }
	      }
	      this.xhr = this.createXhr();
	      this.xhr.open(this.type, this.url, true);
	      if (this.url.match(/^(http)s?\:\/\//) === null) {
	        this.xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
	      }
	      if (this.type === 'POST') {
	        this.xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
	      }
	      this.xhr.onreadystatechange = function() {
	        var contentType;
	        _this.response.state = _this.xhr.readyState;
	        if (_this.response.state === 4) {
	          _this.response.status = _this.xhr.status;
	          _this.response.statusText = _this.xhr.statusText;
	          _this.response.rawData = _this.xhr.responseText;
	          _this.response.xml = _this.xhr.responseXML;
	          _this.response.data = _this.xhr.responseText;
	          contentType = _this.xhr.getResponseHeader('content-type');
	          if (contentType !== null && contentType.match(/application\/json/) !== null) {
	            _this.response.data = JSON.parse(_this.response.data);
	          }
	          if (contentType !== null && (contentType.match(/text\/javascript/) !== null || contentType.match(/application\/javascript/) !== null) && _this.jsonp) {
	            eval(_this.response.data);
	          }
	          if (_this.response.status === 200) {
	            return _this.emit('success', _this);
	          } else {
	            return _this.emit('error', new Error("Can not load " + url + " address", _this));
	          }
	        }
	      };
	    }
	
	    Xhr.prototype.createXhr = function() {
	      if (window.XMLHttpRequest) {
	        return new window.XMLHttpRequest;
	      } else {
	        return new ActiveXObject("Microsoft.XMLHTTP");
	      }
	    };
	
	    Xhr.prototype.getHeaders = function() {
	      return this.xhr.getAllResponseHeaders();
	    };
	
	    Xhr.prototype.getHeader = function(name) {
	      return this.xhr.getResponseHeader(name);
	    };
	
	    Xhr.prototype.setHeader = function(name, value) {
	      this.xhr.setRequestHeader(name, value);
	      return this;
	    };
	
	    Xhr.prototype.setMimeType = function(mime) {
	      this.xhr.overrideMimeType(mime);
	      return this;
	    };
	
	    Xhr.prototype.send = function() {
	      var deferred,
	        _this = this;
	      deferred = Q.defer();
	      this.emit('send', this.response);
	      this.on('success', function() {
	        return deferred.resolve(_this.response);
	      });
	      this.on('error', function(err) {
	        return deferred.reject(err);
	      });
	      this.xhr.send(this.data);
	      this.emit('afterSend', this.response);
	      return deferred.promise;
	    };
	
	    Xhr.prototype.abort = function() {
	      this.xhr.abort();
	      return this;
	    };
	
	    return Xhr;
	
	  })(EventEmitter);
	
	  module.exports = Xhr;
	
	}).call(this);
	

}, 'browser-http/lib/Response.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'browser-http/lib/Response.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'browser-http/lib/Response.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'browser-http/lib/Response.js';
	var __dirname = 'browser-http/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', 'browser-http/lib/Response.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var Response;
	
	  Response = (function() {
	    function Response() {}
	
	    Response.prototype.state = 0;
	
	    Response.prototype.status = null;
	
	    Response.prototype.statusText = null;
	
	    Response.prototype.rawData = null;
	
	    Response.prototype.data = null;
	
	    Response.prototype.xml = null;
	
	    return Response;
	
	  })();
	
	  module.exports = Response;
	
	}).call(this);
	

}, 'browser-http/lib/Queue.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'browser-http/lib/Queue.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'browser-http/lib/Queue.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'browser-http/lib/Queue.js';
	var __dirname = 'browser-http/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', 'browser-http/lib/Queue.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var Queue;
	
	  Queue = (function() {
	    Queue.prototype.requests = null;
	
	    Queue.prototype.running = false;
	
	    function Queue() {
	      this.requests = [];
	    }
	
	    Queue.prototype.add = function(request, fn) {
	      return this.requests.push({
	        request: request,
	        fn: fn
	      });
	    };
	
	    Queue.prototype.run = function() {
	      var data;
	      if (this.running === false && this.requests.length > 0) {
	        this.running = true;
	        data = this.requests.shift();
	        return data.fn();
	      }
	    };
	
	    Queue.prototype.next = function() {
	      this.running = false;
	      return this.run();
	    };
	
	    return Queue;
	
	  })();
	
	  module.exports = Queue;
	
	}).call(this);
	

}, 'browser-http/lib/Mocks/Request.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'browser-http/lib/Mocks/Request.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'browser-http/lib/Mocks/Request.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'browser-http/lib/Mocks/Request.js';
	var __dirname = 'browser-http/lib/Mocks';
	var process = {cwd: function() {return '/';}, argv: ['node', 'browser-http/lib/Mocks/Request.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var OriginalRequest, Request, Xhr, _ref,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
	
	  OriginalRequest = require('../Request');
	
	  Xhr = require('./Xhr');
	
	  Request = (function(_super) {
	    __extends(Request, _super);
	
	    function Request() {
	      _ref = Request.__super__.constructor.apply(this, arguments);
	      return _ref;
	    }
	
	    Request.prototype.createXhr = function(url, type, data, jsonp) {
	      return new Xhr(url, type, data, jsonp);
	    };
	
	    return Request;
	
	  })(OriginalRequest);
	
	  module.exports = Request;
	
	}).call(this);
	

}, 'browser-http/lib/Mocks/Xhr.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'browser-http/lib/Mocks/Xhr.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'browser-http/lib/Mocks/Xhr.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'browser-http/lib/Mocks/Xhr.js';
	var __dirname = 'browser-http/lib/Mocks';
	var process = {cwd: function() {return '/';}, argv: ['node', 'browser-http/lib/Mocks/Xhr.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var OriginalXhr, Xhr, XmlHttpMocks, _ref,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
	
	  OriginalXhr = require('../Xhr');
	
	  XmlHttpMocks = require('../../Mocks/XmlHttpRequest');
	
	  Xhr = (function(_super) {
	    __extends(Xhr, _super);
	
	    function Xhr() {
	      _ref = Xhr.__super__.constructor.apply(this, arguments);
	      return _ref;
	    }
	
	    Xhr.prototype.createXhr = function() {
	      return new XmlHttpMocks;
	    };
	
	    Xhr.prototype.receive = function(status, data) {
	      return this.xhr.receive(status, data);
	    };
	
	    Xhr.prototype.receiveError = function(err) {
	      return this.xhr.err(err);
	    };
	
	    Xhr.prototype.setResponseHeader = function(name, value) {
	      return this.xhr.setResponseHeader(name, value);
	    };
	
	    return Xhr;
	
	  })(OriginalXhr);
	
	  module.exports = Xhr;
	
	}).call(this);
	

}, 'browser-http/Mocks/XmlHttpRequest.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'browser-http/Mocks/XmlHttpRequest.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'browser-http/Mocks/XmlHttpRequest.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'browser-http/Mocks/XmlHttpRequest.js';
	var __dirname = 'browser-http/Mocks';
	var process = {cwd: function() {return '/';}, argv: ['node', 'browser-http/Mocks/XmlHttpRequest.js'], env: {}};

	/** code **/
	/**
	 * from https://github.com/philikon/MockHttpRequest
	 * thanks
	 */
	
	
	
	/*
	 * Mock XMLHttpRequest (see http://www.w3.org/TR/XMLHttpRequest)
	 *
	 * Written by Philipp von Weitershausen <philipp@weitershausen.de>
	 * Released under the MIT license.
	 * http://www.opensource.org/licenses/mit-license.php
	 *
	 * For test interaction it exposes the following attributes:
	 *
	 * - method, url, urlParts, async, user, password
	 * - requestText
	 *
	 * as well as the following methods:
	 *
	 * - getRequestHeader(header)
	 * - setResponseHeader(header, value)
	 * - receive(status, data)
	 * - err(exception)
	 * - authenticate(user, password)
	 *
	 */
	function MockHttpRequest () {
		// These are internal flags and data structures
		this.error = false;
		this.sent = false;
		this.requestHeaders = {};
		this.responseHeaders = {};
	}
	MockHttpRequest.prototype = {
	
		statusReasons: {
			100: 'Continue',
			101: 'Switching Protocols',
			102: 'Processing',
			200: 'OK',
			201: 'Created',
			202: 'Accepted',
			203: 'Non-Authoritative Information',
			204: 'No Content',
			205: 'Reset Content',
			206: 'Partial Content',
			207: 'Multi-Status',
			300: 'Multiple Choices',
			301: 'Moved Permanently',
			302: 'Moved Temporarily',
			303: 'See Other',
			304: 'Not Modified',
			305: 'Use Proxy',
			307: 'Temporary Redirect',
			400: 'Bad Request',
			401: 'Unauthorized',
			402: 'Payment Required',
			403: 'Forbidden',
			404: 'Not Found',
			405: 'Method Not Allowed',
			406: 'Not Acceptable',
			407: 'Proxy Authentication Required',
			408: 'Request Time-out',
			409: 'Conflict',
			410: 'Gone',
			411: 'Length Required',
			412: 'Precondition Failed',
			413: 'Request Entity Too Large',
			414: 'Request-URI Too Large',
			415: 'Unsupported Media Type',
			416: 'Requested range not satisfiable',
			417: 'Expectation Failed',
			422: 'Unprocessable Entity',
			423: 'Locked',
			424: 'Failed Dependency',
			500: 'Internal Server Error',
			501: 'Not Implemented',
			502: 'Bad Gateway',
			503: 'Service Unavailable',
			504: 'Gateway Time-out',
			505: 'HTTP Version not supported',
			507: 'Insufficient Storage'
		},
	
		/*** State ***/
	
		UNSENT: 0,
		OPENED: 1,
		HEADERS_RECEIVED: 2,
		LOADING: 3,
		DONE: 4,
		readyState: 0,
	
	
		/*** Request ***/
	
		open: function (method, url, async, user, password) {
			if (typeof method !== "string") {
				throw "INVALID_METHOD";
			}
			switch (method.toUpperCase()) {
				case "CONNECT":
				case "TRACE":
				case "TRACK":
					throw "SECURITY_ERR";
	
				case "DELETE":
				case "GET":
				case "HEAD":
				case "OPTIONS":
				case "POST":
				case "PUT":
					method = method.toUpperCase();
			}
			this.method = method;
	
			if (typeof url !== "string") {
				throw "INVALID_URL";
			}
			this.url = url;
			this.urlParts = this.parseUri(url);
	
			if (async === undefined) {
				async = true;
			}
			this.async = async;
			this.user = user;
			this.password = password;
	
			this.readyState = this.OPENED;
			this.onreadystatechange();
		},
	
		setRequestHeader: function (header, value) {
			header = header.toLowerCase();
	
			switch (header) {
				case "accept-charset":
				case "accept-encoding":
				case "connection":
				case "content-length":
				case "cookie":
				case "cookie2":
				case "content-transfer-encoding":
				case "date":
				case "expect":
				case "host":
				case "keep-alive":
				case "referer":
				case "te":
				case "trailer":
				case "transfer-encoding":
				case "upgrade":
				case "user-agent":
				case "via":
					return;
			}
			if ((header.substr(0, 6) === "proxy-")
				|| (header.substr(0, 4) === "sec-")) {
				return;
			}
	
			// it's the first call on this header field
			if (this.requestHeaders[header] === undefined)
				this.requestHeaders[header] = value;
			else {
				var prev = this.requestHeaders[header];
				this.requestHeaders[header] = prev + ", " + value;
			}
	
		},
	
		send: function (data) {
			if ((this.readyState !== this.OPENED)
				|| this.sent) {
				throw "INVALID_STATE_ERR";
			}
			if ((this.method === "GET") || (this.method === "HEAD")) {
				data = null;
			}
	
			//TODO set Content-Type header?
			this.error = false;
			this.sent = true;
			this.onreadystatechange();
	
			// fake send
			this.requestText = data;
			this.onsend();
		},
	
		abort: function () {
			this.responseText = null;
			this.error = true;
			for (var header in this.requestHeaders) {
				delete this.requestHeaders[header];
			}
			delete this.requestText;
			this.onreadystatechange();
			this.onabort();
			this.readyState = this.UNSENT;
		},
	
	
		/*** Response ***/
	
		status: 0,
		statusText: "",
	
		getResponseHeader: function (header) {
			if ((this.readyState === this.UNSENT)
				|| (this.readyState === this.OPENED)
				|| this.error) {
				return null;
			}
			return this.responseHeaders[header.toLowerCase()];
		},
	
		getAllResponseHeaders: function () {
			var r = "";
			for (var header in this.responseHeaders) {
				if ((header === "set-cookie") || (header === "set-cookie2")) {
					continue;
				}
				//TODO title case header
				r += header + ": " + this.responseHeaders[header] + "\r\n";
			}
			return r;
		},
	
		responseText: "",
		responseXML: undefined, //TODO
	
	
		/*** See http://www.w3.org/TR/progress-events/ ***/
	
		onload: function () {
			// Instances should override this.
		},
	
		onprogress: function () {
			// Instances should override this.
		},
	
		onerror: function () {
			// Instances should override this.
		},
	
		onabort: function () {
			// Instances should override this.
		},
	
		onreadystatechange: function () {
			// Instances should override this.
		},
	
	
		/*** Properties and methods for test interaction ***/
	
		onsend: function () {
			// Instances should override this.
		},
	
		getRequestHeader: function (header) {
			return this.requestHeaders[header.toLowerCase()];
		},
	
		setResponseHeader: function (header, value) {
			this.responseHeaders[header.toLowerCase()] = value;
		},
	
		makeXMLResponse: function (data) {
			var xmlDoc;
			// according to specs from point 3.7.5:
			// "1. If the response entity body is null terminate these steps
			//     and return null.
			//  2. If final MIME type is not null, text/xml, application/xml,
			//     and does not end in +xml terminate these steps and return null.
			var mimetype = this.getResponseHeader("Content-Type");
			mimetype = mimetype && mimetype.split(';', 1)[0];
			if ((mimetype == null) || (mimetype == 'text/xml') ||
				(mimetype == 'application/xml') ||
				(mimetype && mimetype.substring(mimetype.length - 4) == '+xml')) {
				// Attempt to produce an xml response
				// and it will fail if not a good xml
				try {
					if (window.DOMParser) {
						var parser = new DOMParser();
						xmlDoc = parser.parseFromString(data, "text/xml");
					} else { // Internet Explorer
						xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
						xmlDoc.async = "false";
						xmlDoc.loadXML(data);
					}
				} catch (e) {
					// according to specs from point 3.7.5:
					// "3. Let document be a cookie-free Document object that
					// represents the result of parsing the response entity body
					// into a document tree following the rules from the XML
					//  specifications. If this fails (unsupported character
					// encoding, namespace well-formedness error etc.), terminate
					// these steps return null."
					xmlDoc = null;
				}
				// parse errors also yield a null.
				if ((xmlDoc && xmlDoc.parseError && xmlDoc.parseError.errorCode != 0)
					|| (xmlDoc && xmlDoc.documentElement && xmlDoc.documentElement.nodeName == "parsererror")
					|| (xmlDoc && xmlDoc.documentElement && xmlDoc.documentElement.nodeName == "html"
					&&  xmlDoc.documentElement.firstChild &&  xmlDoc.documentElement.firstChild.nodeName == "body"
					&&  xmlDoc.documentElement.firstChild.firstChild && xmlDoc.documentElement.firstChild.firstChild.nodeName == "parsererror")) {
					xmlDoc = null;
				}
			} else {
				// mimetype is specified, but not xml-ish
				xmlDoc = null;
			}
			return xmlDoc;
		},
	
		// Call this to simulate a server response
		receive: function (status, data) {
			if ((this.readyState !== this.OPENED) || (!this.sent)) {
				// Can't respond to unopened request.
				throw "INVALID_STATE_ERR";
			}
	
			this.status = status;
			this.statusText = status + " " + this.statusReasons[status];
			this.readyState = this.HEADERS_RECEIVED;
			this.onprogress();
			this.onreadystatechange();
	
			this.responseText = data;
			this.responseXML = this.makeXMLResponse(data);
	
			this.readyState = this.LOADING;
			this.onprogress();
			this.onreadystatechange();
	
			this.readyState = this.DONE;
			this.onreadystatechange();
			this.onprogress();
			this.onload();
		},
	
		// Call this to simulate a request error (e.g. NETWORK_ERR)
		err: function (exception) {
			if ((this.readyState !== this.OPENED) || (!this.sent)) {
				// Can't respond to unopened request.
				throw "INVALID_STATE_ERR";
			}
	
			this.responseText = null;
			this.error = true;
			for (var header in this.requestHeaders) {
				delete this.requestHeaders[header];
			}
			this.readyState = this.DONE;
			if (!this.async) {
				throw exception;
			}
			this.onreadystatechange();
			this.onerror();
		},
	
		// Convenience method to verify HTTP credentials
		authenticate: function (user, password) {
			if (this.user) {
				return (user === this.user) && (password === this.password);
			}
	
			if (this.urlParts.user) {
				return ((user === this.urlParts.user)
					&& (password === this.urlParts.password));
			}
	
			// Basic auth.  Requires existence of the 'atob' function.
			var auth = this.getRequestHeader("Authorization");
			if (auth === undefined) {
				return false;
			}
			if (auth.substr(0, 6) !== "Basic ") {
				return false;
			}
			if (typeof atob !== "function") {
				return false;
			}
			auth = atob(auth.substr(6));
			var pieces = auth.split(':');
			var requser = pieces.shift();
			var reqpass = pieces.join(':');
			return (user === requser) && (password === reqpass);
		},
	
		// Parse RFC 3986 compliant URIs.
		// Based on parseUri by Steven Levithan <stevenlevithan.com>
		// See http://blog.stevenlevithan.com/archives/parseuri
		parseUri: function (str) {
			var pattern = /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/;
			var key = ["source", "protocol", "authority", "userInfo", "user",
				"password", "host", "port", "relative", "path",
				"directory", "file", "query", "anchor"];
			var querypattern = /(?:^|&)([^&=]*)=?([^&]*)/g;
	
			var match = pattern.exec(str);
			var uri = {};
			var i = 14;
			while (i--) {
				uri[key[i]] = match[i] || "";
			}
	
			uri.queryKey = {};
			uri[key[12]].replace(querypattern, function ($0, $1, $2) {
				if ($1) {
					uri.queryKey[$1] = $2;
				}
			});
	
			return uri;
		}
	};
	
	
	/*
	 * A small mock "server" that intercepts XMLHttpRequest calls and
	 * diverts them to your handler.
	 *
	 * Usage:
	 *
	 * 1. Initialize with either
	 *       var server = new MockHttpServer(your_request_handler);
	 *    or
	 *       var server = new MockHttpServer();
	 *       server.handle = function (request) { ... };
	 *
	 * 2. Call server.start() to start intercepting all XMLHttpRequests.
	 *
	 * 3. Do your tests.
	 *
	 * 4. Call server.stop() to tear down.
	 *
	 * 5. Profit!
	 */
	function MockHttpServer (handler) {
		if (handler) {
			this.handle = handler;
		}
	};
	MockHttpServer.prototype = {
	
		start: function () {
			var self = this;
	
			function Request () {
				this.onsend = function () {
					self.handle(this);
				};
				MockHttpRequest.apply(this, arguments);
			}
			Request.prototype = MockHttpRequest.prototype;
	
			window.OriginalHttpRequest = window.XMLHttpRequest;
			window.XMLHttpRequest = Request;
		},
	
		stop: function () {
			window.XMLHttpRequest = window.OriginalHttpRequest;
		},
	
		handle: function (request) {
			// Instances should override this.
		}
	};
	
	module.exports = MockHttpRequest;

}, 'browser-http/lib/Mocks/Http.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'browser-http/lib/Mocks/Http.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'browser-http/lib/Mocks/Http.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'browser-http/lib/Mocks/Http.js';
	var __dirname = 'browser-http/lib/Mocks';
	var process = {cwd: function() {return '/';}, argv: ['node', 'browser-http/lib/Mocks/Http.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var Http, Request, original;
	
	  Http = require('../Http');
	
	  Request = require('./Request');
	
	  original = Http.createRequest;
	
	  Http.receive = function(sendData, headers, status) {
	    if (sendData == null) {
	      sendData = '';
	    }
	    if (headers == null) {
	      headers = {};
	    }
	    if (status == null) {
	      status = 200;
	    }
	    return Http.createRequest = function(url, type, data, jsonp) {
	      var request;
	      request = new Request(url, type, data, jsonp);
	      request.on('afterSend', function() {
	        var name, value;
	        if (typeof headers['content-type'] === 'undefined') {
	          headers['content-type'] = 'text/plain';
	        }
	        for (name in headers) {
	          value = headers[name];
	          request.xhr.setResponseHeader(name, value);
	        }
	        return request.xhr.receive(status, sendData);
	      });
	      return request;
	    };
	  };
	
	  Http.receiveError = function(err) {
	    return Http.createRequest = function(url, type, data, jsonp) {
	      var request;
	      request = new Request(url, type, data, jsonp);
	      request.on('afterSend', function() {
	        return request.xhr.receiveError(err);
	      });
	      return request;
	    };
	  };
	
	  Http.restore = function() {
	    return Http.createRequest = original;
	  };
	
	  module.exports = Http;
	
	}).call(this);
	

}, '/lib/Ares.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/lib/Ares.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Ares.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/lib/Ares.js';
	var __dirname = '/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Ares.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var Ares, Q, Validators, httpHelpers, isWindow, moment, xml,
	    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
	
	  Validators = require('./Validators');
	
	  Q = require('q');
	
	  xml = require('xml2js');
	
	  moment = require('moment');
	
	  httpHelpers = require('browser-http/Helpers');
	
	  isWindow = typeof window !== 'undefined';
	
	  Ares = (function() {
	    Ares.URL = 'http://wwwinfo.mfcr.cz/cgi-bin/ares/darv_std.cgi';
	
	    Ares.prototype.http = isWindow ? require('browser-http') : require('http');
	
	    Ares.prototype.url = null;
	
	    Ares.prototype.onlyActive = true;
	
	    Ares.prototype.encoding = 'utf';
	
	    Ares.prototype.lastOriginalData = null;
	
	    function Ares(url) {
	      this.url = url != null ? url : Ares.URL;
	      this.prepare = __bind(this.prepare, this);
	      this.parse = __bind(this.parse, this);
	    }
	
	    Ares.prototype.find = function(name, value, limit, type) {
	      var options;
	      if (limit == null) {
	        limit = 10;
	      }
	      if (type == null) {
	        type = 'free';
	      }
	      options = {
	        czk: this.encoding,
	        aktivni: this.onlyActive,
	        max_pocet: limit,
	        typ_vyhledani: type
	      };
	      options[name] = value;
	      if (limit === false) {
	        delete options.max_pocet;
	      }
	      return this.load(options).then(this.parse).then(this.prepare);
	    };
	
	    Ares.prototype.findByIdentification = function(identification, limit) {
	      if (limit == null) {
	        limit = 10;
	      }
	      if (Validators.companyIdentification(identification) === false) {
	        return Q.reject(new Error('Company identification is not valid'));
	      }
	      return this.find('ico', identification, limit, 'ico');
	    };
	
	    Ares.prototype.findByCompanyName = function(name, limit) {
	      if (limit == null) {
	        limit = 10;
	      }
	      return this.find('obchodni_firma', name, limit, 'of');
	    };
	
	    Ares.prototype.getUrl = function(options) {
	      options = httpHelpers.buildQuery(options);
	      return this.url + '?' + options;
	    };
	
	    Ares.prototype.load = function(options) {
	      var deferred, url;
	      url = this.getUrl(options);
	      deferred = Q.defer();
	      if (isWindow) {
	        this.http.get(url).then(function(res) {
	          return deferred.resolve(res.data);
	        }).fail(function(err) {
	          return deferred.reject(err);
	        });
	      } else {
	        this.http.get(url, function(res) {
	          var data;
	          data = [];
	          res.setEncoding('utf8');
	          res.on('data', function(chunk) {
	            return data.push(chunk);
	          });
	          return res.on('end', function() {
	            return deferred.resolve(data.join(''));
	          });
	        }).on('error', function(err) {
	          return deferred.reject(err);
	        });
	      }
	      return deferred.promise;
	    };
	
	    Ares.prototype.parse = function(data) {
	      var deferred,
	        _this = this;
	      deferred = Q.defer();
	      data = this.simplifyXml(data);
	      xml.parseString(data, function(err, data) {
	        if (err) {
	          _this.lastOriginalData = null;
	          return deferred.reject(err);
	        } else {
	          _this.lastOriginalData = data;
	          return deferred.resolve(data);
	        }
	      });
	      return deferred.promise;
	    };
	
	    Ares.prototype.prepare = function(data) {
	      var item, result, _i, _len, _ref;
	      data = data.Ares_odpovedi.Odpoved[0];
	      if (typeof data.Error !== 'undefined') {
	        return Q.reject(new Error(data.Error[0].Error_text[0]));
	      }
	      result = {
	        length: parseInt(data.Pocet_zaznamu[0]),
	        data: []
	      };
	      _ref = data.Zaznam;
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        item = _ref[_i];
	        result.data.push(this.prepareItem(item));
	      }
	      return Q.resolve(result);
	    };
	
	    Ares.prototype.prepareItem = function(item) {
	      var result;
	      result = {
	        created: moment(item.Datum_vzniku[0], 'YYYY-MM-DD').toDate(),
	        validity: moment(item.Datum_platnosti[0], 'YYYY-MM-DD').toDate(),
	        name: item.Obchodni_firma[0],
	        identification: parseInt(item.ICO[0]),
	        address: {
	          district: item.Identifikace[0].Adresa_ARES[0].Nazev_okresu[0],
	          city: item.Identifikace[0].Adresa_ARES[0].Nazev_obce[0],
	          street: item.Identifikace[0].Adresa_ARES[0].Nazev_ulice[0],
	          descriptionNumber: parseInt(item.Identifikace[0].Adresa_ARES[0].Cislo_domovni[0]),
	          zipCode: parseInt(item.Identifikace[0].Adresa_ARES[0].PSC[0])
	        }
	      };
	      if (typeof item.Identifikace[0].Adresa_ARES[0].Cislo_orientacni !== 'undefined') {
	        result.address.orientationNumber = parseInt(item.Identifikace[0].Adresa_ARES[0].Cislo_orientacni[0]);
	      }
	      return result;
	    };
	
	    Ares.prototype.simplifyXml = function(data) {
	      return data.replace('<?xml version="1.0" encoding="UTF-8"?>', '').replace(/(are|dtt|udt)\:/g, '').replace(' xmlns:are="http://wwwinfo.mfcr.cz/ares/xml_doc/schemas/ares/ares_answer/v_1.0.1"', '').replace(' xmlns:dtt="http://wwwinfo.mfcr.cz/ares/xml_doc/schemas/ares/ares_datatypes/v_1.0.4"', '').replace(' xmlns:udt="http://wwwinfo.mfcr.cz/ares/xml_doc/schemas/uvis_datatypes/v_1.0.1"', '').replace(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"', '').replace(' validation_XSLT="/ares/xml_doc/schemas/ares/ares_answer/v_1.0.0/ares_answer.xsl"', '').replace(' xsi:schemaLocation="http://wwwinfo.mfcr.cz/ares/xml_doc/schemas/ares/ares_answer/v_1.0.1 http://wwwinfo.mfcr.cz/ares/xml_doc/schemas/ares/ares_answer/v_1.0.1/ares_answer_v_1.0.1.xsd"', '').replace(/^\s*/, '').replace(/\s*$/, '');
	    };
	
	    return Ares;
	
	  })();
	
	  module.exports = Ares;
	
	}).call(this);
	

}, '/test/browser/tests/Ares.coffee': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/test/browser/tests/Ares.coffee');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/test/browser/tests/Ares.coffee';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/test/browser/tests/Ares.coffee';
	var __dirname = '/test/browser/tests';
	var process = {cwd: function() {return '/';}, argv: ['node', '/test/browser/tests/Ares.coffee'], env: {}};

	/** code **/
	(function() {
	  var Ares, Http, Q, ares;
	
	  Ares = require('ares-data');
	
	  Http = require('browser-http/Mocks/Http');
	
	  Q = require('q');
	
	  Q.stopUnhandledRejectionTracking();
	
	  ares = new Ares('http://localhost/');
	
	  ares.http = Http;
	
	  describe('Ares', function() {
	    afterEach(function() {
	      return Http.restore();
	    });
	    return describe('#findByIdentification()', function() {
	      it('should load old information about author', function(done) {
	        Http.receive(require('../../responses/employer'), {
	          'content-type': 'text/xml'
	        });
	        return ares.findByIdentification(88241653).then(function(data) {
	          expect(data.length).to.equal(1);
	          expect(data.data[0].name).to.equal('David Kudera');
	          expect(ares.lastOriginalData).not.to.be["null"];
	          return done();
	        }).done();
	      });
	      it('should load informations about some random companies', function(done) {
	        Http.receive(require('../../responses/companies'), {
	          'content-type': 'text/xml'
	        });
	        return ares.findByCompanyName('IBM').then(function(data) {
	          expect(data.length).to.be.above(1);
	          expect(ares.lastOriginalData).not.to.be["null"];
	          return done();
	        }).done();
	      });
	      it('should return an error for bad company identification', function(done) {
	        return ares.findByIdentification(12345678).fail(function(err) {
	          expect(err).to.be.an["instanceof"](Error);
	          return done();
	        }).done();
	      });
	      return it('should return an error for more results than limit', function(done) {
	        Http.receive(require('../../responses/limitError'), {
	          'content-type': 'text/xml'
	        });
	        return ares.findByCompanyName('europa').fail(function(err) {
	          expect(err).to.be.an["instanceof"](Error);
	          return done();
	        }).done();
	      });
	    });
	  });
	
	}).call(this);
	

}, '/test/browser/tests/Validators.coffee': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/test/browser/tests/Validators.coffee');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/test/browser/tests/Validators.coffee';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/test/browser/tests/Validators.coffee';
	var __dirname = '/test/browser/tests';
	var process = {cwd: function() {return '/';}, argv: ['node', '/test/browser/tests/Validators.coffee'], env: {}};

	/** code **/
	(function() {
	  var Validators;
	
	  Validators = require('ares-data/Validators');
	
	  describe('Validators', function() {
	    return describe('#companyIdentification()', function() {
	      it('should return true', function() {
	        expect(Validators.companyIdentification('69663963')).to.be["true"];
	        expect(Validators.companyIdentification('   69663963   ')).to.be["true"];
	        expect(Validators.companyIdentification(69663963)).to.be["true"];
	        return expect(Validators.companyIdentification(25596641)).to.be["true"];
	      });
	      return it('should return false', function() {
	        expect(Validators.companyIdentification('---')).to.be["false"];
	        return expect(Validators.companyIdentification('12345678')).to.be["false"];
	      });
	    });
	  });
	
	}).call(this);
	

}, '/test/responses/companies.coffee': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/test/responses/companies.coffee');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/test/responses/companies.coffee';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/test/responses/companies.coffee';
	var __dirname = '/test/responses';
	var process = {cwd: function() {return '/';}, argv: ['node', '/test/responses/companies.coffee'], env: {}};

	/** code **/
	(function() {
	  module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<are:Ares_odpovedi xmlns:are=\"http://wwwinfo.mfcr.cz/ares/xml_doc/schemas/ares/ares_answer/v_1.0.1\" xmlns:dtt=\"http://wwwinfo.mfcr.cz/ares/xml_doc/schemas/ares/ares_datatypes/v_1.0.4\" xmlns:udt=\"http://wwwinfo.mfcr.cz/ares/xml_doc/schemas/uvis_datatypes/v_1.0.1\" odpoved_datum_cas=\"2013-12-08T21:45:44\" odpoved_pocet=\"1\" odpoved_typ=\"Standard\" vystup_format=\"XML\" xslt=\"klient\" validation_XSLT=\"/ares/xml_doc/schemas/ares/ares_answer/v_1.0.0/ares_answer.xsl\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://wwwinfo.mfcr.cz/ares/xml_doc/schemas/ares/ares_answer/v_1.0.1 http://wwwinfo.mfcr.cz/ares/xml_doc/schemas/ares/ares_answer/v_1.0.1/ares_answer_v_1.0.1.xsd\" Id=\"ares\">\n<are:Odpoved>\n<are:Pocet_zaznamu>3</are:Pocet_zaznamu>\n<are:Typ_vyhledani>OF</are:Typ_vyhledani>\n<are:Zaznam>\n<are:Shoda_OF>\n<dtt:Kod>7</dtt:Kod>\n</are:Shoda_OF>\n<are:Vyhledano_dle>OF</are:Vyhledano_dle>\n<are:Typ_registru>\n<dtt:Kod>2</dtt:Kod>\n<dtt:Text>OR</dtt:Text>\n</are:Typ_registru>\n<are:Datum_vzniku>1990-12-20</are:Datum_vzniku>\n<are:Datum_platnosti>2013-12-08</are:Datum_platnosti>\n<are:Pravni_forma>\n<dtt:Kod_PF>112</dtt:Kod_PF>\n</are:Pravni_forma>\n<are:Obchodni_firma>IBM Česká republika, spol. s r.o.</are:Obchodni_firma>\n<are:ICO>14890992</are:ICO>\n<are:Identifikace>\n<are:Adresa_ARES>\n<dtt:ID_adresy>202869063</dtt:ID_adresy>\n<dtt:Kod_statu>203</dtt:Kod_statu>\n<dtt:Nazev_okresu>Hlavní město Praha</dtt:Nazev_okresu>\n<dtt:Nazev_obce>Praha</dtt:Nazev_obce>\n<dtt:Nazev_casti_obce>Chodov</dtt:Nazev_casti_obce>\n<dtt:Nazev_mestske_casti>Praha 11</dtt:Nazev_mestske_casti>\n<dtt:Nazev_ulice>V parku</dtt:Nazev_ulice>\n<dtt:Cislo_domovni>2294</dtt:Cislo_domovni>\n<dtt:Cislo_orientacni>4</dtt:Cislo_orientacni>\n<dtt:PSC>14800</dtt:PSC>\n<dtt:Adresa_UIR>\n<udt:Kod_oblasti>19</udt:Kod_oblasti>\n<udt:Kod_kraje>19</udt:Kod_kraje>\n<udt:Kod_okresu>3100</udt:Kod_okresu>\n<udt:Kod_obce>554782</udt:Kod_obce>\n<udt:Kod_pobvod>43</udt:Kod_pobvod>\n<udt:Kod_sobvod>116</udt:Kod_sobvod>\n<udt:Kod_casti_obce>400211</udt:Kod_casti_obce>\n<udt:Kod_mestske_casti>547034</udt:Kod_mestske_casti>\n<udt:PSC>14800</udt:PSC>\n<udt:Kod_ulice>721719</udt:Kod_ulice>\n<udt:Cislo_domovni>2294</udt:Cislo_domovni>\n<udt:Typ_cislo_domovni>1</udt:Typ_cislo_domovni>\n<udt:Cislo_orientacni>4</udt:Cislo_orientacni>\n<udt:Kod_adresy>25714023</udt:Kod_adresy>\n<udt:Kod_objektu>25226509</udt:Kod_objektu>\n</dtt:Adresa_UIR>\n</are:Adresa_ARES>\n</are:Identifikace>\n<are:Kod_FU>13</are:Kod_FU>\n<are:Priznaky_subjektu>NAAANANNNNNNNNNNNNNNNNNNANNNNN</are:Priznaky_subjektu>\n</are:Zaznam>\n<are:Zaznam>\n<are:Shoda_OF>\n<dtt:Kod>7</dtt:Kod>\n</are:Shoda_OF>\n<are:Vyhledano_dle>OF</are:Vyhledano_dle>\n<are:Typ_registru>\n<dtt:Kod>2</dtt:Kod>\n<dtt:Text>OR</dtt:Text>\n</are:Typ_registru>\n<are:Datum_vzniku>2001-04-02</are:Datum_vzniku>\n<are:Datum_platnosti>2013-12-08</are:Datum_platnosti>\n<are:Pravni_forma>\n<dtt:Kod_PF>112</dtt:Kod_PF>\n</are:Pravni_forma>\n<are:Obchodni_firma>IBM Global Services Delivery Center Czech Republic, s.r.o.</are:Obchodni_firma>\n<are:ICO>26244535</are:ICO>\n<are:Identifikace>\n<are:Adresa_ARES>\n<dtt:ID_adresy>202879318</dtt:ID_adresy>\n<dtt:Kod_statu>203</dtt:Kod_statu>\n<dtt:Nazev_okresu>Brno-město</dtt:Nazev_okresu>\n<dtt:Nazev_obce>Brno</dtt:Nazev_obce>\n<dtt:Nazev_casti_obce>Královo Pole</dtt:Nazev_casti_obce>\n<dtt:Nazev_mestske_casti>Brno-Královo Pole</dtt:Nazev_mestske_casti>\n<dtt:Nazev_ulice>Technická</dtt:Nazev_ulice>\n<dtt:Cislo_domovni>2995</dtt:Cislo_domovni>\n<dtt:Cislo_orientacni>21</dtt:Cislo_orientacni>\n<dtt:PSC>61600</dtt:PSC>\n<dtt:Adresa_UIR>\n<udt:Kod_oblasti>60</udt:Kod_oblasti>\n<udt:Kod_kraje>116</udt:Kod_kraje>\n<udt:Kod_okresu>3702</udt:Kod_okresu>\n<udt:Kod_obce>582786</udt:Kod_obce>\n<udt:Kod_casti_obce>411965</udt:Kod_casti_obce>\n<udt:Kod_mestske_casti>551007</udt:Kod_mestske_casti>\n<udt:PSC>61600</udt:PSC>\n<udt:Kod_ulice>36951</udt:Kod_ulice>\n<udt:Cislo_domovni>2995</udt:Cislo_domovni>\n<udt:Typ_cislo_domovni>1</udt:Typ_cislo_domovni>\n<udt:Cislo_orientacni>21</udt:Cislo_orientacni>\n<udt:Kod_adresy>26714361</udt:Kod_adresy>\n<udt:Kod_objektu>26202018</udt:Kod_objektu>\n</dtt:Adresa_UIR>\n</are:Adresa_ARES>\n</are:Identifikace>\n<are:Kod_FU>13</are:Kod_FU>\n<are:Priznaky_subjektu>NAAANANNNNANNNNNNNNNNNNNANNNNN</are:Priznaky_subjektu>\n</are:Zaznam>\n<are:Zaznam>\n<are:Shoda_OF>\n<dtt:Kod>7</dtt:Kod>\n</are:Shoda_OF>\n<are:Vyhledano_dle>OF</are:Vyhledano_dle>\n<are:Typ_registru>\n<dtt:Kod>4</dtt:Kod>\n<dtt:Text>RŽP</dtt:Text>\n</are:Typ_registru>\n<are:Datum_vzniku>2002-05-13</are:Datum_vzniku>\n<are:Datum_platnosti>2013-12-08</are:Datum_platnosti>\n<are:Pravni_forma>\n<dtt:Kod_PF>112</dtt:Kod_PF>\n</are:Pravni_forma>\n<are:Obchodni_firma>IBM Business Consulting Services s.r.o.</are:Obchodni_firma>\n<are:ICO>26698153</are:ICO>\n<are:Identifikace>\n<are:Adresa_ARES>\n<dtt:ID_adresy>400115370</dtt:ID_adresy>\n<dtt:Kod_statu>203</dtt:Kod_statu>\n<dtt:Nazev_okresu>Hlavní město Praha</dtt:Nazev_okresu>\n<dtt:Nazev_obce>Praha</dtt:Nazev_obce>\n<dtt:Nazev_casti_obce>Nové Město</dtt:Nazev_casti_obce>\n<dtt:Nazev_mestske_casti>Praha 2</dtt:Nazev_mestske_casti>\n<dtt:Nazev_ulice>Kateřinská</dtt:Nazev_ulice>\n<dtt:Cislo_domovni>466</dtt:Cislo_domovni>\n<dtt:Typ_cislo_domovni>1</dtt:Typ_cislo_domovni>\n<dtt:Cislo_orientacni>40</dtt:Cislo_orientacni>\n<dtt:PSC>12000</dtt:PSC>\n<dtt:Adresa_UIR>\n<udt:Kod_oblasti>19</udt:Kod_oblasti>\n<udt:Kod_kraje>19</udt:Kod_kraje>\n<udt:Kod_okresu>3100</udt:Kod_okresu>\n<udt:Kod_obce>554782</udt:Kod_obce>\n<udt:Kod_pobvod>27</udt:Kod_pobvod>\n<udt:Kod_sobvod>27</udt:Kod_sobvod>\n<udt:Kod_casti_obce>490148</udt:Kod_casti_obce>\n<udt:Kod_mestske_casti>500089</udt:Kod_mestske_casti>\n<udt:PSC>12000</udt:PSC>\n<udt:Kod_ulice>451592</udt:Kod_ulice>\n<udt:Cislo_domovni>466</udt:Cislo_domovni>\n<udt:Typ_cislo_domovni>1</udt:Typ_cislo_domovni>\n<udt:Cislo_orientacni>40</udt:Cislo_orientacni>\n<udt:Kod_adresy>25326309</udt:Kod_adresy>\n<udt:Kod_objektu>24857351</udt:Kod_objektu>\n</dtt:Adresa_UIR>\n</are:Adresa_ARES>\n</are:Identifikace>\n<are:Kod_FU>2</are:Kod_FU>\n<are:Priznaky_subjektu>NZZANZNNNNNNNNNNNNNNNNNNZNNNNN</are:Priznaky_subjektu>\n</are:Zaznam>\n</are:Odpoved>\n</are:Ares_odpovedi>\n";
	
	}).call(this);
	

}, '/test/responses/employer.coffee': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/test/responses/employer.coffee');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/test/responses/employer.coffee';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/test/responses/employer.coffee';
	var __dirname = '/test/responses';
	var process = {cwd: function() {return '/';}, argv: ['node', '/test/responses/employer.coffee'], env: {}};

	/** code **/
	(function() {
	  module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<are:Ares_odpovedi xmlns:are=\"http://wwwinfo.mfcr.cz/ares/xml_doc/schemas/ares/ares_answer/v_1.0.1\" xmlns:dtt=\"http://wwwinfo.mfcr.cz/ares/xml_doc/schemas/ares/ares_datatypes/v_1.0.4\" xmlns:udt=\"http://wwwinfo.mfcr.cz/ares/xml_doc/schemas/uvis_datatypes/v_1.0.1\" odpoved_datum_cas=\"2013-12-08T21:32:42\" odpoved_pocet=\"1\" odpoved_typ=\"Standard\" vystup_format=\"XML\" xslt=\"klient\" validation_XSLT=\"/ares/xml_doc/schemas/ares/ares_answer/v_1.0.0/ares_answer.xsl\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://wwwinfo.mfcr.cz/ares/xml_doc/schemas/ares/ares_answer/v_1.0.1 http://wwwinfo.mfcr.cz/ares/xml_doc/schemas/ares/ares_answer/v_1.0.1/ares_answer_v_1.0.1.xsd\" Id=\"ares\">\n<are:Odpoved>\n<are:Pocet_zaznamu>1</are:Pocet_zaznamu>\n<are:Typ_vyhledani>ICO</are:Typ_vyhledani>\n<are:Zaznam>\n<are:Shoda_ICO>\n<dtt:Kod>9</dtt:Kod>\n</are:Shoda_ICO>\n<are:Vyhledano_dle>ICO</are:Vyhledano_dle>\n<are:Typ_registru>\n<dtt:Kod>4</dtt:Kod>\n<dtt:Text>RŽP</dtt:Text>\n</are:Typ_registru>\n<are:Datum_vzniku>2011-10-31</are:Datum_vzniku>\n<are:Datum_platnosti>2013-12-08</are:Datum_platnosti>\n<are:Pravni_forma>\n<dtt:Kod_PF>101</dtt:Kod_PF>\n</are:Pravni_forma>\n<are:Obchodni_firma>David Kudera</are:Obchodni_firma>\n<are:ICO>88241653</are:ICO>\n<are:Identifikace>\n<are:Adresa_ARES>\n<dtt:ID_adresy>406915683</dtt:ID_adresy>\n<dtt:Kod_statu>203</dtt:Kod_statu>\n<dtt:Nazev_okresu>Bruntál</dtt:Nazev_okresu>\n<dtt:Nazev_obce>Rýmařov</dtt:Nazev_obce>\n<dtt:Nazev_casti_obce>Rýmařov</dtt:Nazev_casti_obce>\n<dtt:Nazev_ulice>Bartákova</dtt:Nazev_ulice>\n<dtt:Cislo_domovni>1025</dtt:Cislo_domovni>\n<dtt:Typ_cislo_domovni>1</dtt:Typ_cislo_domovni>\n<dtt:Cislo_orientacni>19</dtt:Cislo_orientacni>\n<dtt:PSC>79501</dtt:PSC>\n<dtt:Adresa_UIR>\n<udt:Kod_oblasti>86</udt:Kod_oblasti>\n<udt:Kod_kraje>132</udt:Kod_kraje>\n<udt:Kod_okresu>3801</udt:Kod_okresu>\n<udt:Kod_obce>597783</udt:Kod_obce>\n<udt:Kod_casti_obce>413089</udt:Kod_casti_obce>\n<udt:PSC>79501</udt:PSC>\n<udt:Kod_ulice>54321</udt:Kod_ulice>\n<udt:Cislo_domovni>1025</udt:Cislo_domovni>\n<udt:Typ_cislo_domovni>1</udt:Typ_cislo_domovni>\n<udt:Cislo_orientacni>19</udt:Cislo_orientacni>\n<udt:Kod_adresy>14090635</udt:Kod_adresy>\n<udt:Kod_objektu>13999354</udt:Kod_objektu>\n<udt:PCD>758205</udt:PCD>\n</dtt:Adresa_UIR>\n</are:Adresa_ARES>\n</are:Identifikace>\n<are:Kod_FU>358</are:Kod_FU>\n<are:Priznaky_subjektu>NNAANNNNNNNNNNNNNNNNNNNNANNNNN</are:Priznaky_subjektu>\n</are:Zaznam>\n</are:Odpoved>\n</are:Ares_odpovedi>\n";
	
	}).call(this);
	

}, '/test/responses/limitError.coffee': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/test/responses/limitError.coffee');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/test/responses/limitError.coffee';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/test/responses/limitError.coffee';
	var __dirname = '/test/responses';
	var process = {cwd: function() {return '/';}, argv: ['node', '/test/responses/limitError.coffee'], env: {}};

	/** code **/
	(function() {
	  module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<are:Ares_odpovedi xmlns:are=\"http://wwwinfo.mfcr.cz/ares/xml_doc/schemas/ares/ares_answer/v_1.0.1\" xmlns:dtt=\"http://wwwinfo.mfcr.cz/ares/xml_doc/schemas/ares/ares_datatypes/v_1.0.4\" xmlns:udt=\"http://wwwinfo.mfcr.cz/ares/xml_doc/schemas/uvis_datatypes/v_1.0.1\" odpoved_datum_cas=\"2013-12-08T21:49:44\" odpoved_pocet=\"1\" odpoved_typ=\"Standard\" vystup_format=\"XML\" xslt=\"klient\" validation_XSLT=\"/ares/xml_doc/schemas/ares/ares_answer/v_1.0.0/ares_answer.xsl\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://wwwinfo.mfcr.cz/ares/xml_doc/schemas/ares/ares_answer/v_1.0.1 http://wwwinfo.mfcr.cz/ares/xml_doc/schemas/ares/ares_answer/v_1.0.1/ares_answer_v_1.0.1.xsd\" Id=\"ares\">\n<are:Odpoved>\n<are:Error>\n<dtt:Error_kod>1</dtt:Error_kod>\n<dtt:Error_text>Na zadaný Dotaz by se vrátilo více odpovědí, než odpovídá parametru max_pocet. POZOR! Hrozí zablokování Vaší IP adresy! Prosím čtěte http://wwwinfo.mfcr.cz/ares/ares_xml_standard.html.cz#max</dtt:Error_text>\n</are:Error>\n<are:Pocet_zaznamu>-1</are:Pocet_zaznamu>\n<are:Typ_vyhledani>OF</are:Typ_vyhledani>\n</are:Odpoved>\n</are:Ares_odpovedi>\n";
	
	}).call(this);
	

}, 'moment/lang/en-gb.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'moment/lang/en-gb.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'moment/lang/en-gb.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'moment/lang/en-gb.js';
	var __dirname = 'moment/lang';
	var process = {cwd: function() {return '/';}, argv: ['node', 'moment/lang/en-gb.js'], env: {}};

	/** code **/
	// moment.js language configuration
	// language : great britain english (en-gb)
	// author : Chris Gedrim : https://github.com/chrisgedrim
	
	(function (factory) {
	    if (typeof define === 'function' && define.amd) {
	        define(['moment'], factory); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory(window.moment); // Browser global
	    }
	}(function (moment) {
	    return moment.lang('en-gb', {
	        months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
	        monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
	        weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
	        weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
	        weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
	        longDateFormat : {
	            LT : "HH:mm",
	            L : "DD/MM/YYYY",
	            LL : "D MMMM YYYY",
	            LLL : "D MMMM YYYY LT",
	            LLLL : "dddd, D MMMM YYYY LT"
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : "in %s",
	            past : "%s ago",
	            s : "a few seconds",
	            m : "a minute",
	            mm : "%d minutes",
	            h : "an hour",
	            hh : "%d hours",
	            d : "a day",
	            dd : "%d days",
	            M : "a month",
	            MM : "%d months",
	            y : "a year",
	            yy : "%d years"
	        },
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~ (number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));
	

}, 'q/benchmark/compare-with-callbacks.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'q/benchmark/compare-with-callbacks.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'q/benchmark/compare-with-callbacks.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'q/benchmark/compare-with-callbacks.js';
	var __dirname = 'q/benchmark';
	var process = {cwd: function() {return '/';}, argv: ['node', 'q/benchmark/compare-with-callbacks.js'], env: {}};

	/** code **/
	"use strict";
	
	var Q = require("../q");
	var fs = require("fs");
	
	suite("A single simple async operation", function () {
	    bench("with an immediately-fulfilled promise", function (done) {
	        Q().then(done);
	    });
	
	    bench("with direct setImmediate usage", function (done) {
	        setImmediate(done);
	    });
	
	    bench("with direct setTimeout(…, 0)", function (done) {
	        setTimeout(done, 0);
	    });
	});
	
	suite("A fs.readFile", function () {
	    var denodeified = Q.denodeify(fs.readFile);
	
	    set("iterations", 1000);
	    set("delay", 1000);
	
	    bench("directly, with callbacks", function (done) {
	        fs.readFile(__filename, done);
	    });
	
	    bench("with Q.nfcall", function (done) {
	        Q.nfcall(fs.readFile, __filename).then(done);
	    });
	
	    bench("with a Q.denodeify'ed version", function (done) {
	        denodeified(__filename).then(done);
	    });
	
	    bench("with manual usage of deferred.makeNodeResolver", function (done) {
	        var deferred = Q.defer();
	        fs.readFile(__filename, deferred.makeNodeResolver());
	        deferred.promise.then(done);
	    });
	});
	
	suite("1000 operations in parallel", function () {
	    function makeCounter(desiredCount, ultimateCallback) {
	        var soFar = 0;
	        return function () {
	            if (++soFar === desiredCount) {
	                ultimateCallback();
	            }
	        };
	    }
	    var numberOfOps = 1000;
	
	    bench("with immediately-fulfilled promises", function (done) {
	        var counter = makeCounter(numberOfOps, done);
	
	        for (var i = 0; i < numberOfOps; ++i) {
	            Q().then(counter);
	        }
	    });
	
	    bench("with direct setImmediate usage", function (done) {
	        var counter = makeCounter(numberOfOps, done);
	
	        for (var i = 0; i < numberOfOps; ++i) {
	            setImmediate(counter);
	        }
	    });
	});
	

}, 'q/benchmark/scenarios.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'q/benchmark/scenarios.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'q/benchmark/scenarios.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'q/benchmark/scenarios.js';
	var __dirname = 'q/benchmark';
	var process = {cwd: function() {return '/';}, argv: ['node', 'q/benchmark/scenarios.js'], env: {}};

	/** code **/
	"use strict";
	
	var Q = require("../q");
	
	suite("Chaining", function () {
	    var numberToChain = 1000;
	
	    bench("Chaining many already-fulfilled promises together", function (done) {
	        var currentPromise = Q();
	        for (var i = 0; i < numberToChain; ++i) {
	            currentPromise = currentPromise.then(function () {
	                return Q();
	            });
	        }
	
	        currentPromise.then(done);
	    });
	
	    bench("Chaining and then fulfilling the end of the chain", function (done) {
	        var deferred = Q.defer();
	
	        var currentPromise = deferred.promise;
	        for (var i = 0; i < numberToChain; ++i) {
	            (function () {
	                var promiseToReturn = currentPromise;
	                currentPromise = Q().then(function () {
	                    return promiseToReturn;
	                });
	            }());
	        }
	
	        currentPromise.then(done);
	
	        deferred.resolve();
	    });
	});
	

}, 'q/package.json': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'q/package.json');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'q/package.json';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'q/package.json';
	var __dirname = 'q';
	var process = {cwd: function() {return '/';}, argv: ['node', 'q/package.json'], env: {}};

	/** code **/
	module.exports = (function() {
	return {
	  "name": "q",
	  "version": "0.9.7",
	  "description": "A library for promises (CommonJS/Promises/A,B,D)",
	  "homepage": "https://github.com/kriskowal/q",
	  "author": {
	    "name": "Kris Kowal",
	    "email": "kris@cixar.com",
	    "url": "https://github.com/kriskowal"
	  },
	  "keywords": [
	    "q",
	    "promise",
	    "promises",
	    "promises-a",
	    "promises-aplus",
	    "deferred",
	    "future",
	    "async",
	    "flow control",
	    "fluent",
	    "browser",
	    "node"
	  ],
	  "contributors": [
	    {
	      "name": "Kris Kowal",
	      "email": "kris@cixar.com",
	      "url": "https://github.com/kriskowal"
	    },
	    {
	      "name": "Irakli Gozalishvili",
	      "email": "rfobic@gmail.com",
	      "url": "http://jeditoolkit.com"
	    },
	    {
	      "name": "Domenic Denicola",
	      "email": "domenic@domenicdenicola.com",
	      "url": "http://domenicdenicola.com"
	    }
	  ],
	  "bugs": {
	    "url": "http://github.com/kriskowal/q/issues"
	  },
	  "license": {
	    "type": "MIT",
	    "url": "http://github.com/kriskowal/q/raw/master/LICENSE"
	  },
	  "main": "q.js",
	  "repository": {
	    "type": "git",
	    "url": "git://github.com/kriskowal/q.git"
	  },
	  "engines": {
	    "node": ">=0.6.0",
	    "teleport": ">=0.2.0"
	  },
	  "dependencies": {},
	  "devDependencies": {
	    "jshint": "~2.1.9",
	    "cover": "*",
	    "jasmine-node": "1.11.0",
	    "opener": "*",
	    "promises-aplus-tests": "1.x",
	    "grunt": "~0.4.1",
	    "grunt-cli": "~0.1.9",
	    "grunt-contrib-uglify": "~0.2.2",
	    "matcha": "~0.2.0"
	  },
	  "scripts": {
	    "test": "jasmine-node spec && promises-aplus-tests spec/aplus-adapter",
	    "test-browser": "opener spec/q-spec.html",
	    "benchmark": "matcha",
	    "lint": "jshint q.js",
	    "cover": "cover run node_modules/jasmine-node/bin/jasmine-node spec && cover report html && opener cover_html/index.html",
	    "minify": "grunt",
	    "prepublish": "grunt"
	  },
	  "overlay": {
	    "teleport": {
	      "dependencies": {
	        "system": ">=0.0.4"
	      }
	    }
	  },
	  "directories": {
	    "test": "./spec"
	  },
	  "readme": "[![Build Status](https://secure.travis-ci.org/kriskowal/q.png?branch=master)](http://travis-ci.org/kriskowal/q)\n\n<a href=\"http://promises-aplus.github.com/promises-spec\">\n    <img src=\"http://promises-aplus.github.com/promises-spec/assets/logo-small.png\"\n         align=\"right\" alt=\"Promises/A+ logo\" />\n</a>\n\nIf a function cannot return a value or throw an exception without\nblocking, it can return a promise instead.  A promise is an object\nthat represents the return value or the thrown exception that the\nfunction may eventually provide.  A promise can also be used as a\nproxy for a [remote object][Q-Connection] to overcome latency.\n\n[Q-Connection]: https://github.com/kriskowal/q-connection\n\nOn the first pass, promises can mitigate the “[Pyramid of\nDoom][POD]”: the situation where code marches to the right faster\nthan it marches forward.\n\n[POD]: http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/\n\n```javascript\nstep1(function (value1) {\n    step2(value1, function(value2) {\n        step3(value2, function(value3) {\n            step4(value3, function(value4) {\n                // Do something with value4\n            });\n        });\n    });\n});\n```\n\nWith a promise library, you can flatten the pyramid.\n\n```javascript\nQ.fcall(promisedStep1)\n.then(promisedStep2)\n.then(promisedStep3)\n.then(promisedStep4)\n.then(function (value4) {\n    // Do something with value4\n})\n.catch(function (error) {\n    // Handle any error from all above steps\n})\n.done();\n```\n\nWith this approach, you also get implicit error propagation, just like `try`,\n`catch`, and `finally`.  An error in `promisedStep1` will flow all the way to\nthe `catch` function, where it’s caught and handled.  (Here `promisedStepN` is\na version of `stepN` that returns a promise.)\n\nThe callback approach is called an “inversion of control”.\nA function that accepts a callback instead of a return value\nis saying, “Don’t call me, I’ll call you.”.  Promises\n[un-invert][IOC] the inversion, cleanly separating the input\narguments from control flow arguments.  This simplifies the\nuse and creation of API’s, particularly variadic,\nrest and spread arguments.\n\n[IOC]: http://www.slideshare.net/domenicdenicola/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript\n\n\n## Getting Started\n\nThe Q module can be loaded as:\n\n-   A ``<script>`` tag (creating a ``Q`` global variable): ~2.5 KB minified and\n    gzipped.\n-   A Node.js and CommonJS module, available in [npm](https://npmjs.org/) as\n    the [q](https://npmjs.org/package/q) package\n-   An AMD module\n-   A [component](https://github.com/component/component) as ``microjs/q``\n-   Using [bower](http://bower.io/) as ``q``\n-   Using [NuGet](http://nuget.org/) as [Q](https://nuget.org/packages/q)\n\nQ can exchange promises with jQuery, Dojo, When.js, WinJS, and more.\n\n## Resources\n\nOur [wiki][] contains a number of useful resources, including:\n\n- A method-by-method [Q API reference][reference].\n- A growing [examples gallery][examples], showing how Q can be used to make\n  everything better. From XHR to database access to accessing the Flickr API,\n  Q is there for you.\n- There are many libraries that produce and consume Q promises for everything\n  from file system/database access or RPC to templating. For a list of some of\n  the more popular ones, see [Libraries][].\n- If you want materials that introduce the promise concept generally, and the\n  below tutorial isn't doing it for you, check out our collection of\n  [presentations, blog posts, and podcasts][resources].\n- A guide for those [coming from jQuery's `$.Deferred`][jquery].\n\nWe'd also love to have you join the Q-Continuum [mailing list][].\n\n[wiki]: https://github.com/kriskowal/q/wiki\n[reference]: https://github.com/kriskowal/q/wiki/API-Reference\n[examples]: https://github.com/kriskowal/q/wiki/Examples-Gallery\n[Libraries]: https://github.com/kriskowal/q/wiki/Libraries\n[resources]: https://github.com/kriskowal/q/wiki/General-Promise-Resources\n[jquery]: https://github.com/kriskowal/q/wiki/Coming-from-jQuery\n[mailing list]: https://groups.google.com/forum/#!forum/q-continuum\n\n\n## Tutorial\n\nPromises have a ``then`` method, which you can use to get the eventual\nreturn value (fulfillment) or thrown exception (rejection).\n\n```javascript\npromiseMeSomething()\n.then(function (value) {\n}, function (reason) {\n});\n```\n\nIf ``promiseMeSomething`` returns a promise that gets fulfilled later\nwith a return value, the first function (the fulfillment handler) will be\ncalled with the value.  However, if the ``promiseMeSomething`` function\ngets rejected later by a thrown exception, the second function (the\nrejection handler) will be called with the exception.\n\nNote that resolution of a promise is always asynchronous: that is, the\nfulfillment or rejection handler will always be called in the next turn of the\nevent loop (i.e. `process.nextTick` in Node). This gives you a nice\nguarantee when mentally tracing the flow of your code, namely that\n``then`` will always return before either handler is executed.\n\nIn this tutorial, we begin with how to consume and work with promises. We'll\ntalk about how to create them, and thus create functions like\n`promiseMeSomething` that return promises, [below](#the-beginning).\n\n\n### Propagation\n\nThe ``then`` method returns a promise, which in this example, I’m\nassigning to ``outputPromise``.\n\n```javascript\nvar outputPromise = getInputPromise()\n.then(function (input) {\n}, function (reason) {\n});\n```\n\nThe ``outputPromise`` variable becomes a new promise for the return\nvalue of either handler.  Since a function can only either return a\nvalue or throw an exception, only one handler will ever be called and it\nwill be responsible for resolving ``outputPromise``.\n\n-   If you return a value in a handler, ``outputPromise`` will get\n    fulfilled.\n\n-   If you throw an exception in a handler, ``outputPromise`` will get\n    rejected.\n\n-   If you return a **promise** in a handler, ``outputPromise`` will\n    “become” that promise.  Being able to become a new promise is useful\n    for managing delays, combining results, or recovering from errors.\n\nIf the ``getInputPromise()`` promise gets rejected and you omit the\nrejection handler, the **error** will go to ``outputPromise``:\n\n```javascript\nvar outputPromise = getInputPromise()\n.then(function (value) {\n});\n```\n\nIf the input promise gets fulfilled and you omit the fulfillment handler, the\n**value** will go to ``outputPromise``:\n\n```javascript\nvar outputPromise = getInputPromise()\n.then(null, function (error) {\n});\n```\n\nQ promises provide a ``fail`` shorthand for ``then`` when you are only\ninterested in handling the error:\n\n```javascript\nvar outputPromise = getInputPromise()\n.fail(function (error) {\n});\n```\n\nIf you are writing JavaScript for modern engines only or using\nCoffeeScript, you may use `catch` instead of `fail`.\n\nPromises also have a ``fin`` function that is like a ``finally`` clause.\nThe final handler gets called, with no arguments, when the promise\nreturned by ``getInputPromise()`` either returns a value or throws an\nerror.  The value returned or error thrown by ``getInputPromise()``\npasses directly to ``outputPromise`` unless the final handler fails, and\nmay be delayed if the final handler returns a promise.\n\n```javascript\nvar outputPromise = getInputPromise()\n.fin(function () {\n    // close files, database connections, stop servers, conclude tests\n});\n```\n\n-   If the handler returns a value, the value is ignored\n-   If the handler throws an error, the error passes to ``outputPromise``\n-   If the handler returns a promise, ``outputPromise`` gets postponed.  The\n    eventual value or error has the same effect as an immediate return\n    value or thrown error: a value would be ignored, an error would be\n    forwarded.\n\nIf you are writing JavaScript for modern engines only or using\nCoffeeScript, you may use `finally` instead of `fin`.\n\n### Chaining\n\nThere are two ways to chain promises.  You can chain promises either\ninside or outside handlers.  The next two examples are equivalent.\n\n```javascript\nreturn getUsername()\n.then(function (username) {\n    return getUser(username)\n    .then(function (user) {\n        // if we get here without an error,\n        // the value returned here\n        // or the exception thrown here\n        // resolves the promise returned\n        // by the first line\n    })\n});\n```\n\n```javascript\nreturn getUsername()\n.then(function (username) {\n    return getUser(username);\n})\n.then(function (user) {\n    // if we get here without an error,\n    // the value returned here\n    // or the exception thrown here\n    // resolves the promise returned\n    // by the first line\n});\n```\n\nThe only difference is nesting.  It’s useful to nest handlers if you\nneed to capture multiple input values in your closure.\n\n```javascript\nfunction authenticate() {\n    return getUsername()\n    .then(function (username) {\n        return getUser(username);\n    })\n    // chained because we will not need the user name in the next event\n    .then(function (user) {\n        return getPassword()\n        // nested because we need both user and password next\n        .then(function (password) {\n            if (user.passwordHash !== hash(password)) {\n                throw new Error(\"Can't authenticate\");\n            }\n        });\n    });\n}\n```\n\n\n### Combination\n\nYou can turn an array of promises into a promise for the whole,\nfulfilled array using ``all``.\n\n```javascript\nreturn Q.all([\n    eventualAdd(2, 2),\n    eventualAdd(10, 20)\n]);\n```\n\nIf you have a promise for an array, you can use ``spread`` as a\nreplacement for ``then``.  The ``spread`` function “spreads” the\nvalues over the arguments of the fulfillment handler.  The rejection handler\nwill get called at the first sign of failure.  That is, whichever of\nthe recived promises fails first gets handled by the rejection handler.\n\n```javascript\nfunction eventualAdd(a, b) {\n    return Q.spread([a, b], function (a, b) {\n        return a + b;\n    })\n}\n```\n\nBut ``spread`` calls ``all`` initially, so you can skip it in chains.\n\n```javascript\nreturn getUsername()\n.then(function (username) {\n    return [username, getUser(username)];\n})\n.spread(function (username, user) {\n});\n```\n\nThe ``all`` function returns a promise for an array of values.  When this\npromise is fulfilled, the array contains the fulfillment values of the original\npromises, in the same order as those promises.  If one of the given promises\nis rejected, the returned promise is immediately rejected, not waiting for the\nrest of the batch.  If you want to wait for all of the promises to either be\nfulfilled or rejected, you can use ``allSettled``.\n\n```javascript\nQ.allSettled(promises)\n.then(function (results) {\n    results.forEach(function (result) {\n        if (result.state === \"fulfilled\") {\n            var value = result.value;\n        } else {\n            var reason = result.reason;\n        }\n    });\n});\n```\n\n\n### Sequences\n\nIf you have a number of promise-producing functions that need\nto be run sequentially, you can of course do so manually:\n\n```javascript\nreturn foo(initialVal).then(bar).then(baz).then(qux);\n```\n\nHowever, if you want to run a dynamically constructed sequence of\nfunctions, you'll want something like this:\n\n```javascript\nvar funcs = [foo, bar, baz, qux];\n\nvar result = Q(initialVal);\nfuncs.forEach(function (f) {\n    result = result.then(f);\n});\nreturn result;\n```\n\nYou can make this slightly more compact using `reduce`:\n\n```javascript\nreturn funcs.reduce(function (soFar, f) {\n    return soFar.then(f);\n}, Q(initialVal));\n```\n\nOr, you could use th ultra-compact version:\n\n```javascript\nreturn funcs.reduce(Q.when, Q());\n```\n\n### Handling Errors\n\nOne sometimes-unintuive aspect of promises is that if you throw an\nexception in the fulfillment handler, it will not be be caught by the error\nhandler.\n\n```javascript\nreturn foo()\n.then(function (value) {\n    throw new Error(\"Can't bar.\");\n}, function (error) {\n    // We only get here if \"foo\" fails\n});\n```\n\nTo see why this is, consider the parallel between promises and\n``try``/``catch``. We are ``try``-ing to execute ``foo()``: the error\nhandler represents a ``catch`` for ``foo()``, while the fulfillment handler\nrepresents code that happens *after* the ``try``/``catch`` block.\nThat code then needs its own ``try``/``catch`` block.\n\nIn terms of promises, this means chaining your rejection handler:\n\n```javascript\nreturn foo()\n.then(function (value) {\n    throw new Error(\"Can't bar.\");\n})\n.fail(function (error) {\n    // We get here with either foo's error or bar's error\n});\n```\n\n### Progress Notification\n\nIt's possible for promises to report their progress, e.g. for tasks that take a\nlong time like a file upload. Not all promises will implement progress\nnotifications, but for those that do, you can consume the progress values using\na third parameter to ``then``:\n\n```javascript\nreturn uploadFile()\n.then(function () {\n    // Success uploading the file\n}, function (err) {\n    // There was an error, and we get the reason for error\n}, function (progress) {\n    // We get notified of the upload's progress as it is executed\n});\n```\n\nLike `fail`, Q also provides a shorthand for progress callbacks\ncalled `progress`:\n\n```javascript\nreturn uploadFile().progress(function (progress) {\n    // We get notified of the upload's progress\n});\n```\n\n### The End\n\nWhen you get to the end of a chain of promises, you should either\nreturn the last promise or end the chain.  Since handlers catch\nerrors, it’s an unfortunate pattern that the exceptions can go\nunobserved.\n\nSo, either return it,\n\n```javascript\nreturn foo()\n.then(function () {\n    return \"bar\";\n});\n```\n\nOr, end it.\n\n```javascript\nfoo()\n.then(function () {\n    return \"bar\";\n})\n.done();\n```\n\nEnding a promise chain makes sure that, if an error doesn’t get\nhandled before the end, it will get rethrown and reported.\n\nThis is a stopgap. We are exploring ways to make unhandled errors\nvisible without any explicit handling.\n\n\n### The Beginning\n\nEverything above assumes you get a promise from somewhere else.  This\nis the common case.  Every once in a while, you will need to create a\npromise from scratch.\n\n#### Using ``Q.fcall``\n\nYou can create a promise from a value using ``Q.fcall``.  This returns a\npromise for 10.\n\n```javascript\nreturn Q.fcall(function () {\n    return 10;\n});\n```\n\nYou can also use ``fcall`` to get a promise for an exception.\n\n```javascript\nreturn Q.fcall(function () {\n    throw new Error(\"Can't do it\");\n});\n```\n\nAs the name implies, ``fcall`` can call functions, or even promised\nfunctions.  This uses the ``eventualAdd`` function above to add two\nnumbers.\n\n```javascript\nreturn Q.fcall(eventualAdd, 2, 2);\n```\n\n\n#### Using Deferreds\n\nIf you have to interface with asynchronous functions that are callback-based\ninstead of promise-based, Q provides a few shortcuts (like ``Q.nfcall`` and\nfriends). But much of the time, the solution will be to use *deferreds*.\n\n```javascript\nvar deferred = Q.defer();\nFS.readFile(\"foo.txt\", \"utf-8\", function (error, text) {\n    if (error) {\n        deferred.reject(new Error(error));\n    } else {\n        deferred.resolve(text);\n    }\n});\nreturn deferred.promise;\n```\n\nNote that a deferred can be resolved with a value or a promise.  The\n``reject`` function is a shorthand for resolving with a rejected\npromise.\n\n```javascript\n// this:\ndeferred.reject(new Error(\"Can't do it\"));\n\n// is shorthand for:\nvar rejection = Q.fcall(function () {\n    throw new Error(\"Can't do it\");\n});\ndeferred.resolve(rejection);\n```\n\nThis is a simplified implementation of ``Q.delay``.\n\n```javascript\nfunction delay(ms) {\n    var deferred = Q.defer();\n    setTimeout(deferred.resolve, ms);\n    return deferred.promise;\n}\n```\n\nThis is a simplified implementation of ``Q.timeout``\n\n```javascript\nfunction timeout(promise, ms) {\n    var deferred = Q.defer();\n    Q.when(promise, deferred.resolve);\n    delay(ms).then(function () {\n        deferred.reject(new Error(\"Timed out\"));\n    });\n    return deferred.promise;\n}\n```\n\nFinally, you can send a progress notification to the promise with\n``deferred.notify``.\n\nFor illustration, this is a wrapper for XML HTTP requests in the browser. Note\nthat a more [thorough][XHR] implementation would be in order in practice.\n\n[XHR]: https://github.com/montagejs/mr/blob/71e8df99bb4f0584985accd6f2801ef3015b9763/browser.js#L29-L73\n\n```javascript\nfunction requestOkText(url) {\n    var request = new XMLHttpRequest();\n    var deferred = Q.defer();\n\n    request.open(\"GET\", url, true);\n    request.onload = onload;\n    request.onerror = onerror;\n    request.onprogress = onprogress;\n    request.send();\n\n    function onload() {\n        if (request.status === 200) {\n            deferred.resolve(request.responseText);\n        } else {\n            deferred.reject(new Error(\"Status code was \" + request.status));\n        }\n    }\n\n    function onerror() {\n        deferred.reject(new Error(\"Can't XHR \" + JSON.stringify(url)));\n    }\n\n    function onprogress(event) {\n        deferred.notify(event.loaded / event.total);\n    }\n\n    return deferred.promise;\n}\n```\n\nBelow is an example of how to use this ``requestOkText`` function:\n\n```javascript\nrequestOkText(\"http://localhost:3000\")\n.then(function (responseText) {\n    // If the HTTP response returns 200 OK, log the response text.\n    console.log(responseText);\n}, function (error) {\n    // If there's an error or a non-200 status code, log the error.\n    console.error(error);\n}, function (progress) {\n    // Log the progress as it comes in.\n    console.log(\"Request progress: \" + Math.round(progress * 100) + \"%\");\n});\n```\n\n### The Middle\n\nIf you are using a function that may return a promise, but just might\nreturn a value if it doesn’t need to defer, you can use the “static”\nmethods of the Q library.\n\nThe ``when`` function is the static equivalent for ``then``.\n\n```javascript\nreturn Q.when(valueOrPromise, function (value) {\n}, function (error) {\n});\n```\n\nAll of the other methods on a promise have static analogs with the\nsame name.\n\nThe following are equivalent:\n\n```javascript\nreturn Q.all([a, b]);\n```\n\n```javascript\nreturn Q.fcall(function () {\n    return [a, b];\n})\n.all();\n```\n\nWhen working with promises provided by other libraries, you should\nconvert it to a Q promise.  Not all promise libraries make the same\nguarantees as Q and certainly don’t provide all of the same methods.\nMost libraries only provide a partially functional ``then`` method.\nThis thankfully is all we need to turn them into vibrant Q promises.\n\n```javascript\nreturn Q($.ajax(...))\n.then(function () {\n});\n```\n\nIf there is any chance that the promise you receive is not a Q promise\nas provided by your library, you should wrap it using a Q function.\nYou can even use ``Q.invoke`` as a shorthand.\n\n```javascript\nreturn Q.invoke($, 'ajax', ...)\n.then(function () {\n});\n```\n\n\n### Over the Wire\n\nA promise can serve as a proxy for another object, even a remote\nobject.  There are methods that allow you to optimistically manipulate\nproperties or call functions.  All of these interactions return\npromises, so they can be chained.\n\n```\ndirect manipulation         using a promise as a proxy\n--------------------------  -------------------------------\nvalue.foo                   promise.get(\"foo\")\nvalue.foo = value           promise.put(\"foo\", value)\ndelete value.foo            promise.del(\"foo\")\nvalue.foo(...args)          promise.post(\"foo\", [args])\nvalue.foo(...args)          promise.invoke(\"foo\", ...args)\nvalue(...args)              promise.fapply([args])\nvalue(...args)              promise.fcall(...args)\n```\n\nIf the promise is a proxy for a remote object, you can shave\nround-trips by using these functions instead of ``then``.  To take\nadvantage of promises for remote objects, check out [Q-Connection][].\n\n[Q-Connection]: https://github.com/kriskowal/q-connection\n\nEven in the case of non-remote objects, these methods can be used as\nshorthand for particularly-simple fulfillment handlers. For example, you\ncan replace\n\n```javascript\nreturn Q.fcall(function () {\n    return [{ foo: \"bar\" }, { foo: \"baz\" }];\n})\n.then(function (value) {\n    return value[0].foo;\n});\n```\n\nwith\n\n```javascript\nreturn Q.fcall(function () {\n    return [{ foo: \"bar\" }, { foo: \"baz\" }];\n})\n.get(0)\n.get(\"foo\");\n```\n\n\n### Adapting Node\n\nIf you're working with functions that make use of the Node.js callback pattern,\nwhere callbacks are in the form of `function(err, result)`, Q provides a few\nuseful utility functions for converting between them. The most straightforward\nare probably `Q.nfcall` and `Q.nfapply` (\"Node function call/apply\") for calling\nNode.js-style functions and getting back a promise:\n\n```javascript\nreturn Q.nfcall(FS.readFile, \"foo.txt\", \"utf-8\");\nreturn Q.nfapply(FS.readFile, [\"foo.txt\", \"utf-8\"]);\n```\n\nIf you are working with methods, instead of simple functions, you can easily\nrun in to the usual problems where passing a method to another function—like\n`Q.nfcall`—\"un-binds\" the method from its owner. To avoid this, you can either\nuse `Function.prototype.bind` or some nice shortcut methods we provide:\n\n```javascript\nreturn Q.ninvoke(redisClient, \"get\", \"user:1:id\");\nreturn Q.npost(redisClient, \"get\", [\"user:1:id\"]);\n```\n\nYou can also create reusable wrappers with `Q.denodeify` or `Q.nbind`:\n\n```javascript\nvar readFile = Q.denodeify(FS.readFile);\nreturn readFile(\"foo.txt\", \"utf-8\");\n\nvar redisClientGet = Q.nbind(redisClient.get, redisClient);\nreturn redisClientGet(\"user:1:id\");\n```\n\nFinally, if you're working with raw deferred objects, there is a\n`makeNodeResolver` method on deferreds that can be handy:\n\n```javascript\nvar deferred = Q.defer();\nFS.readFile(\"foo.txt\", \"utf-8\", deferred.makeNodeResolver());\nreturn deferred.promise;\n```\n\n### Long Stack Traces\n\nQ comes with optional support for “long stack traces,” wherein the `stack`\nproperty of `Error` rejection reasons is rewritten to be traced along\nasynchronous jumps instead of stopping at the most recent one. As an example:\n\n```js\nfunction theDepthsOfMyProgram() {\n  Q.delay(100).done(function explode() {\n    throw new Error(\"boo!\");\n  });\n}\n\ntheDepthsOfMyProgram();\n```\n\nusually would give a rather unhelpful stack trace looking something like\n\n```\nError: boo!\n    at explode (/path/to/test.js:3:11)\n    at _fulfilled (/path/to/test.js:q:54)\n    at resolvedValue.promiseDispatch.done (/path/to/q.js:823:30)\n    at makePromise.promise.promiseDispatch (/path/to/q.js:496:13)\n    at pending (/path/to/q.js:397:39)\n    at process.startup.processNextTick.process._tickCallback (node.js:244:9)\n```\n\nBut, if you turn this feature on by setting\n\n```js\nQ.longStackSupport = true;\n```\n\nthen the above code gives a nice stack trace to the tune of\n\n```\nError: boo!\n    at explode (/path/to/test.js:3:11)\nFrom previous event:\n    at theDepthsOfMyProgram (/path/to/test.js:2:16)\n    at Object.<anonymous> (/path/to/test.js:7:1)\n```\n\nNote how you can see the the function that triggered the async operation in the\nstack trace! This is very helpful for debugging, as otherwise you end up getting\nonly the first line, plus a bunch of Q internals, with no sign of where the\noperation started.\n\nThis feature does come with somewhat-serious performance and memory overhead,\nhowever. If you're working with lots of promises, or trying to scale a server\nto many users, you should probably keep it off. But in development, go for it!\n\n## Tests\n\nYou can view the results of the Q test suite [in your browser][tests]!\n\n[tests]: https://rawgithub.com/kriskowal/q/master/spec/q-spec.html\n\n## License\n\nCopyright 2009–2013 Kristopher Michael Kowal\nMIT License (enclosed)\n\n",
	  "readmeFilename": "README.md",
	  "_id": "q@0.9.7",
	  "_from": "q@~0.9.7"
	}
	
	}).call(this);
	

}, 'q/queue.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'q/queue.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'q/queue.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'q/queue.js';
	var __dirname = 'q';
	var process = {cwd: function() {return '/';}, argv: ['node', 'q/queue.js'], env: {}};

	/** code **/
	
	var Q = require("./q");
	
	module.exports = Queue;
	function Queue() {
	    var ends = Q.defer();
	    var closed = Q.defer();
	    return {
	        put: function (value) {
	            var next = Q.defer();
	            ends.resolve({
	                head: value,
	                tail: next.promise
	            });
	            ends.resolve = next.resolve;
	        },
	        get: function () {
	            var result = ends.promise.get("head");
	            ends.promise = ends.promise.get("tail");
	            return result.fail(function (error) {
	                closed.resolve(error);
	                throw error;
	            });
	        },
	        closed: closed.promise,
	        close: function (error) {
	            error = error || new Error("Can't get value from closed queue");
	            var end = {head: Q.reject(error)};
	            end.tail = end;
	            ends.resolve(end);
	            return closed.promise;
	        }
	    };
	}
	
	

}, 'sax/component.json': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/component.json');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/component.json';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/component.json';
	var __dirname = 'sax';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/component.json'], env: {}};

	/** code **/
	module.exports = (function() {
	return {
	  "name": "sax",
	  "description": "An evented streaming XML parser in JavaScript",
	  "author": "Isaac Z. Schlueter <i@izs.me> (http://blog.izs.me/)",
	  "version": "0.5.2",
	  "main": "lib/sax.js",
	  "license": "BSD",
	  "scripts": [
	    "lib/sax.js"
	  ],
	  "repository": "git://github.com/isaacs/sax-js.git"
	}
	
	}).call(this);
	

}, 'sax/examples/example.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/examples/example.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/examples/example.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/examples/example.js';
	var __dirname = 'sax/examples';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/examples/example.js'], env: {}};

	/** code **/
	
	var fs = require("fs"),
	  util = require("util"),
	  path = require("path"),
	  xml = fs.readFileSync(path.join(__dirname, "test.xml"), "utf8"),
	  sax = require("../lib/sax"),
	  strict = sax.parser(true),
	  loose = sax.parser(false, {trim:true}),
	  inspector = function (ev) { return function (data) {
	    console.error("%s %s %j", this.line+":"+this.column, ev, data);
	  }};
	
	sax.EVENTS.forEach(function (ev) {
	  loose["on"+ev] = inspector(ev);
	});
	loose.onend = function () {
	  console.error("end");
	  console.error(loose);
	};
	
	// do this in random bits at a time to verify that it works.
	(function () {
	  if (xml) {
	    var c = Math.ceil(Math.random() * 1000)
	    loose.write(xml.substr(0,c));
	    xml = xml.substr(c);
	    process.nextTick(arguments.callee);
	  } else loose.close();
	})();
	

}, 'sax/examples/get-products.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/examples/get-products.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/examples/get-products.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/examples/get-products.js';
	var __dirname = 'sax/examples';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/examples/get-products.js'], env: {}};

	/** code **/
	// pull out /GeneralSearchResponse/categories/category/items/product tags
	// the rest we don't care about.
	
	var sax = require("../lib/sax.js")
	var fs = require("fs")
	var path = require("path")
	var xmlFile = path.resolve(__dirname, "shopping.xml")
	var util = require("util")
	var http = require("http")
	
	fs.readFile(xmlFile, function (er, d) {
	  http.createServer(function (req, res) {
	    if (er) throw er
	    var xmlstr = d.toString("utf8")
	
	    var parser = sax.parser(true)
	    var products = []
	    var product = null
	    var currentTag = null
	
	    parser.onclosetag = function (tagName) {
	      if (tagName === "product") {
	        products.push(product)
	        currentTag = product = null
	        return
	      }
	      if (currentTag && currentTag.parent) {
	        var p = currentTag.parent
	        delete currentTag.parent
	        currentTag = p
	      }
	    }
	
	    parser.onopentag = function (tag) {
	      if (tag.name !== "product" && !product) return
	      if (tag.name === "product") {
	        product = tag
	      }
	      tag.parent = currentTag
	      tag.children = []
	      tag.parent && tag.parent.children.push(tag)
	      currentTag = tag
	    }
	
	    parser.ontext = function (text) {
	      if (currentTag) currentTag.children.push(text)
	    }
	
	    parser.onend = function () {
	      var out = util.inspect(products, false, 3, true)
	      res.writeHead(200, {"content-type":"application/json"})
	      res.end("{\"ok\":true}")
	      // res.end(JSON.stringify(products))
	    }
	
	    parser.write(xmlstr).end()
	  }).listen(1337)
	})
	

}, 'sax/examples/hello-world.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/examples/hello-world.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/examples/hello-world.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/examples/hello-world.js';
	var __dirname = 'sax/examples';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/examples/hello-world.js'], env: {}};

	/** code **/
	require("http").createServer(function (req, res) {
	  res.writeHead(200, {"content-type":"application/json"})
	  res.end(JSON.stringify({ok: true}))
	}).listen(1337)
	

}, 'sax/examples/pretty-print.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/examples/pretty-print.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/examples/pretty-print.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/examples/pretty-print.js';
	var __dirname = 'sax/examples';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/examples/pretty-print.js'], env: {}};

	/** code **/
	var sax = require("../lib/sax")
	  , printer = sax.createStream(false, {lowercasetags:true, trim:true})
	  , fs = require("fs")
	
	function entity (str) {
	  return str.replace('"', '&quot;')
	}
	
	printer.tabstop = 2
	printer.level = 0
	printer.indent = function () {
	  print("\n")
	  for (var i = this.level; i > 0; i --) {
	    for (var j = this.tabstop; j > 0; j --) {
	      print(" ")
	    }
	  }
	}
	printer.on("opentag", function (tag) {
	  this.indent()
	  this.level ++
	  print("<"+tag.name)
	  for (var i in tag.attributes) {
	    print(" "+i+"=\""+entity(tag.attributes[i])+"\"")
	  }
	  print(">")
	})
	
	printer.on("text", ontext)
	printer.on("doctype", ontext)
	function ontext (text) {
	  this.indent()
	  print(text)
	}
	
	printer.on("closetag", function (tag) {
	  this.level --
	  this.indent()
	  print("</"+tag+">")
	})
	
	printer.on("cdata", function (data) {
	  this.indent()
	  print("<![CDATA["+data+"]]>")
	})
	
	printer.on("comment", function (comment) {
	  this.indent()
	  print("<!--"+comment+"-->")
	})
	
	printer.on("error", function (error) {
	  console.error(error)
	  throw error
	})
	
	if (!process.argv[2]) {
	  throw new Error("Please provide an xml file to prettify\n"+
	    "TODO: read from stdin or take a file")
	}
	var xmlfile = require("path").join(process.cwd(), process.argv[2])
	var fstr = fs.createReadStream(xmlfile, { encoding: "utf8" })
	
	function print (c) {
	  if (!process.stdout.write(c)) {
	    fstr.pause()
	  }
	}
	
	process.stdout.on("drain", function () {
	  fstr.resume()
	})
	
	fstr.pipe(printer)
	

}, 'sax/package.json': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/package.json');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/package.json';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/package.json';
	var __dirname = 'sax';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/package.json'], env: {}};

	/** code **/
	module.exports = (function() {
	return {
	  "name": "sax",
	  "description": "An evented streaming XML parser in JavaScript",
	  "author": {
	    "name": "Isaac Z. Schlueter",
	    "email": "i@izs.me",
	    "url": "http://blog.izs.me/"
	  },
	  "version": "0.5.5",
	  "main": "lib/sax.js",
	  "license": "BSD",
	  "scripts": {
	    "test": "node test/index.js"
	  },
	  "repository": {
	    "type": "git",
	    "url": "git://github.com/isaacs/sax-js.git"
	  },
	  "contributors": [
	    {
	      "name": "Isaac Z. Schlueter",
	      "email": "i@izs.me"
	    },
	    {
	      "name": "Stein Martin Hustad",
	      "email": "stein@hustad.com"
	    },
	    {
	      "name": "Mikeal Rogers",
	      "email": "mikeal.rogers@gmail.com"
	    },
	    {
	      "name": "Laurie Harper",
	      "email": "laurie@holoweb.net"
	    },
	    {
	      "name": "Jann Horn",
	      "email": "jann@Jann-PC.fritz.box"
	    },
	    {
	      "name": "Elijah Insua",
	      "email": "tmpvar@gmail.com"
	    },
	    {
	      "name": "Henry Rawas",
	      "email": "henryr@schakra.com"
	    },
	    {
	      "name": "Justin Makeig",
	      "email": "jmpublic@makeig.com"
	    },
	    {
	      "name": "Mike Schilling",
	      "email": "mike@emotive.com"
	    }
	  ],
	  "readme": "# sax js\n\nA sax-style parser for XML and HTML.\n\nDesigned with [node](http://nodejs.org/) in mind, but should work fine in\nthe browser or other CommonJS implementations.\n\n## What This Is\n\n* A very simple tool to parse through an XML string.\n* A stepping stone to a streaming HTML parser.\n* A handy way to deal with RSS and other mostly-ok-but-kinda-broken XML \n  docs.\n\n## What This Is (probably) Not\n\n* An HTML Parser - That's a fine goal, but this isn't it.  It's just\n  XML.\n* A DOM Builder - You can use it to build an object model out of XML,\n  but it doesn't do that out of the box.\n* XSLT - No DOM = no querying.\n* 100% Compliant with (some other SAX implementation) - Most SAX\n  implementations are in Java and do a lot more than this does.\n* An XML Validator - It does a little validation when in strict mode, but\n  not much.\n* A Schema-Aware XSD Thing - Schemas are an exercise in fetishistic \n  masochism.\n* A DTD-aware Thing - Fetching DTDs is a much bigger job.\n\n## Regarding `<!DOCTYPE`s and `<!ENTITY`s\n\nThe parser will handle the basic XML entities in text nodes and attribute\nvalues: `&amp; &lt; &gt; &apos; &quot;`. It's possible to define additional\nentities in XML by putting them in the DTD. This parser doesn't do anything\nwith that. If you want to listen to the `ondoctype` event, and then fetch\nthe doctypes, and read the entities and add them to `parser.ENTITIES`, then\nbe my guest.\n\nUnknown entities will fail in strict mode, and in loose mode, will pass\nthrough unmolested.\n\n## Usage\n\n    var sax = require(\"./lib/sax\"),\n      strict = true, // set to false for html-mode\n      parser = sax.parser(strict);\n\n    parser.onerror = function (e) {\n      // an error happened.\n    };\n    parser.ontext = function (t) {\n      // got some text.  t is the string of text.\n    };\n    parser.onopentag = function (node) {\n      // opened a tag.  node has \"name\" and \"attributes\"\n    };\n    parser.onattribute = function (attr) {\n      // an attribute.  attr has \"name\" and \"value\"\n    };\n    parser.onend = function () {\n      // parser stream is done, and ready to have more stuff written to it.\n    };\n\n    parser.write('<xml>Hello, <who name=\"world\">world</who>!</xml>').close();\n\n    // stream usage\n    // takes the same options as the parser\n    var saxStream = require(\"sax\").createStream(strict, options)\n    saxStream.on(\"error\", function (e) {\n      // unhandled errors will throw, since this is a proper node\n      // event emitter.\n      console.error(\"error!\", e)\n      // clear the error\n      this._parser.error = null\n      this._parser.resume()\n    })\n    saxStream.on(\"opentag\", function (node) {\n      // same object as above\n    })\n    // pipe is supported, and it's readable/writable\n    // same chunks coming in also go out.\n    fs.createReadStream(\"file.xml\")\n      .pipe(saxStream)\n      .pipe(fs.createWriteStream(\"file-copy.xml\"))\n\n\n\n## Arguments\n\nPass the following arguments to the parser function.  All are optional.\n\n`strict` - Boolean. Whether or not to be a jerk. Default: `false`.\n\n`opt` - Object bag of settings regarding string formatting.  All default to `false`.\n\nSettings supported:\n\n* `trim` - Boolean. Whether or not to trim text and comment nodes.\n* `normalize` - Boolean. If true, then turn any whitespace into a single\n  space.\n* `lowercase` - Boolean. If true, then lowercase tag names and attribute names\n  in loose mode, rather than uppercasing them.\n* `xmlns` - Boolean. If true, then namespaces are supported.\n* `position` - Boolean. If false, then don't track line/col/position.\n\n## Methods\n\n`write` - Write bytes onto the stream. You don't have to do this all at\nonce. You can keep writing as much as you want.\n\n`close` - Close the stream. Once closed, no more data may be written until\nit is done processing the buffer, which is signaled by the `end` event.\n\n`resume` - To gracefully handle errors, assign a listener to the `error`\nevent. Then, when the error is taken care of, you can call `resume` to\ncontinue parsing. Otherwise, the parser will not continue while in an error\nstate.\n\n## Members\n\nAt all times, the parser object will have the following members:\n\n`line`, `column`, `position` - Indications of the position in the XML\ndocument where the parser currently is looking.\n\n`startTagPosition` - Indicates the position where the current tag starts.\n\n`closed` - Boolean indicating whether or not the parser can be written to.\nIf it's `true`, then wait for the `ready` event to write again.\n\n`strict` - Boolean indicating whether or not the parser is a jerk.\n\n`opt` - Any options passed into the constructor.\n\n`tag` - The current tag being dealt with.\n\nAnd a bunch of other stuff that you probably shouldn't touch.\n\n## Events\n\nAll events emit with a single argument. To listen to an event, assign a\nfunction to `on<eventname>`. Functions get executed in the this-context of\nthe parser object. The list of supported events are also in the exported\n`EVENTS` array.\n\nWhen using the stream interface, assign handlers using the EventEmitter\n`on` function in the normal fashion.\n\n`error` - Indication that something bad happened. The error will be hanging\nout on `parser.error`, and must be deleted before parsing can continue. By\nlistening to this event, you can keep an eye on that kind of stuff. Note:\nthis happens *much* more in strict mode. Argument: instance of `Error`.\n\n`text` - Text node. Argument: string of text.\n\n`doctype` - The `<!DOCTYPE` declaration. Argument: doctype string.\n\n`processinginstruction` - Stuff like `<?xml foo=\"blerg\" ?>`. Argument:\nobject with `name` and `body` members. Attributes are not parsed, as\nprocessing instructions have implementation dependent semantics.\n\n`sgmldeclaration` - Random SGML declarations. Stuff like `<!ENTITY p>`\nwould trigger this kind of event. This is a weird thing to support, so it\nmight go away at some point. SAX isn't intended to be used to parse SGML,\nafter all.\n\n`opentag` - An opening tag. Argument: object with `name` and `attributes`.\nIn non-strict mode, tag names are uppercased, unless the `lowercase`\noption is set.  If the `xmlns` option is set, then it will contain\nnamespace binding information on the `ns` member, and will have a\n`local`, `prefix`, and `uri` member.\n\n`closetag` - A closing tag. In loose mode, tags are auto-closed if their\nparent closes. In strict mode, well-formedness is enforced. Note that\nself-closing tags will have `closeTag` emitted immediately after `openTag`.\nArgument: tag name.\n\n`attribute` - An attribute node.  Argument: object with `name` and `value`.\nIn non-strict mode, attribute names are uppercased, unless the `lowercase`\noption is set.  If the `xmlns` option is set, it will also contains namespace\ninformation.\n\n`comment` - A comment node.  Argument: the string of the comment.\n\n`opencdata` - The opening tag of a `<![CDATA[` block.\n\n`cdata` - The text of a `<![CDATA[` block. Since `<![CDATA[` blocks can get\nquite large, this event may fire multiple times for a single block, if it\nis broken up into multiple `write()`s. Argument: the string of random\ncharacter data.\n\n`closecdata` - The closing tag (`]]>`) of a `<![CDATA[` block.\n\n`opennamespace` - If the `xmlns` option is set, then this event will\nsignal the start of a new namespace binding.\n\n`closenamespace` - If the `xmlns` option is set, then this event will\nsignal the end of a namespace binding.\n\n`end` - Indication that the closed stream has ended.\n\n`ready` - Indication that the stream has reset, and is ready to be written\nto.\n\n`noscript` - In non-strict mode, `<script>` tags trigger a `\"script\"`\nevent, and their contents are not checked for special xml characters.\nIf you pass `noscript: true`, then this behavior is suppressed.\n\n## Reporting Problems\n\nIt's best to write a failing test if you find an issue.  I will always\naccept pull requests with failing tests if they demonstrate intended\nbehavior, but it is very hard to figure out what issue you're describing\nwithout a test.  Writing a test is also the best way for you yourself\nto figure out if you really understand the issue you think you have with\nsax-js.\n",
	  "readmeFilename": "README.md",
	  "bugs": {
	    "url": "https://github.com/isaacs/sax-js/issues"
	  },
	  "homepage": "https://github.com/isaacs/sax-js",
	  "_id": "sax@0.5.5",
	  "_from": "sax@0.5.x"
	}
	
	}).call(this);
	

}, 'sax/test/attribute-name.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/attribute-name.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/attribute-name.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/attribute-name.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/attribute-name.js'], env: {}};

	/** code **/
	require(__dirname).test(
	  { xml: "<root length='12345'></root>"
	  , expect: [
	    ["attribute", {
	      name: "length"
	    , value: "12345"
	    , prefix: ""
	    , local: "length"
	    , uri: ""
	    }]
	  , ["opentag", {
	      name: "root"
	    , prefix: ""
	    , local: "root"
	    , uri: ""
	    , attributes: {
	      length: {
	        name: "length"
	      , value: "12345"
	      , prefix: ""
	      , local: "length"
	      , uri: ""
	      }
	    }
	    , ns: {}
	    , isSelfClosing: false
	    }]
	  , ["closetag", "root"]
	  ]
	  , strict: true
	  , opt: { xmlns: true }
	  }
	)
	

}, 'sax/test/buffer-overrun.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/buffer-overrun.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/buffer-overrun.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/buffer-overrun.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/buffer-overrun.js'], env: {}};

	/** code **/
	// set this really low so that I don't have to put 64 MB of xml in here.
	var sax = require("../lib/sax")
	var bl = sax.MAX_BUFFER_LENGTH
	sax.MAX_BUFFER_LENGTH = 5;
	
	require(__dirname).test({
	  expect : [
	    ["error", "Max buffer length exceeded: tagName\nLine: 0\nColumn: 15\nChar: "],
	    ["error", "Max buffer length exceeded: tagName\nLine: 0\nColumn: 30\nChar: "],
	    ["error", "Max buffer length exceeded: tagName\nLine: 0\nColumn: 45\nChar: "],
	    ["opentag", {
	     "name": "ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ",
	     "attributes": {},
	     "isSelfClosing": false
	    }],
	    ["text", "yo"],
	    ["closetag", "ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ"]
	  ]
	}).write("<abcdefghijklmn")
	  .write("opqrstuvwxyzABC")
	  .write("DEFGHIJKLMNOPQR")
	  .write("STUVWXYZ>")
	  .write("yo")
	  .write("</abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ>")
	  .close();
	sax.MAX_BUFFER_LENGTH = bl
	

}, 'sax/test/case.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/case.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/case.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/case.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/case.js'], env: {}};

	/** code **/
	// default to uppercase
	require(__dirname).test
	  ( { xml :
	      "<span class=\"test\" hello=\"world\"></span>"
	    , expect :
	      [ [ "attribute", { name: "CLASS", value: "test" } ]
	      , [ "attribute", { name: "HELLO", value: "world" } ]
	      , [ "opentag", { name: "SPAN",
	                       attributes: { CLASS: "test", HELLO: "world" },
	                       isSelfClosing: false } ]
	      , [ "closetag", "SPAN" ]
	      ]
	    , strict : false
	    , opt : {}
	    }
	  )
	
	// lowercase option : lowercase tag/attribute names
	require(__dirname).test
	  ( { xml :
	      "<span class=\"test\" hello=\"world\"></span>"
	    , expect :
	      [ [ "attribute", { name: "class", value: "test" } ]
	      , [ "attribute", { name: "hello", value: "world" } ]
	      , [ "opentag", { name: "span",
	                       attributes: { class: "test", hello: "world" },
	                       isSelfClosing: false } ]
	      , [ "closetag", "span" ]
	      ]
	    , strict : false
	    , opt : {lowercase:true}
	    }
	  )
	
	// backward compatibility with old lowercasetags opt
	require(__dirname).test
	  ( { xml :
	      "<span class=\"test\" hello=\"world\"></span>"
	    , expect :
	      [ [ "attribute", { name: "class", value: "test" } ]
	      , [ "attribute", { name: "hello", value: "world" } ]
	      , [ "opentag", { name: "span",
	                       attributes: { class: "test", hello: "world" },
	                       isSelfClosing: false } ]
	      , [ "closetag", "span" ]
	      ]
	    , strict : false
	    , opt : {lowercasetags:true}
	    }
	  )
	

}, 'sax/test/cdata-chunked.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/cdata-chunked.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/cdata-chunked.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/cdata-chunked.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/cdata-chunked.js'], env: {}};

	/** code **/
	
	require(__dirname).test({
	  expect : [
	    ["opentag", {"name": "R","attributes": {}, "isSelfClosing": false}],
	    ["opencdata", undefined],
	    ["cdata", " this is character data  "],
	    ["closecdata", undefined],
	    ["closetag", "R"]
	  ]
	}).write("<r><![CDATA[ this is ").write("character data  ").write("]]></r>").close();
	
	

}, 'sax/test/cdata-end-split.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/cdata-end-split.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/cdata-end-split.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/cdata-end-split.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/cdata-end-split.js'], env: {}};

	/** code **/
	
	require(__dirname).test({
	  expect : [
	    ["opentag", {"name": "R","attributes": {}, "isSelfClosing": false}],
	    ["opencdata", undefined],
	    ["cdata", " this is "],
	    ["closecdata", undefined],
	    ["closetag", "R"]
	  ]
	})
	  .write("<r><![CDATA[ this is ]")
	  .write("]>")
	  .write("</r>")
	  .close();
	
	

}, 'sax/test/cdata-fake-end.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/cdata-fake-end.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/cdata-fake-end.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/cdata-fake-end.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/cdata-fake-end.js'], env: {}};

	/** code **/
	
	var p = require(__dirname).test({
	  expect : [
	    ["opentag", {"name": "R","attributes": {}, "isSelfClosing": false}],
	    ["opencdata", undefined],
	    ["cdata", "[[[[[[[[]]]]]]]]"],
	    ["closecdata", undefined],
	    ["closetag", "R"]
	  ]
	})
	var x = "<r><![CDATA[[[[[[[[[]]]]]]]]]]></r>"
	for (var i = 0; i < x.length ; i ++) {
	  p.write(x.charAt(i))
	}
	p.close();
	
	
	var p2 = require(__dirname).test({
	  expect : [
	    ["opentag", {"name": "R","attributes": {}, "isSelfClosing": false}],
	    ["opencdata", undefined],
	    ["cdata", "[[[[[[[[]]]]]]]]"],
	    ["closecdata", undefined],
	    ["closetag", "R"]
	  ]
	})
	var x = "<r><![CDATA[[[[[[[[[]]]]]]]]]]></r>"
	p2.write(x).close();
	

}, 'sax/test/cdata-multiple.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/cdata-multiple.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/cdata-multiple.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/cdata-multiple.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/cdata-multiple.js'], env: {}};

	/** code **/
	
	require(__dirname).test({
	  expect : [
	    ["opentag", {"name": "R","attributes": {}, "isSelfClosing": false}],
	    ["opencdata", undefined],
	    ["cdata", " this is "],
	    ["closecdata", undefined],
	    ["opencdata", undefined],
	    ["cdata", "character data  "],
	    ["closecdata", undefined],
	    ["closetag", "R"]
	  ]
	}).write("<r><![CDATA[ this is ]]>").write("<![CDA").write("T").write("A[")
	  .write("character data  ").write("]]></r>").close();
	
	

}, 'sax/test/cdata.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/cdata.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/cdata.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/cdata.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/cdata.js'], env: {}};

	/** code **/
	require(__dirname).test({
	  xml : "<r><![CDATA[ this is character data  ]]></r>",
	  expect : [
	    ["opentag", {"name": "R","attributes": {}, "isSelfClosing": false}],
	    ["opencdata", undefined],
	    ["cdata", " this is character data  "],
	    ["closecdata", undefined],
	    ["closetag", "R"]
	  ]
	});
	

}, 'sax/test/cyrillic.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/cyrillic.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/cyrillic.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/cyrillic.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/cyrillic.js'], env: {}};

	/** code **/
	require(__dirname).test({
	  xml: '<Р>тест</Р>',
	  expect: [
	    ['opentag', {'name':'Р', attributes:{}, isSelfClosing: false}],
	    ['text', 'тест'],
	    ['closetag', 'Р']
	  ]
	});
	

}, 'sax/test/duplicate-attribute.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/duplicate-attribute.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/duplicate-attribute.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/duplicate-attribute.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/duplicate-attribute.js'], env: {}};

	/** code **/
	require(__dirname).test
	  ( { xml :
	      "<span id=\"hello\" id=\"there\"></span>"
	    , expect :
	      [ [ "attribute", { name: "ID", value: "hello" } ]
	      , [ "opentag", { name: "SPAN",
	                       attributes: { ID: "hello" }, isSelfClosing: false } ]
	      , [ "closetag", "SPAN" ]
	      ]
	    , strict : false
	    , opt : {}
	    }
	  )
	

}, 'sax/test/entities.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/entities.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/entities.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/entities.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/entities.js'], env: {}};

	/** code **/
	require(__dirname).test({
	  xml: '<r>&rfloor; ' +
	       '&spades; &copy; &rarr; &amp; ' +
	        '&lt; < <  <   < &gt; &real; &weierp; &euro;</r>',
	  expect: [
	    ['opentag', {'name':'R', attributes:{}, isSelfClosing: false}],
	    ['text', '⌋ ♠ © → & < < <  <   < > ℜ ℘ €'],
	    ['closetag', 'R']
	  ]
	});
	

}, 'sax/test/entity-mega.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/entity-mega.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/entity-mega.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/entity-mega.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/entity-mega.js'], env: {}};

	/** code **/
	var sax = require('../');
	var xml = '<r>';
	var text = '';
	for (var i in sax.ENTITIES) {
	  xml += '&' + i + ';'
	  text += sax.ENTITIES[i]
	}
	xml += '</r>'
	require(__dirname).test({
	  xml: xml,
	  expect: [
	    ['opentag', {'name':'R', attributes:{}, isSelfClosing: false}],
	    ['text', text],
	    ['closetag', 'R']
	  ]
	});
	

}, 'sax/test/index.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/index.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/index.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/index.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/index.js'], env: {}};

	/** code **/
	var globalsBefore = JSON.stringify(Object.keys(global))
	  , util = require("util")
	  , assert = require("assert")
	  , fs = require("fs")
	  , path = require("path")
	  , sax = require("../lib/sax")
	
	exports.sax = sax
	
	// handy way to do simple unit tests
	// if the options contains an xml string, it'll be written and the parser closed.
	// otherwise, it's assumed that the test will write and close.
	exports.test = function test (options) {
	  var xml = options.xml
	    , parser = sax.parser(options.strict, options.opt)
	    , expect = options.expect
	    , e = 0
	  sax.EVENTS.forEach(function (ev) {
	    parser["on" + ev] = function (n) {
	      if (process.env.DEBUG) {
	        console.error({ expect: expect[e]
	                      , actual: [ev, n] })
	      }
	      if (e >= expect.length && (ev === "end" || ev === "ready")) return
	      assert.ok( e < expect.length,
	        "expectation #"+e+" "+util.inspect(expect[e])+"\n"+
	        "Unexpected event: "+ev+" "+(n ? util.inspect(n) : ""))
	      var inspected = n instanceof Error ? "\n"+ n.message : util.inspect(n)
	      assert.equal(ev, expect[e][0],
	        "expectation #"+e+"\n"+
	        "Didn't get expected event\n"+
	        "expect: "+expect[e][0] + " " +util.inspect(expect[e][1])+"\n"+
	        "actual: "+ev+" "+inspected+"\n")
	      if (ev === "error") assert.equal(n.message, expect[e][1])
	      else assert.deepEqual(n, expect[e][1],
	        "expectation #"+e+"\n"+
	        "Didn't get expected argument\n"+
	        "expect: "+expect[e][0] + " " +util.inspect(expect[e][1])+"\n"+
	        "actual: "+ev+" "+inspected+"\n")
	      e++
	      if (ev === "error") parser.resume()
	    }
	  })
	  if (xml) parser.write(xml).close()
	  return parser
	}
	
	if (module === require.main) {
	  var running = true
	    , failures = 0
	
	  function fail (file, er) {
	    util.error("Failed: "+file)
	    util.error(er.stack || er.message)
	    failures ++
	  }
	
	  fs.readdir(__dirname, function (error, files) {
	    files = files.filter(function (file) {
	      return (/\.js$/.exec(file) && file !== 'index.js')
	    })
	    var n = files.length
	      , i = 0
	    console.log("0.." + n)
	    files.forEach(function (file) {
	      // run this test.
	      try {
	        require(path.resolve(__dirname, file))
	        var globalsAfter = JSON.stringify(Object.keys(global))
	        if (globalsAfter !== globalsBefore) {
	          var er = new Error("new globals introduced\n"+
	                             "expected: "+globalsBefore+"\n"+
	                             "actual:   "+globalsAfter)
	          globalsBefore = globalsAfter
	          throw er
	        }
	        console.log("ok " + (++i) + " - " + file)
	      } catch (er) {
	        console.log("not ok "+ (++i) + " - " + file)
	        fail(file, er)
	      }
	    })
	    if (!failures) return console.log("#all pass")
	    else return console.error(failures + " failure" + (failures > 1 ? "s" : ""))
	  })
	}
	

}, 'sax/test/issue-23.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/issue-23.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/issue-23.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/issue-23.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/issue-23.js'], env: {}};

	/** code **/
	
	require(__dirname).test
	  ( { xml :
	      "<compileClassesResponse>"+
	        "<result>"+
	          "<bodyCrc>653724009</bodyCrc>"+
	          "<column>-1</column>"+
	          "<id>01pG0000002KoSUIA0</id>"+
	          "<line>-1</line>"+
	          "<name>CalendarController</name>"+
	          "<success>true</success>"+
	        "</result>"+
	      "</compileClassesResponse>"
	
	    , expect :
	      [ [ "opentag", { name: "COMPILECLASSESRESPONSE", attributes: {}, isSelfClosing: false } ]
	      , [ "opentag", { name : "RESULT", attributes: {}, isSelfClosing: false } ]
	      , [ "opentag", { name: "BODYCRC", attributes: {}, isSelfClosing: false } ]
	      , [ "text", "653724009" ]
	      , [ "closetag", "BODYCRC" ]
	      , [ "opentag", { name: "COLUMN", attributes: {}, isSelfClosing: false } ]
	      , [ "text", "-1" ]
	      , [ "closetag", "COLUMN" ]
	      , [ "opentag", { name: "ID", attributes: {}, isSelfClosing: false } ]
	      , [ "text", "01pG0000002KoSUIA0" ]
	      , [ "closetag", "ID" ]
	      , [ "opentag", {name: "LINE", attributes: {}, isSelfClosing: false } ]
	      , [ "text", "-1" ]
	      , [ "closetag", "LINE" ]
	      , [ "opentag", {name: "NAME", attributes: {}, isSelfClosing: false } ]
	      , [ "text", "CalendarController" ]
	      , [ "closetag", "NAME" ]
	      , [ "opentag", {name: "SUCCESS", attributes: {}, isSelfClosing: false } ]
	      , [ "text", "true" ]
	      , [ "closetag", "SUCCESS" ]
	      , [ "closetag", "RESULT" ]
	      , [ "closetag", "COMPILECLASSESRESPONSE" ]
	      ]
	    , strict : false
	    , opt : {}
	    }
	  )
	
	

}, 'sax/test/issue-30.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/issue-30.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/issue-30.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/issue-30.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/issue-30.js'], env: {}};

	/** code **/
	// https://github.com/isaacs/sax-js/issues/33
	require(__dirname).test
	  ( { xml : "<xml>\n"+
	            "<!-- \n"+
	            "  comment with a single dash- in it\n"+
	            "-->\n"+
	            "<data/>\n"+
	            "</xml>"
	
	    , expect :
	      [ [ "opentag", { name: "xml", attributes: {}, isSelfClosing: false } ]
	      , [ "text", "\n" ]
	      , [ "comment", " \n  comment with a single dash- in it\n" ]
	      , [ "text", "\n" ]
	      , [ "opentag", { name: "data", attributes: {}, isSelfClosing: true } ]
	      , [ "closetag", "data" ]
	      , [ "text", "\n" ]
	      , [ "closetag", "xml" ]
	      ]
	    , strict : true
	    , opt : {}
	    }
	  )
	
	

}, 'sax/test/issue-35.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/issue-35.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/issue-35.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/issue-35.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/issue-35.js'], env: {}};

	/** code **/
	// https://github.com/isaacs/sax-js/issues/35
	require(__dirname).test
	  ( { xml : "<xml>&#Xd;&#X0d;\n"+
	            "</xml>"
	
	    , expect :
	      [ [ "opentag", { name: "xml", attributes: {}, isSelfClosing: false } ]
	      , [ "text", "\r\r\n" ]
	      , [ "closetag", "xml" ]
	      ]
	    , strict : true
	    , opt : {}
	    }
	  )
	
	

}, 'sax/test/issue-47.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/issue-47.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/issue-47.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/issue-47.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/issue-47.js'], env: {}};

	/** code **/
	// https://github.com/isaacs/sax-js/issues/47
	require(__dirname).test
	  ( { xml : '<a href="query.svc?x=1&y=2&z=3"/>'
	    , expect : [
	        [ "attribute", { name:'HREF', value:"query.svc?x=1&y=2&z=3"} ],
	        [ "opentag", { name: "A", attributes: { HREF:"query.svc?x=1&y=2&z=3"}, isSelfClosing: true } ],
	        [ "closetag", "A" ]
	      ]
	    , opt : {}
	    }
	  )
	
	

}, 'sax/test/issue-49.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/issue-49.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/issue-49.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/issue-49.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/issue-49.js'], env: {}};

	/** code **/
	// https://github.com/isaacs/sax-js/issues/49
	require(__dirname).test
	  ( { xml : "<xml><script>hello world</script></xml>"
	    , expect :
	      [ [ "opentag", { name: "xml", attributes: {}, isSelfClosing: false } ]
	      , [ "opentag", { name: "script", attributes: {}, isSelfClosing: false } ]
	      , [ "text", "hello world" ]
	      , [ "closetag", "script" ]
	      , [ "closetag", "xml" ]
	      ]
	    , strict : false
	    , opt : { lowercasetags: true, noscript: true }
	    }
	  )
	
	require(__dirname).test
	  ( { xml : "<xml><script><![CDATA[hello world]]></script></xml>"
	    , expect :
	      [ [ "opentag", { name: "xml", attributes: {}, isSelfClosing: false } ]
	      , [ "opentag", { name: "script", attributes: {}, isSelfClosing: false } ]
	      , [ "opencdata", undefined ]
	      , [ "cdata", "hello world" ]
	      , [ "closecdata", undefined ]
	      , [ "closetag", "script" ]
	      , [ "closetag", "xml" ]
	      ]
	    , strict : false
	    , opt : { lowercasetags: true, noscript: true }
	    }
	  )
	
	

}, 'sax/test/issue-84.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/issue-84.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/issue-84.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/issue-84.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/issue-84.js'], env: {}};

	/** code **/
	// https://github.com/isaacs/sax-js/issues/49
	require(__dirname).test
	  ( { xml : "<?has unbalanced \"quotes?><xml>body</xml>"
	    , expect :
	      [ [ "processinginstruction", { name: "has", body: "unbalanced \"quotes" } ],
	        [ "opentag", { name: "xml", attributes: {}, isSelfClosing: false } ]
	      , [ "text", "body" ]
	      , [ "closetag", "xml" ]
	      ]
	    , strict : false
	    , opt : { lowercasetags: true, noscript: true }
	    }
	  )
	

}, 'sax/test/parser-position.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/parser-position.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/parser-position.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/parser-position.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/parser-position.js'], env: {}};

	/** code **/
	var sax = require("../lib/sax"),
	    assert = require("assert")
	
	function testPosition(chunks, expectedEvents) {
	  var parser = sax.parser();
	  expectedEvents.forEach(function(expectation) {
	    parser['on' + expectation[0]] = function() {
	      for (var prop in expectation[1]) {
	        assert.equal(parser[prop], expectation[1][prop]);
	      }
	    }
	  });
	  chunks.forEach(function(chunk) {
	    parser.write(chunk);
	  });
	};
	
	testPosition(['<div>abcdefgh</div>'],
	             [ ['opentag',  { position:  5, startTagPosition:  1 }]
	             , ['text',     { position: 19, startTagPosition: 14 }]
	             , ['closetag', { position: 19, startTagPosition: 14 }]
	             ]);
	
	testPosition(['<div>abcde','fgh</div>'],
	             [ ['opentag',  { position:  5, startTagPosition:  1 }]
	             , ['text',     { position: 19, startTagPosition: 14 }]
	             , ['closetag', { position: 19, startTagPosition: 14 }]
	             ]);
	

}, 'sax/test/script-close-better.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/script-close-better.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/script-close-better.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/script-close-better.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/script-close-better.js'], env: {}};

	/** code **/
	require(__dirname).test({
	  xml : "<html><head><script>'<div>foo</div></'</script></head></html>",
	  expect : [
	    ["opentag", {"name": "HTML","attributes": {}, isSelfClosing: false}],
	    ["opentag", {"name": "HEAD","attributes": {}, isSelfClosing: false}],
	    ["opentag", {"name": "SCRIPT","attributes": {}, isSelfClosing: false}],
	    ["script", "'<div>foo</div></'"],
	    ["closetag", "SCRIPT"],
	    ["closetag", "HEAD"],
	    ["closetag", "HTML"]
	  ]
	});
	

}, 'sax/test/script.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/script.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/script.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/script.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/script.js'], env: {}};

	/** code **/
	require(__dirname).test({
	  xml : "<html><head><script>if (1 < 0) { console.log('elo there'); }</script></head></html>",
	  expect : [
	    ["opentag", {"name": "HTML","attributes": {}, "isSelfClosing": false}],
	    ["opentag", {"name": "HEAD","attributes": {}, "isSelfClosing": false}],
	    ["opentag", {"name": "SCRIPT","attributes": {}, "isSelfClosing": false}],
	    ["script", "if (1 < 0) { console.log('elo there'); }"],
	    ["closetag", "SCRIPT"],
	    ["closetag", "HEAD"],
	    ["closetag", "HTML"]
	  ]
	});
	

}, 'sax/test/self-closing-child-strict.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/self-closing-child-strict.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/self-closing-child-strict.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/self-closing-child-strict.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/self-closing-child-strict.js'], env: {}};

	/** code **/
	
	require(__dirname).test({
	  xml :
	  "<root>"+
	    "<child>" +
	      "<haha />" +
	    "</child>" +
	    "<monkey>" +
	      "=(|)" +
	    "</monkey>" +
	  "</root>",
	  expect : [
	    ["opentag", {
	     "name": "root",
	     "attributes": {},
	     "isSelfClosing": false
	    }],
	    ["opentag", {
	     "name": "child",
	     "attributes": {},
	     "isSelfClosing": false
	    }],
	    ["opentag", {
	     "name": "haha",
	     "attributes": {},
	     "isSelfClosing": true
	    }],
	    ["closetag", "haha"],
	    ["closetag", "child"],
	    ["opentag", {
	     "name": "monkey",
	     "attributes": {},
	     "isSelfClosing": false
	    }],
	    ["text", "=(|)"],
	    ["closetag", "monkey"],
	    ["closetag", "root"],
	    ["end"],
	    ["ready"]
	  ],
	  strict : true,
	  opt : {}
	});
	
	

}, 'sax/test/self-closing-child.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/self-closing-child.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/self-closing-child.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/self-closing-child.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/self-closing-child.js'], env: {}};

	/** code **/
	
	require(__dirname).test({
	  xml :
	  "<root>"+
	    "<child>" +
	      "<haha />" +
	    "</child>" +
	    "<monkey>" +
	      "=(|)" +
	    "</monkey>" +
	  "</root>",
	  expect : [
	    ["opentag", {
	     "name": "ROOT",
	     "attributes": {},
	     "isSelfClosing": false
	    }],
	    ["opentag", {
	     "name": "CHILD",
	     "attributes": {},
	     "isSelfClosing": false
	    }],
	    ["opentag", {
	     "name": "HAHA",
	     "attributes": {},
	     "isSelfClosing": true
	    }],
	    ["closetag", "HAHA"],
	    ["closetag", "CHILD"],
	    ["opentag", {
	     "name": "MONKEY",
	     "attributes": {},
	     "isSelfClosing": false
	    }],
	    ["text", "=(|)"],
	    ["closetag", "MONKEY"],
	    ["closetag", "ROOT"],
	    ["end"],
	    ["ready"]
	  ],
	  strict : false,
	  opt : {}
	});
	
	

}, 'sax/test/self-closing-tag.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/self-closing-tag.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/self-closing-tag.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/self-closing-tag.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/self-closing-tag.js'], env: {}};

	/** code **/
	
	require(__dirname).test({
	  xml :
	  "<root>   "+
	    "<haha /> "+
	    "<haha/>  "+
	    "<monkey> "+
	      "=(|)     "+
	    "</monkey>"+
	  "</root>  ",
	  expect : [
	    ["opentag", {name:"ROOT", attributes:{}, isSelfClosing: false}],
	    ["opentag", {name:"HAHA", attributes:{}, isSelfClosing: true}],
	    ["closetag", "HAHA"],
	    ["opentag", {name:"HAHA", attributes:{}, isSelfClosing: true}],
	    ["closetag", "HAHA"],
	    // ["opentag", {name:"HAHA", attributes:{}}],
	    // ["closetag", "HAHA"],
	    ["opentag", {name:"MONKEY", attributes:{}, isSelfClosing: false}],
	    ["text", "=(|)"],
	    ["closetag", "MONKEY"],
	    ["closetag", "ROOT"]
	  ],
	  opt : { trim : true }
	});

}, 'sax/test/stray-ending.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/stray-ending.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/stray-ending.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/stray-ending.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/stray-ending.js'], env: {}};

	/** code **/
	// stray ending tags should just be ignored in non-strict mode.
	// https://github.com/isaacs/sax-js/issues/32
	require(__dirname).test
	  ( { xml :
	      "<a><b></c></b></a>"
	    , expect :
	      [ [ "opentag", { name: "A", attributes: {}, isSelfClosing: false } ]
	      , [ "opentag", { name: "B", attributes: {}, isSelfClosing: false } ]
	      , [ "text", "</c>" ]
	      , [ "closetag", "B" ]
	      , [ "closetag", "A" ]
	      ]
	    , strict : false
	    , opt : {}
	    }
	  )
	
	

}, 'sax/test/trailing-attribute-no-value.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/trailing-attribute-no-value.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/trailing-attribute-no-value.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/trailing-attribute-no-value.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/trailing-attribute-no-value.js'], env: {}};

	/** code **/
	
	require(__dirname).test({
	  xml :
	  "<root attrib>",
	  expect : [
	    ["attribute", {name:"ATTRIB", value:"attrib"}],
	    ["opentag", {name:"ROOT", attributes:{"ATTRIB":"attrib"}, isSelfClosing: false}]
	  ],
	  opt : { trim : true }
	});
	

}, 'sax/test/trailing-non-whitespace.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/trailing-non-whitespace.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/trailing-non-whitespace.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/trailing-non-whitespace.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/trailing-non-whitespace.js'], env: {}};

	/** code **/
	
	require(__dirname).test({
	  xml : "<span>Welcome,</span> to monkey land",
	  expect : [
	    ["opentag", {
	     "name": "SPAN",
	     "attributes": {},
	     isSelfClosing: false
	    }],
	    ["text", "Welcome,"],
	    ["closetag", "SPAN"],
	    ["text", " to monkey land"],
	    ["end"],
	    ["ready"]
	  ],
	  strict : false,
	  opt : {}
	});
	

}, 'sax/test/unclosed-root.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/unclosed-root.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/unclosed-root.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/unclosed-root.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/unclosed-root.js'], env: {}};

	/** code **/
	require(__dirname).test
	  ( { xml : "<root>"
	
	    , expect :
	      [ [ "opentag", { name: "root", attributes: {}, isSelfClosing: false } ]
	      , [ "error", "Unclosed root tag\nLine: 0\nColumn: 6\nChar: " ]
	      ]
	    , strict : true
	    , opt : {}
	    }
	  )
	

}, 'sax/test/unquoted.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/unquoted.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/unquoted.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/unquoted.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/unquoted.js'], env: {}};

	/** code **/
	// unquoted attributes should be ok in non-strict mode
	// https://github.com/isaacs/sax-js/issues/31
	require(__dirname).test
	  ( { xml :
	      "<span class=test hello=world></span>"
	    , expect :
	      [ [ "attribute", { name: "CLASS", value: "test" } ]
	      , [ "attribute", { name: "HELLO", value: "world" } ]
	      , [ "opentag", { name: "SPAN",
	                       attributes: { CLASS: "test", HELLO: "world" },
	                       isSelfClosing: false } ]
	      , [ "closetag", "SPAN" ]
	      ]
	    , strict : false
	    , opt : {}
	    }
	  )
	
	

}, 'sax/test/utf8-split.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/utf8-split.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/utf8-split.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/utf8-split.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/utf8-split.js'], env: {}};

	/** code **/
	var assert = require('assert')
	var saxStream = require('../lib/sax').createStream()
	
	var b = new Buffer('误')
	
	saxStream.on('text', function(text) {
	  assert.equal(text, b.toString())
	})
	
	saxStream.write(new Buffer('<test><a>'))
	saxStream.write(b.slice(0, 1))
	saxStream.write(b.slice(1))
	saxStream.write(new Buffer('</a><b>'))
	saxStream.write(b.slice(0, 2))
	saxStream.write(b.slice(2))
	saxStream.write(new Buffer('</b><c>'))
	saxStream.write(b)
	saxStream.write(new Buffer('</c>'))
	saxStream.write(Buffer.concat([new Buffer('<d>'), b.slice(0, 1)]))
	saxStream.end(Buffer.concat([b.slice(1), new Buffer('</d></test>')]))
	
	var saxStream2 = require('../lib/sax').createStream()
	
	saxStream2.on('text', function(text) {
	  assert.equal(text, '�')
	});
	
	saxStream2.write(new Buffer('<e>'));
	saxStream2.write(new Buffer([0xC0]));
	saxStream2.write(new Buffer('</e>'));
	saxStream2.write(Buffer.concat([new Buffer('<f>'), b.slice(0,1)]));
	saxStream2.end();
	

}, 'sax/test/xmlns-issue-41.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/xmlns-issue-41.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/xmlns-issue-41.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/xmlns-issue-41.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/xmlns-issue-41.js'], env: {}};

	/** code **/
	var t = require(__dirname)
	
	  , xmls = // should be the same both ways.
	    [ "<parent xmlns:a='http://ATTRIBUTE' a:attr='value' />"
	    , "<parent a:attr='value' xmlns:a='http://ATTRIBUTE' />" ]
	
	  , ex1 =
	    [ [ "opennamespace"
	      , { prefix: "a"
	        , uri: "http://ATTRIBUTE"
	        }
	      ]
	    , [ "attribute"
	      , { name: "xmlns:a"
	        , value: "http://ATTRIBUTE"
	        , prefix: "xmlns"
	        , local: "a"
	        , uri: "http://www.w3.org/2000/xmlns/"
	        }
	      ]
	    , [ "attribute"
	      , { name: "a:attr"
	        , local: "attr"
	        , prefix: "a"
	        , uri: "http://ATTRIBUTE"
	        , value: "value"
	        }
	      ]
	    , [ "opentag"
	      , { name: "parent"
	        , uri: ""
	        , prefix: ""
	        , local: "parent"
	        , attributes:
	          { "a:attr":
	            { name: "a:attr"
	            , local: "attr"
	            , prefix: "a"
	            , uri: "http://ATTRIBUTE"
	            , value: "value"
	            }
	          , "xmlns:a":
	            { name: "xmlns:a"
	            , local: "a"
	            , prefix: "xmlns"
	            , uri: "http://www.w3.org/2000/xmlns/"
	            , value: "http://ATTRIBUTE"
	            }
	          }
	        , ns: {"a": "http://ATTRIBUTE"}
	        , isSelfClosing: true
	        }
	      ]
	    , ["closetag", "parent"]
	    , ["closenamespace", { prefix: "a", uri: "http://ATTRIBUTE" }]
	    ]
	
	  // swap the order of elements 2 and 1
	  , ex2 = [ex1[0], ex1[2], ex1[1]].concat(ex1.slice(3))
	  , expected = [ex1, ex2]
	
	xmls.forEach(function (x, i) {
	  t.test({ xml: x
	         , expect: expected[i]
	         , strict: true
	         , opt: { xmlns: true }
	         })
	})
	

}, 'sax/test/xmlns-rebinding.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/xmlns-rebinding.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/xmlns-rebinding.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/xmlns-rebinding.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/xmlns-rebinding.js'], env: {}};

	/** code **/
	
	require(__dirname).test
	  ( { xml :
	      "<root xmlns:x='x1' xmlns:y='y1' x:a='x1' y:a='y1'>"+
	        "<rebind xmlns:x='x2'>"+
	          "<check x:a='x2' y:a='y1'/>"+
	        "</rebind>"+
	        "<check x:a='x1' y:a='y1'/>"+
	      "</root>"
	
	    , expect :
	      [ [ "opennamespace", { prefix: "x", uri: "x1" } ]
	      , [ "opennamespace", { prefix: "y", uri: "y1" } ]
	      , [ "attribute", { name: "xmlns:x", value: "x1", uri: "http://www.w3.org/2000/xmlns/", prefix: "xmlns", local: "x" } ]
	      , [ "attribute", { name: "xmlns:y", value: "y1", uri: "http://www.w3.org/2000/xmlns/", prefix: "xmlns", local: "y" } ]
	      , [ "attribute", { name: "x:a", value: "x1", uri: "x1", prefix: "x", local: "a" } ]
	      , [ "attribute", { name: "y:a", value: "y1", uri: "y1", prefix: "y", local: "a" } ]
	      , [ "opentag", { name: "root", uri: "", prefix: "", local: "root",
	            attributes: { "xmlns:x": { name: "xmlns:x", value: "x1", uri: "http://www.w3.org/2000/xmlns/", prefix: "xmlns", local: "x" }
	                        , "xmlns:y": { name: "xmlns:y", value: "y1", uri: "http://www.w3.org/2000/xmlns/", prefix: "xmlns", local: "y" }
	                        , "x:a": { name: "x:a", value: "x1", uri: "x1", prefix: "x", local: "a" }
	                        , "y:a": { name: "y:a", value: "y1", uri: "y1", prefix: "y", local: "a" } },
	            ns: { x: 'x1', y: 'y1' },
	            isSelfClosing: false } ]
	
	      , [ "opennamespace", { prefix: "x", uri: "x2" } ]
	      , [ "attribute", { name: "xmlns:x", value: "x2", uri: "http://www.w3.org/2000/xmlns/", prefix: "xmlns", local: "x" } ]
	      , [ "opentag", { name: "rebind", uri: "", prefix: "", local: "rebind",
	            attributes: { "xmlns:x": { name: "xmlns:x", value: "x2", uri: "http://www.w3.org/2000/xmlns/", prefix: "xmlns", local: "x" } },
	            ns: { x: 'x2' },
	            isSelfClosing: false } ]
	
	      , [ "attribute", { name: "x:a", value: "x2", uri: "x2", prefix: "x", local: "a" } ]
	      , [ "attribute", { name: "y:a", value: "y1", uri: "y1", prefix: "y", local: "a" } ]
	      , [ "opentag", { name: "check", uri: "", prefix: "", local: "check",
	            attributes: { "x:a": { name: "x:a", value: "x2", uri: "x2", prefix: "x", local: "a" }
	                        , "y:a": { name: "y:a", value: "y1", uri: "y1", prefix: "y", local: "a" } },
	            ns: { x: 'x2' },
	            isSelfClosing: true } ]
	
	      , [ "closetag", "check" ]
	
	      , [ "closetag", "rebind" ]
	      , [ "closenamespace", { prefix: "x", uri: "x2" } ]
	
	      , [ "attribute", { name: "x:a", value: "x1", uri: "x1", prefix: "x", local: "a" } ]
	      , [ "attribute", { name: "y:a", value: "y1", uri: "y1", prefix: "y", local: "a" } ]
	      , [ "opentag", { name: "check", uri: "", prefix: "", local: "check",
	            attributes: { "x:a": { name: "x:a", value: "x1", uri: "x1", prefix: "x", local: "a" }
	                        , "y:a": { name: "y:a", value: "y1", uri: "y1", prefix: "y", local: "a" } },
	            ns: { x: 'x1', y: 'y1' },
	            isSelfClosing: true } ]
	      , [ "closetag", "check" ]
	
	      , [ "closetag", "root" ]
	      , [ "closenamespace", { prefix: "x", uri: "x1" } ]
	      , [ "closenamespace", { prefix: "y", uri: "y1" } ]
	      ]
	    , strict : true
	    , opt : { xmlns: true }
	    }
	  )
	
	

}, 'sax/test/xmlns-strict.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/xmlns-strict.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/xmlns-strict.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/xmlns-strict.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/xmlns-strict.js'], env: {}};

	/** code **/
	
	require(__dirname).test
	  ( { xml :
	      "<root>"+
	        "<plain attr='normal'/>"+
	        "<ns1 xmlns='uri:default'>"+
	          "<plain attr='normal'/>"+
	        "</ns1>"+
	        "<ns2 xmlns:a='uri:nsa'>"+
	          "<plain attr='normal'/>"+
	          "<a:ns a:attr='namespaced'/>"+
	        "</ns2>"+
	      "</root>"
	
	    , expect :
	      [ [ "opentag", { name: "root", prefix: "", local: "root", uri: "",
	            attributes: {}, ns: {}, isSelfClosing: false } ]
	
	      , [ "attribute", { name: "attr", value: "normal", prefix: "", local: "attr", uri: "" } ]
	      , [ "opentag", { name: "plain", prefix: "", local: "plain", uri: "",
	            attributes: { "attr": { name: "attr", value: "normal", uri: "", prefix: "", local: "attr", uri: "" } },
	            ns: {}, isSelfClosing: true } ]
	      , [ "closetag", "plain" ]
	
	      , [ "opennamespace", { prefix: "", uri: "uri:default" } ]
	
	      , [ "attribute", { name: "xmlns", value: "uri:default", prefix: "xmlns", local: "", uri: "http://www.w3.org/2000/xmlns/" } ]
	      , [ "opentag", { name: "ns1", prefix: "", local: "ns1", uri: "uri:default",
	            attributes: { "xmlns": { name: "xmlns", value: "uri:default", prefix: "xmlns", local: "", uri: "http://www.w3.org/2000/xmlns/" } },
	            ns: { "": "uri:default" }, isSelfClosing: false } ]
	
	      , [ "attribute", { name: "attr", value: "normal", prefix: "", local: "attr", uri: "" } ]
	      , [ "opentag", { name: "plain", prefix: "", local: "plain", uri: "uri:default", ns: { '': 'uri:default' },
	            attributes: { "attr": { name: "attr", value: "normal", prefix: "", local: "attr", uri: "" } },
	            isSelfClosing: true } ]
	      , [ "closetag", "plain" ]
	
	      , [ "closetag", "ns1" ]
	
	      , [ "closenamespace", { prefix: "", uri: "uri:default" } ]
	
	      , [ "opennamespace", { prefix: "a", uri: "uri:nsa" } ]
	
	      , [ "attribute", { name: "xmlns:a", value: "uri:nsa", prefix: "xmlns", local: "a", uri: "http://www.w3.org/2000/xmlns/" } ]
	
	      , [ "opentag", { name: "ns2", prefix: "", local: "ns2", uri: "",
	            attributes: { "xmlns:a": { name: "xmlns:a", value: "uri:nsa", prefix: "xmlns", local: "a", uri: "http://www.w3.org/2000/xmlns/" } },
	            ns: { a: "uri:nsa" }, isSelfClosing: false } ]
	
	      , [ "attribute", { name: "attr", value: "normal", prefix: "", local: "attr", uri: "" } ]
	      , [ "opentag", { name: "plain", prefix: "", local: "plain", uri: "",
	            attributes: { "attr": { name: "attr", value: "normal", prefix: "", local: "attr", uri: "" } },
	            ns: { a: 'uri:nsa' },
	            isSelfClosing: true } ]
	      , [ "closetag", "plain" ]
	
	      , [ "attribute", { name: "a:attr", value: "namespaced", prefix: "a", local: "attr", uri: "uri:nsa" } ]
	      , [ "opentag", { name: "a:ns", prefix: "a", local: "ns", uri: "uri:nsa",
	            attributes: { "a:attr": { name: "a:attr", value: "namespaced", prefix: "a", local: "attr", uri: "uri:nsa" } },
	            ns: { a: 'uri:nsa' },
	            isSelfClosing: true } ]
	      , [ "closetag", "a:ns" ]
	
	      , [ "closetag", "ns2" ]
	
	      , [ "closenamespace", { prefix: "a", uri: "uri:nsa" } ]
	
	      , [ "closetag", "root" ]
	      ]
	    , strict : true
	    , opt : { xmlns: true }
	    }
	  )
	
	

}, 'sax/test/xmlns-unbound-element.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/xmlns-unbound-element.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/xmlns-unbound-element.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/xmlns-unbound-element.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/xmlns-unbound-element.js'], env: {}};

	/** code **/
	require(__dirname).test(
	  { strict : true
	  , opt : { xmlns: true }
	  , expect :
	    [ [ "error", "Unbound namespace prefix: \"unbound:root\"\nLine: 0\nColumn: 15\nChar: >"]
	    , [ "opentag", { name: "unbound:root", uri: "unbound", prefix: "unbound", local: "root"
	        , attributes: {}, ns: {}, isSelfClosing: true } ]
	    , [ "closetag", "unbound:root" ]
	    ]
	  }
	).write("<unbound:root/>");
	
	require(__dirname).test(
	  { strict : true
	  , opt : { xmlns: true }
	  , expect :
	    [ [ "opennamespace", { prefix: "unbound", uri: "someuri" } ]
	    , [ "attribute", { name: 'xmlns:unbound', value: 'someuri'
	      , prefix: 'xmlns', local: 'unbound'
	      , uri: 'http://www.w3.org/2000/xmlns/' } ]
	    , [ "opentag", { name: "unbound:root", uri: "someuri", prefix: "unbound", local: "root"
	          , attributes: { 'xmlns:unbound': {
	              name: 'xmlns:unbound'
	            , value: 'someuri'
	            , prefix: 'xmlns'
	            , local: 'unbound'
	            , uri: 'http://www.w3.org/2000/xmlns/' } }
	      , ns: { "unbound": "someuri" }, isSelfClosing: true } ]
	    , [ "closetag", "unbound:root" ]
	    , [ "closenamespace", { prefix: 'unbound', uri: 'someuri' }]
	    ]
	  }
	).write("<unbound:root xmlns:unbound=\"someuri\"/>");
	

}, 'sax/test/xmlns-unbound.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/xmlns-unbound.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/xmlns-unbound.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/xmlns-unbound.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/xmlns-unbound.js'], env: {}};

	/** code **/
	
	require(__dirname).test(
	  { strict : true
	  , opt : { xmlns: true }
	  , expect :
	    [ ["error", "Unbound namespace prefix: \"unbound\"\nLine: 0\nColumn: 28\nChar: >"]
	
	    , [ "attribute", { name: "unbound:attr", value: "value", uri: "unbound", prefix: "unbound", local: "attr" } ]
	    , [ "opentag", { name: "root", uri: "", prefix: "", local: "root",
	          attributes: { "unbound:attr": { name: "unbound:attr", value: "value", uri: "unbound", prefix: "unbound", local: "attr" } },
	          ns: {}, isSelfClosing: true } ]
	    , [ "closetag", "root" ]
	    ]
	  }
	).write("<root unbound:attr='value'/>")
	

}, 'sax/test/xmlns-xml-default-ns.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/xmlns-xml-default-ns.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/xmlns-xml-default-ns.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/xmlns-xml-default-ns.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/xmlns-xml-default-ns.js'], env: {}};

	/** code **/
	var xmlns_attr =
	{
	    name: "xmlns", value: "http://foo", prefix: "xmlns",
	    local: "", uri : "http://www.w3.org/2000/xmlns/"
	};
	
	var attr_attr =
	{
	    name: "attr", value: "bar", prefix: "",
	    local : "attr",  uri : ""
	};
	
	
	require(__dirname).test
	  ( { xml :
	      "<elm xmlns='http://foo' attr='bar'/>"
	    , expect :
	      [ [ "opennamespace", { prefix: "", uri: "http://foo" } ]
	      , [ "attribute", xmlns_attr ]
	      , [ "attribute", attr_attr ]
	      , [ "opentag", { name: "elm", prefix: "", local: "elm", uri : "http://foo",
	                       ns : { "" : "http://foo" },
	                       attributes: { xmlns: xmlns_attr, attr: attr_attr },
	                       isSelfClosing: true } ]
	      , [ "closetag", "elm" ]
	      , [ "closenamespace", { prefix: "", uri: "http://foo"} ]
	      ]
	    , strict : true
	    , opt : {xmlns: true}
	    }
	  )
	

}, 'sax/test/xmlns-xml-default-prefix-attribute.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/xmlns-xml-default-prefix-attribute.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/xmlns-xml-default-prefix-attribute.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/xmlns-xml-default-prefix-attribute.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/xmlns-xml-default-prefix-attribute.js'], env: {}};

	/** code **/
	require(__dirname).test(
	  { xml : "<root xml:lang='en'/>"
	  , expect :
	    [ [ "attribute"
	      , { name: "xml:lang"
	        , local: "lang"
	        , prefix: "xml"
	        , uri: "http://www.w3.org/XML/1998/namespace"
	        , value: "en"
	        }
	      ]
	    , [ "opentag"
	      , { name: "root"
	        , uri: ""
	        , prefix: ""
	        , local: "root"
	        , attributes:
	          { "xml:lang":
	            { name: "xml:lang"
	            , local: "lang"
	            , prefix: "xml"
	            , uri: "http://www.w3.org/XML/1998/namespace"
	            , value: "en"
	            }
	          }
	        , ns: {}
	        , isSelfClosing: true
	        }
	      ]
	    , ["closetag", "root"]
	    ]
	  , strict : true
	  , opt : { xmlns: true }
	  }
	)
	
	

}, 'sax/test/xmlns-xml-default-prefix.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/xmlns-xml-default-prefix.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/xmlns-xml-default-prefix.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/xmlns-xml-default-prefix.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/xmlns-xml-default-prefix.js'], env: {}};

	/** code **/
	require(__dirname).test(
	  { xml : "<xml:root/>"
	  , expect :
	    [
	      [ "opentag"
	      , { name: "xml:root"
	        , uri: "http://www.w3.org/XML/1998/namespace"
	        , prefix: "xml"
	        , local: "root"
	        , attributes: {}
	        , ns: {}
	        , isSelfClosing: true
	        }
	      ]
	    , ["closetag", "xml:root"]
	    ]
	  , strict : true
	  , opt : { xmlns: true }
	  }
	)
	
	

}, 'sax/test/xmlns-xml-default-redefine.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'sax/test/xmlns-xml-default-redefine.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'sax/test/xmlns-xml-default-redefine.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'sax/test/xmlns-xml-default-redefine.js';
	var __dirname = 'sax/test';
	var process = {cwd: function() {return '/';}, argv: ['node', 'sax/test/xmlns-xml-default-redefine.js'], env: {}};

	/** code **/
	require(__dirname).test(
	  { xml : "<xml:root xmlns:xml='ERROR'/>"
	  , expect :
	    [ ["error"
	      , "xml: prefix must be bound to http://www.w3.org/XML/1998/namespace\n"
	                        + "Actual: ERROR\n"
	      + "Line: 0\nColumn: 27\nChar: '"
	      ]
	    , [ "attribute"
	      , { name: "xmlns:xml"
	        , local: "xml"
	        , prefix: "xmlns"
	        , uri: "http://www.w3.org/2000/xmlns/"
	        , value: "ERROR"
	        }
	      ]
	    , [ "opentag"
	      , { name: "xml:root"
	        , uri: "http://www.w3.org/XML/1998/namespace"
	        , prefix: "xml"
	        , local: "root"
	        , attributes:
	          { "xmlns:xml":
	            { name: "xmlns:xml"
	            , local: "xml"
	            , prefix: "xmlns"
	            , uri: "http://www.w3.org/2000/xmlns/"
	            , value: "ERROR"
	            }
	          }
	        , ns: {}
	        , isSelfClosing: true
	        }
	      ]
	    , ["closetag", "xml:root"]
	    ]
	  , strict : true
	  , opt : { xmlns: true }
	  }
	)
	
	

}, 'underscore/package.json': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'underscore/package.json');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'underscore/package.json';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'underscore/package.json';
	var __dirname = 'underscore';
	var process = {cwd: function() {return '/';}, argv: ['node', 'underscore/package.json'], env: {}};

	/** code **/
	module.exports = (function() {
	return {
	  "name": "underscore",
	  "description": "JavaScript's functional programming helper library.",
	  "homepage": "http://underscorejs.org",
	  "keywords": [
	    "util",
	    "functional",
	    "server",
	    "client",
	    "browser"
	  ],
	  "author": {
	    "name": "Jeremy Ashkenas",
	    "email": "jeremy@documentcloud.org"
	  },
	  "repository": {
	    "type": "git",
	    "url": "git://github.com/jashkenas/underscore.git"
	  },
	  "main": "underscore.js",
	  "version": "1.5.2",
	  "devDependencies": {
	    "phantomjs": "1.9.0-1"
	  },
	  "scripts": {
	    "test": "phantomjs test/vendor/runner.js test/index.html?noglobals=true"
	  },
	  "licenses": [
	    {
	      "type": "MIT",
	      "url": "https://raw.github.com/jashkenas/underscore/master/LICENSE"
	    }
	  ],
	  "files": [
	    "underscore.js",
	    "underscore-min.js",
	    "LICENSE"
	  ],
	  "readme": "                       __\n                      /\\ \\                                                         __\n     __  __    ___    \\_\\ \\     __   _ __   ____    ___    ___   _ __    __       /\\_\\    ____\n    /\\ \\/\\ \\ /' _ `\\  /'_  \\  /'__`\\/\\  __\\/ ,__\\  / ___\\ / __`\\/\\  __\\/'__`\\     \\/\\ \\  /',__\\\n    \\ \\ \\_\\ \\/\\ \\/\\ \\/\\ \\ \\ \\/\\  __/\\ \\ \\//\\__, `\\/\\ \\__//\\ \\ \\ \\ \\ \\//\\  __/  __  \\ \\ \\/\\__, `\\\n     \\ \\____/\\ \\_\\ \\_\\ \\___,_\\ \\____\\\\ \\_\\\\/\\____/\\ \\____\\ \\____/\\ \\_\\\\ \\____\\/\\_\\ _\\ \\ \\/\\____/\n      \\/___/  \\/_/\\/_/\\/__,_ /\\/____/ \\/_/ \\/___/  \\/____/\\/___/  \\/_/ \\/____/\\/_//\\ \\_\\ \\/___/\n                                                                                  \\ \\____/\n                                                                                   \\/___/\n\nUnderscore.js is a utility-belt library for JavaScript that provides\nsupport for the usual functional suspects (each, map, reduce, filter...)\nwithout extending any core JavaScript objects.\n\nFor Docs, License, Tests, and pre-packed downloads, see:\nhttp://underscorejs.org\n\nUnderscore is an open-sourced component of DocumentCloud:\nhttps://github.com/documentcloud\n\nMany thanks to our contributors:\nhttps://github.com/jashkenas/underscore/contributors\n",
	  "readmeFilename": "README.md",
	  "bugs": {
	    "url": "https://github.com/jashkenas/underscore/issues"
	  },
	  "_id": "underscore@1.5.2",
	  "dist": {
	    "shasum": "07f3f49f2970cf72ab975f4504333a51584d1dbe"
	  },
	  "_from": "underscore@>=1.5.x",
	  "_resolved": "https://registry.npmjs.org/underscore/-/underscore-1.5.2.tgz"
	}
	
	}).call(this);
	

}, 'underscore/underscore-min.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'underscore/underscore-min.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'underscore/underscore-min.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'underscore/underscore-min.js';
	var __dirname = 'underscore';
	var process = {cwd: function() {return '/';}, argv: ['node', 'underscore/underscore-min.js'], env: {}};

	/** code **/
	//     Underscore.js 1.5.2
	//     http://underscorejs.org
	//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Underscore may be freely distributed under the MIT license.
	(function(){var n=this,t=n._,r={},e=Array.prototype,u=Object.prototype,i=Function.prototype,a=e.push,o=e.slice,c=e.concat,l=u.toString,f=u.hasOwnProperty,s=e.forEach,p=e.map,h=e.reduce,v=e.reduceRight,g=e.filter,d=e.every,m=e.some,y=e.indexOf,b=e.lastIndexOf,x=Array.isArray,w=Object.keys,_=i.bind,j=function(n){return n instanceof j?n:this instanceof j?(this._wrapped=n,void 0):new j(n)};"undefined"!=typeof exports?("undefined"!=typeof module&&module.exports&&(exports=module.exports=j),exports._=j):n._=j,j.VERSION="1.5.2";var A=j.each=j.forEach=function(n,t,e){if(null!=n)if(s&&n.forEach===s)n.forEach(t,e);else if(n.length===+n.length){for(var u=0,i=n.length;i>u;u++)if(t.call(e,n[u],u,n)===r)return}else for(var a=j.keys(n),u=0,i=a.length;i>u;u++)if(t.call(e,n[a[u]],a[u],n)===r)return};j.map=j.collect=function(n,t,r){var e=[];return null==n?e:p&&n.map===p?n.map(t,r):(A(n,function(n,u,i){e.push(t.call(r,n,u,i))}),e)};var E="Reduce of empty array with no initial value";j.reduce=j.foldl=j.inject=function(n,t,r,e){var u=arguments.length>2;if(null==n&&(n=[]),h&&n.reduce===h)return e&&(t=j.bind(t,e)),u?n.reduce(t,r):n.reduce(t);if(A(n,function(n,i,a){u?r=t.call(e,r,n,i,a):(r=n,u=!0)}),!u)throw new TypeError(E);return r},j.reduceRight=j.foldr=function(n,t,r,e){var u=arguments.length>2;if(null==n&&(n=[]),v&&n.reduceRight===v)return e&&(t=j.bind(t,e)),u?n.reduceRight(t,r):n.reduceRight(t);var i=n.length;if(i!==+i){var a=j.keys(n);i=a.length}if(A(n,function(o,c,l){c=a?a[--i]:--i,u?r=t.call(e,r,n[c],c,l):(r=n[c],u=!0)}),!u)throw new TypeError(E);return r},j.find=j.detect=function(n,t,r){var e;return O(n,function(n,u,i){return t.call(r,n,u,i)?(e=n,!0):void 0}),e},j.filter=j.select=function(n,t,r){var e=[];return null==n?e:g&&n.filter===g?n.filter(t,r):(A(n,function(n,u,i){t.call(r,n,u,i)&&e.push(n)}),e)},j.reject=function(n,t,r){return j.filter(n,function(n,e,u){return!t.call(r,n,e,u)},r)},j.every=j.all=function(n,t,e){t||(t=j.identity);var u=!0;return null==n?u:d&&n.every===d?n.every(t,e):(A(n,function(n,i,a){return(u=u&&t.call(e,n,i,a))?void 0:r}),!!u)};var O=j.some=j.any=function(n,t,e){t||(t=j.identity);var u=!1;return null==n?u:m&&n.some===m?n.some(t,e):(A(n,function(n,i,a){return u||(u=t.call(e,n,i,a))?r:void 0}),!!u)};j.contains=j.include=function(n,t){return null==n?!1:y&&n.indexOf===y?n.indexOf(t)!=-1:O(n,function(n){return n===t})},j.invoke=function(n,t){var r=o.call(arguments,2),e=j.isFunction(t);return j.map(n,function(n){return(e?t:n[t]).apply(n,r)})},j.pluck=function(n,t){return j.map(n,function(n){return n[t]})},j.where=function(n,t,r){return j.isEmpty(t)?r?void 0:[]:j[r?"find":"filter"](n,function(n){for(var r in t)if(t[r]!==n[r])return!1;return!0})},j.findWhere=function(n,t){return j.where(n,t,!0)},j.max=function(n,t,r){if(!t&&j.isArray(n)&&n[0]===+n[0]&&n.length<65535)return Math.max.apply(Math,n);if(!t&&j.isEmpty(n))return-1/0;var e={computed:-1/0,value:-1/0};return A(n,function(n,u,i){var a=t?t.call(r,n,u,i):n;a>e.computed&&(e={value:n,computed:a})}),e.value},j.min=function(n,t,r){if(!t&&j.isArray(n)&&n[0]===+n[0]&&n.length<65535)return Math.min.apply(Math,n);if(!t&&j.isEmpty(n))return 1/0;var e={computed:1/0,value:1/0};return A(n,function(n,u,i){var a=t?t.call(r,n,u,i):n;a<e.computed&&(e={value:n,computed:a})}),e.value},j.shuffle=function(n){var t,r=0,e=[];return A(n,function(n){t=j.random(r++),e[r-1]=e[t],e[t]=n}),e},j.sample=function(n,t,r){return arguments.length<2||r?n[j.random(n.length-1)]:j.shuffle(n).slice(0,Math.max(0,t))};var k=function(n){return j.isFunction(n)?n:function(t){return t[n]}};j.sortBy=function(n,t,r){var e=k(t);return j.pluck(j.map(n,function(n,t,u){return{value:n,index:t,criteria:e.call(r,n,t,u)}}).sort(function(n,t){var r=n.criteria,e=t.criteria;if(r!==e){if(r>e||r===void 0)return 1;if(e>r||e===void 0)return-1}return n.index-t.index}),"value")};var F=function(n){return function(t,r,e){var u={},i=null==r?j.identity:k(r);return A(t,function(r,a){var o=i.call(e,r,a,t);n(u,o,r)}),u}};j.groupBy=F(function(n,t,r){(j.has(n,t)?n[t]:n[t]=[]).push(r)}),j.indexBy=F(function(n,t,r){n[t]=r}),j.countBy=F(function(n,t){j.has(n,t)?n[t]++:n[t]=1}),j.sortedIndex=function(n,t,r,e){r=null==r?j.identity:k(r);for(var u=r.call(e,t),i=0,a=n.length;a>i;){var o=i+a>>>1;r.call(e,n[o])<u?i=o+1:a=o}return i},j.toArray=function(n){return n?j.isArray(n)?o.call(n):n.length===+n.length?j.map(n,j.identity):j.values(n):[]},j.size=function(n){return null==n?0:n.length===+n.length?n.length:j.keys(n).length},j.first=j.head=j.take=function(n,t,r){return null==n?void 0:null==t||r?n[0]:o.call(n,0,t)},j.initial=function(n,t,r){return o.call(n,0,n.length-(null==t||r?1:t))},j.last=function(n,t,r){return null==n?void 0:null==t||r?n[n.length-1]:o.call(n,Math.max(n.length-t,0))},j.rest=j.tail=j.drop=function(n,t,r){return o.call(n,null==t||r?1:t)},j.compact=function(n){return j.filter(n,j.identity)};var M=function(n,t,r){return t&&j.every(n,j.isArray)?c.apply(r,n):(A(n,function(n){j.isArray(n)||j.isArguments(n)?t?a.apply(r,n):M(n,t,r):r.push(n)}),r)};j.flatten=function(n,t){return M(n,t,[])},j.without=function(n){return j.difference(n,o.call(arguments,1))},j.uniq=j.unique=function(n,t,r,e){j.isFunction(t)&&(e=r,r=t,t=!1);var u=r?j.map(n,r,e):n,i=[],a=[];return A(u,function(r,e){(t?e&&a[a.length-1]===r:j.contains(a,r))||(a.push(r),i.push(n[e]))}),i},j.union=function(){return j.uniq(j.flatten(arguments,!0))},j.intersection=function(n){var t=o.call(arguments,1);return j.filter(j.uniq(n),function(n){return j.every(t,function(t){return j.indexOf(t,n)>=0})})},j.difference=function(n){var t=c.apply(e,o.call(arguments,1));return j.filter(n,function(n){return!j.contains(t,n)})},j.zip=function(){for(var n=j.max(j.pluck(arguments,"length").concat(0)),t=new Array(n),r=0;n>r;r++)t[r]=j.pluck(arguments,""+r);return t},j.object=function(n,t){if(null==n)return{};for(var r={},e=0,u=n.length;u>e;e++)t?r[n[e]]=t[e]:r[n[e][0]]=n[e][1];return r},j.indexOf=function(n,t,r){if(null==n)return-1;var e=0,u=n.length;if(r){if("number"!=typeof r)return e=j.sortedIndex(n,t),n[e]===t?e:-1;e=0>r?Math.max(0,u+r):r}if(y&&n.indexOf===y)return n.indexOf(t,r);for(;u>e;e++)if(n[e]===t)return e;return-1},j.lastIndexOf=function(n,t,r){if(null==n)return-1;var e=null!=r;if(b&&n.lastIndexOf===b)return e?n.lastIndexOf(t,r):n.lastIndexOf(t);for(var u=e?r:n.length;u--;)if(n[u]===t)return u;return-1},j.range=function(n,t,r){arguments.length<=1&&(t=n||0,n=0),r=arguments[2]||1;for(var e=Math.max(Math.ceil((t-n)/r),0),u=0,i=new Array(e);e>u;)i[u++]=n,n+=r;return i};var R=function(){};j.bind=function(n,t){var r,e;if(_&&n.bind===_)return _.apply(n,o.call(arguments,1));if(!j.isFunction(n))throw new TypeError;return r=o.call(arguments,2),e=function(){if(!(this instanceof e))return n.apply(t,r.concat(o.call(arguments)));R.prototype=n.prototype;var u=new R;R.prototype=null;var i=n.apply(u,r.concat(o.call(arguments)));return Object(i)===i?i:u}},j.partial=function(n){var t=o.call(arguments,1);return function(){return n.apply(this,t.concat(o.call(arguments)))}},j.bindAll=function(n){var t=o.call(arguments,1);if(0===t.length)throw new Error("bindAll must be passed function names");return A(t,function(t){n[t]=j.bind(n[t],n)}),n},j.memoize=function(n,t){var r={};return t||(t=j.identity),function(){var e=t.apply(this,arguments);return j.has(r,e)?r[e]:r[e]=n.apply(this,arguments)}},j.delay=function(n,t){var r=o.call(arguments,2);return setTimeout(function(){return n.apply(null,r)},t)},j.defer=function(n){return j.delay.apply(j,[n,1].concat(o.call(arguments,1)))},j.throttle=function(n,t,r){var e,u,i,a=null,o=0;r||(r={});var c=function(){o=r.leading===!1?0:new Date,a=null,i=n.apply(e,u)};return function(){var l=new Date;o||r.leading!==!1||(o=l);var f=t-(l-o);return e=this,u=arguments,0>=f?(clearTimeout(a),a=null,o=l,i=n.apply(e,u)):a||r.trailing===!1||(a=setTimeout(c,f)),i}},j.debounce=function(n,t,r){var e,u,i,a,o;return function(){i=this,u=arguments,a=new Date;var c=function(){var l=new Date-a;t>l?e=setTimeout(c,t-l):(e=null,r||(o=n.apply(i,u)))},l=r&&!e;return e||(e=setTimeout(c,t)),l&&(o=n.apply(i,u)),o}},j.once=function(n){var t,r=!1;return function(){return r?t:(r=!0,t=n.apply(this,arguments),n=null,t)}},j.wrap=function(n,t){return function(){var r=[n];return a.apply(r,arguments),t.apply(this,r)}},j.compose=function(){var n=arguments;return function(){for(var t=arguments,r=n.length-1;r>=0;r--)t=[n[r].apply(this,t)];return t[0]}},j.after=function(n,t){return function(){return--n<1?t.apply(this,arguments):void 0}},j.keys=w||function(n){if(n!==Object(n))throw new TypeError("Invalid object");var t=[];for(var r in n)j.has(n,r)&&t.push(r);return t},j.values=function(n){for(var t=j.keys(n),r=t.length,e=new Array(r),u=0;r>u;u++)e[u]=n[t[u]];return e},j.pairs=function(n){for(var t=j.keys(n),r=t.length,e=new Array(r),u=0;r>u;u++)e[u]=[t[u],n[t[u]]];return e},j.invert=function(n){for(var t={},r=j.keys(n),e=0,u=r.length;u>e;e++)t[n[r[e]]]=r[e];return t},j.functions=j.methods=function(n){var t=[];for(var r in n)j.isFunction(n[r])&&t.push(r);return t.sort()},j.extend=function(n){return A(o.call(arguments,1),function(t){if(t)for(var r in t)n[r]=t[r]}),n},j.pick=function(n){var t={},r=c.apply(e,o.call(arguments,1));return A(r,function(r){r in n&&(t[r]=n[r])}),t},j.omit=function(n){var t={},r=c.apply(e,o.call(arguments,1));for(var u in n)j.contains(r,u)||(t[u]=n[u]);return t},j.defaults=function(n){return A(o.call(arguments,1),function(t){if(t)for(var r in t)n[r]===void 0&&(n[r]=t[r])}),n},j.clone=function(n){return j.isObject(n)?j.isArray(n)?n.slice():j.extend({},n):n},j.tap=function(n,t){return t(n),n};var S=function(n,t,r,e){if(n===t)return 0!==n||1/n==1/t;if(null==n||null==t)return n===t;n instanceof j&&(n=n._wrapped),t instanceof j&&(t=t._wrapped);var u=l.call(n);if(u!=l.call(t))return!1;switch(u){case"[object String]":return n==String(t);case"[object Number]":return n!=+n?t!=+t:0==n?1/n==1/t:n==+t;case"[object Date]":case"[object Boolean]":return+n==+t;case"[object RegExp]":return n.source==t.source&&n.global==t.global&&n.multiline==t.multiline&&n.ignoreCase==t.ignoreCase}if("object"!=typeof n||"object"!=typeof t)return!1;for(var i=r.length;i--;)if(r[i]==n)return e[i]==t;var a=n.constructor,o=t.constructor;if(a!==o&&!(j.isFunction(a)&&a instanceof a&&j.isFunction(o)&&o instanceof o))return!1;r.push(n),e.push(t);var c=0,f=!0;if("[object Array]"==u){if(c=n.length,f=c==t.length)for(;c--&&(f=S(n[c],t[c],r,e)););}else{for(var s in n)if(j.has(n,s)&&(c++,!(f=j.has(t,s)&&S(n[s],t[s],r,e))))break;if(f){for(s in t)if(j.has(t,s)&&!c--)break;f=!c}}return r.pop(),e.pop(),f};j.isEqual=function(n,t){return S(n,t,[],[])},j.isEmpty=function(n){if(null==n)return!0;if(j.isArray(n)||j.isString(n))return 0===n.length;for(var t in n)if(j.has(n,t))return!1;return!0},j.isElement=function(n){return!(!n||1!==n.nodeType)},j.isArray=x||function(n){return"[object Array]"==l.call(n)},j.isObject=function(n){return n===Object(n)},A(["Arguments","Function","String","Number","Date","RegExp"],function(n){j["is"+n]=function(t){return l.call(t)=="[object "+n+"]"}}),j.isArguments(arguments)||(j.isArguments=function(n){return!(!n||!j.has(n,"callee"))}),"function"!=typeof/./&&(j.isFunction=function(n){return"function"==typeof n}),j.isFinite=function(n){return isFinite(n)&&!isNaN(parseFloat(n))},j.isNaN=function(n){return j.isNumber(n)&&n!=+n},j.isBoolean=function(n){return n===!0||n===!1||"[object Boolean]"==l.call(n)},j.isNull=function(n){return null===n},j.isUndefined=function(n){return n===void 0},j.has=function(n,t){return f.call(n,t)},j.noConflict=function(){return n._=t,this},j.identity=function(n){return n},j.times=function(n,t,r){for(var e=Array(Math.max(0,n)),u=0;n>u;u++)e[u]=t.call(r,u);return e},j.random=function(n,t){return null==t&&(t=n,n=0),n+Math.floor(Math.random()*(t-n+1))};var I={escape:{"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;"}};I.unescape=j.invert(I.escape);var T={escape:new RegExp("["+j.keys(I.escape).join("")+"]","g"),unescape:new RegExp("("+j.keys(I.unescape).join("|")+")","g")};j.each(["escape","unescape"],function(n){j[n]=function(t){return null==t?"":(""+t).replace(T[n],function(t){return I[n][t]})}}),j.result=function(n,t){if(null==n)return void 0;var r=n[t];return j.isFunction(r)?r.call(n):r},j.mixin=function(n){A(j.functions(n),function(t){var r=j[t]=n[t];j.prototype[t]=function(){var n=[this._wrapped];return a.apply(n,arguments),z.call(this,r.apply(j,n))}})};var N=0;j.uniqueId=function(n){var t=++N+"";return n?n+t:t},j.templateSettings={evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g,escape:/<%-([\s\S]+?)%>/g};var q=/(.)^/,B={"'":"'","\\":"\\","\r":"r","\n":"n","	":"t","\u2028":"u2028","\u2029":"u2029"},D=/\\|'|\r|\n|\t|\u2028|\u2029/g;j.template=function(n,t,r){var e;r=j.defaults({},r,j.templateSettings);var u=new RegExp([(r.escape||q).source,(r.interpolate||q).source,(r.evaluate||q).source].join("|")+"|$","g"),i=0,a="__p+='";n.replace(u,function(t,r,e,u,o){return a+=n.slice(i,o).replace(D,function(n){return"\\"+B[n]}),r&&(a+="'+\n((__t=("+r+"))==null?'':_.escape(__t))+\n'"),e&&(a+="'+\n((__t=("+e+"))==null?'':__t)+\n'"),u&&(a+="';\n"+u+"\n__p+='"),i=o+t.length,t}),a+="';\n",r.variable||(a="with(obj||{}){\n"+a+"}\n"),a="var __t,__p='',__j=Array.prototype.join,"+"print=function(){__p+=__j.call(arguments,'');};\n"+a+"return __p;\n";try{e=new Function(r.variable||"obj","_",a)}catch(o){throw o.source=a,o}if(t)return e(t,j);var c=function(n){return e.call(this,n,j)};return c.source="function("+(r.variable||"obj")+"){\n"+a+"}",c},j.chain=function(n){return j(n).chain()};var z=function(n){return this._chain?j(n).chain():n};j.mixin(j),A(["pop","push","reverse","shift","sort","splice","unshift"],function(n){var t=e[n];j.prototype[n]=function(){var r=this._wrapped;return t.apply(r,arguments),"shift"!=n&&"splice"!=n||0!==r.length||delete r[0],z.call(this,r)}}),A(["concat","join","slice"],function(n){var t=e[n];j.prototype[n]=function(){return z.call(this,t.apply(this._wrapped,arguments))}}),j.extend(j.prototype,{chain:function(){return this._chain=!0,this},value:function(){return this._wrapped}})}).call(this);
	//# sourceMappingURL=underscore-min.map

}, 'xmlbuilder/package.json': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'xmlbuilder/package.json');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'xmlbuilder/package.json';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'xmlbuilder/package.json';
	var __dirname = 'xmlbuilder';
	var process = {cwd: function() {return '/';}, argv: ['node', 'xmlbuilder/package.json'], env: {}};

	/** code **/
	module.exports = (function() {
	return {
	  "name": "xmlbuilder",
	  "version": "1.0.2",
	  "keywords": [
	    "xml",
	    "xmlbuilder"
	  ],
	  "homepage": "http://github.com/oozcitak/xmlbuilder-js",
	  "description": "An XML builder for node.js",
	  "author": {
	    "name": "Ozgur Ozcitak",
	    "email": "oozcitak@gmail.com"
	  },
	  "licenses": [
	    {
	      "type": "MIT",
	      "url": "http://opensource.org/licenses/mit-license.php"
	    }
	  ],
	  "repository": {
	    "type": "git",
	    "url": "git://github.com/oozcitak/xmlbuilder-js.git"
	  },
	  "bugs": {
	    "url": "http://github.com/oozcitak/xmlbuilder-js/issues"
	  },
	  "main": "./lib/index",
	  "engines": {
	    "node": ">=0.2.0"
	  },
	  "dependencies": {
	    "underscore": ">=1.5.x"
	  },
	  "devDependencies": {
	    "coffee-script": ">=1.1.x",
	    "vows": ">=0.7.x"
	  },
	  "scripts": {
	    "prepublish": "coffee -co lib/ src/*.coffee",
	    "postpublish": "rm -rf lib",
	    "test": "vows test/*"
	  },
	  "readme": "# xmlbuilder-js\n\nAn XMLBuilder for [node.js](http://nodejs.org/) similar to \n[java-xmlbuilder](http://code.google.com/p/java-xmlbuilder/).\n\n[![Build Status](https://secure.travis-ci.org/oozcitak/xmlbuilder-js.png)](http://travis-ci.org/oozcitak/xmlbuilder-js)\n\n### Installation:\n\n``` sh\nnpm install xmlbuilder\n```\n\n### Usage:\n\n``` js\nvar builder = require('xmlbuilder');\nvar xml = builder.create('root')\n  .ele('xmlbuilder', {'for': 'node-js'})\n    .ele('repo', {'type': 'git'}, 'git://github.com/oozcitak/xmlbuilder-js.git')\n  .end({ pretty: true});\n    \nconsole.log(xml);\n```\n\nwill result in:\n\n``` xml\n<?xml version=\"1.0\"?>\n<root>\n  <xmlbuilder for=\"node-js\">\n    <repo type=\"git\">git://github.com/oozcitak/xmlbuilder-js.git</repo>\n  </xmlbuilder>\n</root>\n```\n\nIf you need to do some processing:\n\n``` js\nvar root = builder.create('squares');\nroot.com('f(x) = x^2');\nfor(var i = 1; i <= 5; i++)\n{\n  var item = root.ele('data');\n  item.att('x', i);\n  item.att('y', i * i);\n}\n```\n\nThis will result in:\n\n``` xml\n<?xml version=\"1.0\"?>\n<squares>\n  <!-- f(x) = x^2 -->\n  <data x=\"1\" y=\"1\"/>\n  <data x=\"2\" y=\"4\"/>\n  <data x=\"3\" y=\"9\"/>\n  <data x=\"4\" y=\"16\"/>\n  <data x=\"5\" y=\"25\"/>\n</squares>\n```\n\nSee the [Usage](https://github.com/oozcitak/xmlbuilder-js/wiki/Usage) page in the wiki for more detailed instructions.\n\n### License:\n\n`xmlbuilder-js` is [MIT Licensed](http://opensource.org/licenses/mit-license.php).\n",
	  "readmeFilename": "README.md",
	  "_id": "xmlbuilder@1.0.2",
	  "dist": {
	    "shasum": "8e83f70c6a014cf7eea75af5ae926f3148b2043a"
	  },
	  "_from": "xmlbuilder@>=0.4.2",
	  "_resolved": "https://registry.npmjs.org/xmlbuilder/-/xmlbuilder-1.0.2.tgz"
	}
	
	}).call(this);
	

}, 'xml2js/package.json': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'xml2js/package.json');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'xml2js/package.json';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'xml2js/package.json';
	var __dirname = 'xml2js';
	var process = {cwd: function() {return '/';}, argv: ['node', 'xml2js/package.json'], env: {}};

	/** code **/
	module.exports = (function() {
	return {
	  "name": "xml2js",
	  "description": "Simple XML to JavaScript object converter.",
	  "keywords": [
	    "xml",
	    "json"
	  ],
	  "homepage": "https://github.com/Leonidas-from-XIV/node-xml2js",
	  "version": "0.4.0",
	  "author": {
	    "name": "Marek Kubica",
	    "email": "marek@xivilization.net",
	    "url": "http://xivilization.net"
	  },
	  "contributors": [
	    {
	      "name": "maqr",
	      "email": "maqr.lollerskates@gmail.com",
	      "url": "https://github.com/maqr"
	    },
	    {
	      "name": "Ben Weaver",
	      "url": "http://benweaver.com/"
	    },
	    {
	      "name": "Jae Kwon",
	      "url": "https://github.com/jaekwon"
	    },
	    {
	      "name": "Jim Robert"
	    },
	    {
	      "name": "Ștefan Rusu",
	      "url": "http://www.saltwaterc.eu/"
	    },
	    {
	      "name": "Carter Cole",
	      "email": "carter.cole@cartercole.com",
	      "url": "http://cartercole.com/"
	    },
	    {
	      "name": "Kurt Raschke",
	      "email": "kurt@kurtraschke.com",
	      "url": "http://www.kurtraschke.com/"
	    },
	    {
	      "name": "Contra",
	      "email": "contra@australia.edu",
	      "url": "https://github.com/Contra"
	    },
	    {
	      "name": "Marcelo Diniz",
	      "email": "marudiniz@gmail.com",
	      "url": "https://github.com/mdiniz"
	    },
	    {
	      "name": "Michael Hart",
	      "url": "https://github.com/mhart"
	    },
	    {
	      "name": "Zachary Scott",
	      "email": "zachary@zacharyscott.net",
	      "url": "http://zacharyscott.net/"
	    },
	    {
	      "name": "Raoul Millais",
	      "url": "https://github.com/raoulmillais"
	    },
	    {
	      "name": "Salsita Software",
	      "url": "http://www.salsitasoft.com/"
	    },
	    {
	      "name": "Mike Schilling",
	      "email": "mike@emotive.com",
	      "url": "http://www.emotive.com/"
	    },
	    {
	      "name": "Jackson Tian",
	      "email": "shyvo1987@gmail.com",
	      "url": "http://weibo.com/shyvo"
	    },
	    {
	      "name": "Mikhail Zyatin",
	      "email": "mikhail.zyatin@gmail.com",
	      "url": "https://github.com/Sitin"
	    },
	    {
	      "name": "Chris Tavares",
	      "email": "ctavares@microsoft.com",
	      "url": "https://github.com/christav"
	    },
	    {
	      "name": "Frank Xu",
	      "email": "yyfrankyy@gmail.com",
	      "url": "http://f2e.us/"
	    },
	    {
	      "name": "Guido D'Albore",
	      "email": "guido@bitstorm.it",
	      "url": "http://www.bitstorm.it/"
	    },
	    {
	      "name": "Jack Senechal",
	      "url": "http://jacksenechal.com/"
	    },
	    {
	      "name": "Matthias Hölzl",
	      "email": "tc@xantira.com",
	      "url": "https://github.com/hoelzl"
	    }
	  ],
	  "main": "./lib/xml2js",
	  "directories": {
	    "lib": "./lib"
	  },
	  "scripts": {
	    "test": "zap"
	  },
	  "repository": {
	    "type": "git",
	    "url": "https://github.com/Leonidas-from-XIV/node-xml2js.git"
	  },
	  "dependencies": {
	    "sax": "0.5.x",
	    "xmlbuilder": ">=0.4.2"
	  },
	  "devDependencies": {
	    "coffee-script": ">=1.6.3",
	    "zap": ">=0.2.5",
	    "docco": ">=0.6.2",
	    "diff": ">=1.0.7"
	  },
	  "licenses": [
	    {
	      "type": "MIT",
	      "url": "https://raw.github.com/Leonidas-from-XIV/node-xml2js/master/LICENSE"
	    }
	  ],
	  "readme": "node-xml2js\n===========\n\nEver had the urge to parse XML? And wanted to access the data in some sane,\neasy way? Don't want to compile a C parser, for whatever reason? Then xml2js is\nwhat you're looking for!\n\nDescription\n===========\n\nSimple XML to JavaScript object converter. It supports bi-directional conversion.\nUses [sax-js](https://github.com/isaacs/sax-js/) and\n[xmlbuilder-js](https://github.com/oozcitak/xmlbuilder-js/).\n\nNote: If you're looking for a full DOM parser, you probably want\n[JSDom](https://github.com/tmpvar/jsdom).\n\nInstallation\n============\n\nSimplest way to install `xml2js` is to use [npm](http://npmjs.org), just `npm\ninstall xml2js` which will download xml2js and all dependencies.\n\nUsage\n=====\n\nNo extensive tutorials required because you are a smart developer! The task of\nparsing XML should be an easy one, so let's make it so! Here's some examples.\n\nShoot-and-forget usage\n----------------------\n\nYou want to parse XML as simple and easy as possible? It's dangerous to go\nalone, take this:\n\n```javascript\nvar parseString = require('xml2js').parseString;\nvar xml = \"<root>Hello xml2js!</root>\"\nparseString(xml, function (err, result) {\n    console.dir(result);\n});\n```\n\nCan't get easier than this, right? This works starting with `xml2js` 0.2.3.\nWith CoffeeScript it looks like this:\n\n```coffeescript\n{parseString} = require 'xml2js'\nxml = \"<root>Hello xml2js!</root>\"\nparseString xml, (err, result) ->\n    console.dir result\n```\n\nIf you need some special options, fear not, `xml2js` supports a number of\noptions (see below), you can specify these as second argument:\n\n```javascript\nparseString(xml, {trim: true}, function (err, result) {\n});\n```\n\nSimple as pie usage\n-------------------\n\nThat's right, if you have been using xml-simple or a home-grown\nwrapper, this was added in 0.1.11 just for you:\n\n```javascript\nvar fs = require('fs'),\n    xml2js = require('xml2js');\n\nvar parser = new xml2js.Parser();\nfs.readFile(__dirname + '/foo.xml', function(err, data) {\n    parser.parseString(data, function (err, result) {\n        console.dir(result);\n        console.log('Done');\n    });\n});\n```\n\nLook ma, no event listeners!\n\nYou can also use `xml2js` from\n[CoffeeScript](http://jashkenas.github.com/coffee-script/), further reducing\nthe clutter:\n\n```coffeescript\nfs = require 'fs',\nxml2js = require 'xml2js'\n\nparser = new xml2js.Parser()\nfs.readFile __dirname + '/foo.xml', (err, data) ->\n  parser.parseString data, (err, result) ->\n    console.dir result\n    console.log 'Done.'\n```\n\nBut what happens if you forget the `new` keyword to create a new `Parser`? In\nthe middle of a nightly coding session, it might get lost, after all. Worry\nnot, we got you covered! Starting with 0.2.8 you can also leave it out, in\nwhich case `xml2js` will helpfully add it for you, no bad surprises and\ninexplicable bugs!\n\n\"Traditional\" usage\n-------------------\n\nAlternatively you can still use the traditional `addListener` variant that was\nsupported since forever:\n\n```javascript\nvar fs = require('fs'),\n    xml2js = require('xml2js');\n\nvar parser = new xml2js.Parser();\nparser.addListener('end', function(result) {\n    console.dir(result);\n    console.log('Done.');\n});\nfs.readFile(__dirname + '/foo.xml', function(err, data) {\n    parser.parseString(data);\n});\n```\n\nIf you want to parse multiple files, you have multiple possibilites:\n\n  * You can create one `xml2js.Parser` per file. That's the recommended one\n    and is promised to always *just work*.\n  * You can call `reset()` on your parser object.\n  * You can hope everything goes well anyway. This behaviour is not\n    guaranteed work always, if ever. Use option #1 if possible. Thanks!\n\nSo you wanna some JSON?\n-----------------------\n\nJust wrap the `result` object in a call to `JSON.stringify` like this\n`JSON.stringify(result)`. You get a string containing the JSON representation\nof the parsed object that you can feed to JSON-hungry consumers.\n\nDisplaying results\n------------------\n\nYou might wonder why, using `console.dir` or `console.log` the output at some\nlevel is only `[Object]`. Don't worry, this is not because xml2js got lazy.\nThat's because Node uses `util.inspect` to convert the object into strings and\nthat function stops after `depth=2` which is a bit low for most XML.\n\nTo display the whole deal, you can use `console.log(util.inspect(result, false,\nnull))`, which displays the whole result.\n\nSo much for that, but what if you use\n[eyes](https://github.com/cloudhead/eyes.js) for nice colored output and it\ntruncates the output with `…`? Don't fear, there's also a solution for that,\nyou just need to increase the `maxLength` limit by creating a custom inspector\n`var inspect = require('eyes').inspector({maxLength: false})` and then you can\neasily `inspect(result)`.\n\nXML builder usage\n-----------------\n\nSince 0.4.0, objects can be also be used to build XML:\n\n```javascript\nvar fs = require('fs'),\n    xml2js = require('xml2js');\n\nvar obj = {name: \"Super\", Surname: \"Man\", age: 23};\n\nvar builder = new xml2js.Builder();\nvar xml = builder.buildObject(obj);\n```\n\nAt the moment, a one to one bi-directional conversion is guaranteed only for\ndefault configuration, except for `attrkey`, `charkey` and `explicitArray` options\nyou can redefine to your taste. Writing CDATA is not currently supported.\n\nOptions\n=======\n\nApart from the default settings, there are a number of options that can be\nspecified for the parser. Options are specified by ``new Parser({optionName:\nvalue})``. Possible options are:\n\n  * `attrkey` (default: `$`): Prefix that is used to access the attributes.\n    Version 0.1 default was `@`.\n  * `charkey` (default: `_`): Prefix that is used to access the character\n    content. Version 0.1 default was `#`.\n  * `explicitCharkey` (default: `false`)\n  * `trim` (default: `false`): Trim the whitespace at the beginning and end of\n    text nodes.\n  * `normalizeTags` (default: `false`): Normalize all tag names to lowercase.\n  * `normalize` (default: `false`): Trim whitespaces inside text nodes.\n  * `explicitRoot` (default: `true`): Set this if you want to get the root\n    node in the resulting object.\n  * `emptyTag` (default: `undefined`): what will the value of empty nodes be.\n    Default is `{}`.\n  * `explicitArray` (default: `true`): Always put child nodes in an array if\n    true; otherwise an array is created only if there is more than one.\n  * `ignoreAttrs` (default: `false`): Ignore all XML attributes and only create\n    text nodes.\n  * `mergeAttrs` (default: `false`): Merge attributes and child elements as\n    properties of the parent, instead of keying attributes off a child\n    attribute object. This option is ignored if `ignoreAttrs` is `false`.\n  * `validator` (default `null`): You can specify a callable that validates\n    the resulting structure somehow, however you want. See unit tests\n    for an example.\n  * `xmlns` (default `false`): Give each element a field usually called '$ns'\n    (the first character is the same as attrkey) that contains its local name\n    and namespace URI.\n  * `explicitChildren` (default `false`): Put child elements to separate\n    property. Doesn't work with `mergeAttrs = true`. If element has no children\n    then \"children\" won't be created. Added in 0.2.5.\n  * `childkey` (default `$$`): Prefix that is used to access child elements if\n    `explicitChildren` is set to `true`. Added in 0.2.5.\n  * `charsAsChildren` (default `false`): Determines whether chars should be\n    considered children if `explicitChildren` is on. Added in 0.2.5.\n  * `async` (default `false`): Should the callbacks be async? This *might* be\n    an incompatible change if your code depends on sync execution of callbacks.\n    xml2js 0.3 might change this default, so the recommendation is to not\n    depend on sync execution anyway. Added in 0.2.6.\n  * `strict` (default `true`): Set sax-js to strict or non-strict parsing mode.\n    Defaults to `true` which is *highly* recommended, since parsing HTML which\n    is not well-formed XML might yield just about anything. Added in 0.2.7.\n\nOptions for the `Builder` class\n-------------------------------\n\n  * `rootName` (default `root`): root element name to be used in case\n     `explicitiRoot` is `false` or to override the root element name.\n  * `renderOpts` (default `{ 'pretty': true, 'indent': '  ', 'newline': '\\n' }`):\n    Rendering options for xmlbuilder-js.\n    * pretty: prettify generated XML\n    * indent: whitespace for indentation (only when pretty)\n    * newline: newline char (only when pretty)\n  * `xmldec` (default `{ 'version': '1.0', 'encoding': 'UTF-8', 'standalone': true }`:\n    XML declaration attributes.\n    * `xmldec.version` A version number string, e.g. 1.0\n    * `xmldec.encoding` Encoding declaration, e.g. UTF-8\n    * `xmldec.standalone` standalone document declaration: true or false\n  * `doctype` (default `null`): optional DTD. Eg. `{'ext': 'hello.dtd'}`\n\nrenderOpts, xmldec and doctype pass through to [xmlbuilder-js](https://github.com/oozcitak/xmlbuilder-js)\n\nUpdating to new version\n=======================\n\nVersion 0.2 changed the default parsing settings, but version 0.1.14 introduced\nthe default settings for version 0.2, so these settings can be tried before the\nmigration.\n\n```javascript\nvar xml2js = require('xml2js');\nvar parser = new xml2js.Parser(xml2js.defaults[\"0.2\"]);\n```\n\nTo get the 0.1 defaults in version 0.2 you can just use\n`xml2js.defaults[\"0.1\"]` in the same place. This provides you with enough time\nto migrate to the saner way of parsing in xml2js 0.2. We try to make the\nmigration as simple and gentle as possible, but some breakage cannot be\navoided.\n\nSo, what exactly did change and why? In 0.2 we changed some defaults to parse\nthe XML in a more universal and sane way. So we disabled `normalize` and `trim`\nso xml2js does not cut out any text content. You can reenable this at will of\ncourse. A more important change is that we return the root tag in the resulting\nJavaScript structure via the `explicitRoot` setting, so you need to access the\nfirst element. This is useful for anybody who wants to know what the root node\nis and preserves more information. The last major change was to enable\n`explicitArray`, so everytime it is possible that one might embed more than one\nsub-tag into a tag, xml2js >= 0.2 returns an array even if the array just\nincludes one element. This is useful when dealing with APIs that return\nvariable amounts of subtags.\n\nRunning tests, development\n==========================\n\n[![Build Status](https://secure.travis-ci.org/Leonidas-from-XIV/node-xml2js.png?branch=master)](https://travis-ci.org/Leonidas-from-XIV/node-xml2js)\n[![Dependency Status](https://david-dm.org/Leonidas-from-XIV/node-xml2js.png)](https://david-dm.org/Leonidas-from-XIV/node-xml2js)\n\nThe development requirements are handled by npm, you just need to install them.\nWe also have a number of unit tests, they can be run using `npm test` directly\nfrom the project root. This runs zap to discover all the tests and execute\nthem.\n\nIf you like to contribute, keep in mind that xml2js is written in CoffeeScript,\nso don't develop on the JavaScript files that are checked into the repository\nfor convenience reasons. Also, please write some unit test to check your\nbehaviour and if it is some user-facing thing, add some documentation to this\nREADME, so people will know it exists. Thanks in advance!\n",
	  "readmeFilename": "README.md",
	  "bugs": {
	    "url": "https://github.com/Leonidas-from-XIV/node-xml2js/issues"
	  },
	  "_id": "xml2js@0.4.0",
	  "dist": {
	    "shasum": "ba86307638019b510c3d1e53f7986b233cb97e5b"
	  },
	  "_from": "xml2js@0.4.0",
	  "_resolved": "https://registry.npmjs.org/xml2js/-/xml2js-0.4.0.tgz"
	}
	
	}).call(this);
	

}, 'browser-http/lib/Extensions/Forms.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'browser-http/lib/Extensions/Forms.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'browser-http/lib/Extensions/Forms.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'browser-http/lib/Extensions/Forms.js';
	var __dirname = 'browser-http/lib/Extensions';
	var process = {cwd: function() {return '/';}, argv: ['node', 'browser-http/lib/Extensions/Forms.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var $, Forms, Http,
	    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
	
	  Http = require('../Http');
	
	  $ = null;
	
	  Forms = (function() {
	    function Forms(jQuery) {
	      this.onFormSubmitted = __bind(this.onFormSubmitted, this);
	      $ = jQuery;
	      $(document).on('submit', 'form.ajax:not(.not-ajax)', this.onFormSubmitted);
	      $(document).on('click', 'form.ajax:not(.not-ajax) :submit', this.onFormSubmitted);
	    }
	
	    Forms.prototype.onFormSubmitted = function(e) {
	      var el, form, i, name, options, sendValues, val, value, values, _i, _len;
	      e.preventDefault();
	      el = $(e.target);
	      sendValues = {};
	      if (el.is(':submit')) {
	        form = el.closest('form');
	        sendValues[el.attr('name')] = el.val() || '';
	      } else if (el.is('form')) {
	        form = el;
	      } else {
	        return null;
	      }
	      if (form.get(0).onsubmit && form.get(0).onsubmit() === false) {
	        return null;
	      }
	      values = form.serializeArray();
	      for (i = _i = 0, _len = values.length; _i < _len; i = ++_i) {
	        value = values[i];
	        name = value.name;
	        if (typeof sendValues[name] === 'undefined') {
	          sendValues[name] = value.value;
	        } else {
	          val = sendValues[name];
	          if (Object.prototype.toString.call(val) !== '[object Array]') {
	            val = [val];
	          }
	          val.push(value.value);
	          sendValues[name] = val;
	        }
	      }
	      options = {
	        data: sendValues,
	        type: form.attr('method') || 'GET'
	      };
	      return Http.request(form.attr('action'), options);
	    };
	
	    return Forms;
	
	  })();
	
	  module.exports = Forms;
	
	}).call(this);
	

}, 'browser-http/lib/Extensions/Links.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'browser-http/lib/Extensions/Links.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'browser-http/lib/Extensions/Links.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'browser-http/lib/Extensions/Links.js';
	var __dirname = 'browser-http/lib/Extensions';
	var process = {cwd: function() {return '/';}, argv: ['node', 'browser-http/lib/Extensions/Links.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var $, Http, Links;
	
	  Http = require('../Http');
	
	  $ = null;
	
	  Links = (function() {
	    function Links(jQuery) {
	      var historyApi;
	      $ = jQuery;
	      historyApi = false;
	      $(document).on('click', 'a.ajax:not(.not-ajax)', function(e) {
	        var a, link;
	        e.preventDefault();
	        a = e.target.nodeName.toLowerCase() === 'a' ? $(e.target) : $(e.target).closest('a');
	        link = a.attr('href');
	        if (historyApi) {
	          window.history.pushState({}, null, link);
	        }
	        return Http.get(link);
	      });
	    }
	
	    return Links;
	
	  })();
	
	  module.exports = Links;
	
	}).call(this);
	

}, 'browser-http/lib/Extensions/Loading.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'browser-http/lib/Extensions/Loading.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'browser-http/lib/Extensions/Loading.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'browser-http/lib/Extensions/Loading.js';
	var __dirname = 'browser-http/lib/Extensions';
	var process = {cwd: function() {return '/';}, argv: ['node', 'browser-http/lib/Extensions/Loading.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var Http, Loading,
	    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
	
	  Http = require('../Http');
	
	  Loading = (function() {
	    function Loading() {
	      this.onComplete = __bind(this.onComplete, this);
	      this.onSend = __bind(this.onSend, this);
	      Http.addExtension('loading', {
	        send: this.onSend,
	        complete: this.onComplete
	      });
	    }
	
	    Loading.prototype.onSend = function(response, request) {
	      return document.body.style.cursor = 'progress';
	    };
	
	    Loading.prototype.onComplete = function(response, request) {
	      return document.body.style.cursor = 'auto';
	    };
	
	    return Loading;
	
	  })();
	
	  module.exports = Loading;
	
	}).call(this);
	

}, 'browser-http/lib/Extensions/Redirect.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'browser-http/lib/Extensions/Redirect.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'browser-http/lib/Extensions/Redirect.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'browser-http/lib/Extensions/Redirect.js';
	var __dirname = 'browser-http/lib/Extensions';
	var process = {cwd: function() {return '/';}, argv: ['node', 'browser-http/lib/Extensions/Redirect.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var Http, Redirect;
	
	  Http = require('../Http');
	
	  Redirect = (function() {
	    function Redirect() {
	      Http.addExtension('redirect', {
	        success: this.onSuccess
	      });
	    }
	
	    Redirect.prototype.onSuccess = function(response, request) {
	      if (typeof response.data.redirect !== 'undefined') {
	        return window.location.href = response.data.redirect;
	      }
	    };
	
	    return Redirect;
	
	  })();
	
	  module.exports = Redirect;
	
	}).call(this);
	

}, 'browser-http/lib/Extensions/Snippets.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'browser-http/lib/Extensions/Snippets.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'browser-http/lib/Extensions/Snippets.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'browser-http/lib/Extensions/Snippets.js';
	var __dirname = 'browser-http/lib/Extensions';
	var process = {cwd: function() {return '/';}, argv: ['node', 'browser-http/lib/Extensions/Snippets.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var $, Http, Snippets,
	    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
	
	  Http = require('../Http');
	
	  $ = null;
	
	  Snippets = (function() {
	    function Snippets(jQuery) {
	      this.onSuccess = __bind(this.onSuccess, this);
	      $ = jQuery;
	      Http.addExtension('snippets', {
	        success: this.onSuccess
	      });
	    }
	
	    Snippets.prototype.onSuccess = function(response, request) {
	      var html, id, _ref, _results;
	      if (typeof response.data.snippets !== 'undefined') {
	        _ref = response.data.snippets;
	        _results = [];
	        for (id in _ref) {
	          html = _ref[id];
	          _results.push(this.updateSnippet(id, html));
	        }
	        return _results;
	      }
	    };
	
	    Snippets.prototype.updateSnippet = function(id, html) {
	      var el;
	      el = $("#" + id);
	      return el.html(html);
	    };
	
	    return Snippets;
	
	  })();
	
	  module.exports = Snippets;
	
	}).call(this);
	

}, 'browser-http/Mocks/Http.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'browser-http/Mocks/Http.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'browser-http/Mocks/Http.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'browser-http/Mocks/Http.js';
	var __dirname = 'browser-http/Mocks';
	var process = {cwd: function() {return '/';}, argv: ['node', 'browser-http/Mocks/Http.js'], env: {}};

	/** code **/
	module.exports = require('../lib/Mocks/Http');

}, 'browser-http/Mocks/Request.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'browser-http/Mocks/Request.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'browser-http/Mocks/Request.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'browser-http/Mocks/Request.js';
	var __dirname = 'browser-http/Mocks';
	var process = {cwd: function() {return '/';}, argv: ['node', 'browser-http/Mocks/Request.js'], env: {}};

	/** code **/
	module.exports = require('../lib/Mocks/Request');

}, 'browser-http/Mocks/Xhr.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'browser-http/Mocks/Xhr.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'browser-http/Mocks/Xhr.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'browser-http/Mocks/Xhr.js';
	var __dirname = 'browser-http/Mocks';
	var process = {cwd: function() {return '/';}, argv: ['node', 'browser-http/Mocks/Xhr.js'], env: {}};

	/** code **/
	module.exports = require('../lib/Mocks/Xhr');

}, 'events': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'events');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'events';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'events';
	var __dirname = '.';
	var process = {cwd: function() {return '/';}, argv: ['node', 'events'], env: {}};

	/** code **/
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var domain;
	
	exports.usingDomains = false;
	
	function EventEmitter() {
	  this.domain = null;
	  if (exports.usingDomains) {
	    // if there is an active domain, then attach to it.
	    domain = domain || require('domain');
	    if (domain.active && !(this instanceof domain.Domain)) {
	      this.domain = domain.active;
	    }
	  }
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || defaultMaxListeners;
	}
	exports.EventEmitter = EventEmitter;
	
	// By default EventEmitters will print a warning if more than
	// 10 listeners are added to it. This is a useful default which
	// helps finding memory leaks.
	//
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	var defaultMaxListeners = 10;
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (typeof n !== 'number' || n < 0)
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (typeof this._events.error === 'object' &&
	         !this._events.error.length)) {
	      er = arguments[1];
	      if (this.domain) {
	        if (!er) er = new TypeError('Uncaught, unspecified "error" event.');
	        er.domainEmitter = this;
	        er.domain = this.domain;
	        er.domainThrown = false;
	        this.domain.emit('error', er);
	      } else if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        throw TypeError('Uncaught, unspecified "error" event.');
	      }
	      return false;
	    }
	  }
	
	  handler = this._events[type];
	
	  if (typeof handler === 'undefined')
	    return false;
	
	  if (this.domain && this !== process)
	    this.domain.enter();
	
	  if (typeof handler === 'function') {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        len = arguments.length;
	        args = new Array(len - 1);
	        for (i = 1; i < len; i++)
	          args[i - 1] = arguments[i];
	        handler.apply(this, args);
	    }
	  } else if (typeof handler === 'object') {
	    len = arguments.length;
	    args = new Array(len - 1);
	    for (i = 1; i < len; i++)
	      args[i - 1] = arguments[i];
	
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  if (this.domain && this !== process)
	    this.domain.exit();
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (typeof listener !== 'function')
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type, typeof listener.listener === 'function' ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (typeof this._events[type] === 'object')
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (typeof this._events[type] === 'object' && !this._events[type].warned) {
	    m = this._maxListeners;
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      console.trace();
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (typeof listener !== 'function')
	    throw TypeError('listener must be a function');
	
	  function g() {
	    this.removeListener(type, g);
	    listener.apply(this, arguments);
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (typeof listener !== 'function')
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (typeof list.listener === 'function' && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (typeof list === 'object') {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (typeof listeners === 'function') {
	    this.removeListener(type, listeners);
	  } else {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (typeof this._events[type] === 'function')
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  var ret;
	  if (!emitter._events || !emitter._events[type])
	    ret = 0;
	  else if (typeof emitter._events[type] === 'function')
	    ret = 1;
	  else
	    ret = emitter._events[type].length;
	  return ret;
	};
	

}, '/package.json': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/package.json');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/package.json';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/package.json';
	var __dirname = '/';
	var process = {cwd: function() {return '/';}, argv: ['node', '/package.json'], env: {}};

	/** code **/
	module.exports = (function() {
	return {
		"name": "ares-data",
		"description": "Load information about employers from Czech ares service.",
		"version": "1.3.0",
		"author": {
			"name": "David Kudera",
			"email": "sakren@gmail.com"
		},
		"keywords": [
			"ares",
			"employer",
			"company",
			"czech"
		],
		"repository": {
			"type": "git",
			"url": "git@github.com:sakren/node-ares-data.git"
		},
		"license": "MIT",
		"engines": {
			"node": "*"
		},
		"main": "./lib/Ares.js",
		"dependencies": {
			"q": "0.9.7",
			"xml2js": "0.4.0",
			"moment": "2.4.0",
			"browser-http": "2.0.0"
		},
		"devDependencies": {
			"mocha": "1.15.1",
			"phantomjs": "1.9.2-5",
			"mocha-phantomjs": "3.1.6",
			"chai": "1.8.1"
		},
		"scripts": {
			"test": "npm run prepare-browser; npm run test-browser",
			"test-node": "mocha ./test/node/index.js --reporter spec --timeout 120000",
			"test-browser": "mocha-phantomjs -p ./node_modules/phantomjs/bin/phantomjs ./test/browser/index.html",
			"prepare-browser": "cd ./test/browser; simq build;"
		}
	}
	}).call(this);
	

}, 'moment/package.json': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'moment/package.json');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'moment/package.json';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'moment/package.json';
	var __dirname = 'moment';
	var process = {cwd: function() {return '/';}, argv: ['node', 'moment/package.json'], env: {}};

	/** code **/
	module.exports = (function() {
	return {
	  "name": "moment",
	  "version": "2.4.0",
	  "description": "Parse, manipulate, and display dates.",
	  "homepage": "http://momentjs.com",
	  "author": {
	    "name": "Iskren Ivov Chernev",
	    "email": "iskren.chernev@gmail.com",
	    "url": "https://github.com/ichernev"
	  },
	  "contributors": [
	    {
	      "name": "Tim Wood",
	      "email": "washwithcare@gmail.com",
	      "url": "http://timwoodcreates.com/"
	    },
	    {
	      "name": "Rocky Meza",
	      "url": "http://rockymeza.com"
	    },
	    {
	      "name": "Matt Johnson",
	      "email": "mj1856@hotmail.com",
	      "url": "http://codeofmatt.com"
	    },
	    {
	      "name": "Isaac Cambron",
	      "email": "isaac@isaaccambron.com",
	      "url": "http://drunkencoder.net/"
	    }
	  ],
	  "keywords": [
	    "moment",
	    "date",
	    "time",
	    "parse",
	    "format",
	    "validate",
	    "i18n",
	    "l10n",
	    "ender"
	  ],
	  "main": "./moment.js",
	  "engines": {
	    "node": "*"
	  },
	  "repository": {
	    "type": "git",
	    "url": "https://github.com/moment/moment.git"
	  },
	  "bugs": {
	    "url": "https://github.com/moment/moment/issues"
	  },
	  "licenses": [
	    {
	      "type": "MIT"
	    }
	  ],
	  "devDependencies": {
	    "uglify-js": "latest",
	    "grunt": "latest",
	    "nodeunit": "latest",
	    "grunt-contrib-jshint": "latest",
	    "grunt-contrib-nodeunit": "latest",
	    "grunt-contrib-concat": "latest",
	    "grunt-contrib-uglify": "latest",
	    "grunt-contrib-watch": "latest",
	    "grunt-lib-legacyhelpers": "latest"
	  },
	  "scripts": {
	    "test": "grunt"
	  },
	  "ender": "./ender.js",
	  "dojoBuild": "package.js",
	  "readme": "A lightweight javascript date library for parsing, validating, manipulating, and formatting dates.\n\n# [Documentation](http://momentjs.com/docs/)\n\nUpgrading to 2.0.0\n==================\n\nThere are a number of small backwards incompatible changes with version 2.0.0.\n\n[See them and their descriptions here](https://gist.github.com/timrwood/e72f2eef320ed9e37c51#backwards-incompatible-changes)\n\nChanged language ordinal method to return the number + ordinal instead of just the ordinal.\n\nChanged two digit year parsing cutoff to match strptime.\n\nRemoved `moment#sod` and `moment#eod` in favor of `moment#startOf` and `moment#endOf`.\n\nRemoved `moment.humanizeDuration()` in favor of `moment.duration().humanize()`.\n\nRemoved the lang data objects from the top level namespace.\n\nDuplicate `Date` passed to `moment()` instead of referencing it.\n\nTravis Build Status\n===================\n\nDevelop [![Build Status](https://travis-ci.org/moment/moment.png?branch=develop)](https://travis-ci.org/moment/moment)\n\nMaster [![Build Status](https://travis-ci.org/moment/moment.png?branch=master)](https://travis-ci.org/moment/moment)\n\nChangelog\n=========\n\n### 2.4.0\n\n* **Deprecate** globally exported moment, will be removed in next major\n* New languages\n  * Farose (fo) [#1206](https://github.com/moment/moment/issues/1206)\n  * Tagalog/Filipino (tl-ph) [#1197](https://github.com/moment/moment/issues/1197)\n  * Welsh (cy) [#1214](https://github.com/moment/moment/issues/1214)\n* Bugfixes\n  * properly handle Z at the end of iso RegExp [#1187](https://github.com/moment/moment/issues/1187)\n  * chinese meridian time improvements [#1076](https://github.com/moment/moment/issues/1076)\n  * fix language tests [#1177](https://github.com/moment/moment/issues/1177)\n  * remove some failing tests (that should have never existed :))\n    [#1185](https://github.com/moment/moment/issues/#1185)\n    [#1183](https://github.com/moment/moment/issues/1183)\n  * handle russian noun cases in weird cases [#1195](https://github.com/moment/moment/issues/1195]\n\n### 2.3.1\n\nRemoved a trailing comma [1169] and fixed a bug with `months`, `weekdays` getters [1171].\n\n### 2.3.0 [See changelog](https://gist.github.com/ichernev/6864354)\n\nChanged isValid, added strict parsing.\nWeek tokens parsing.\n\n### 2.2.1\n\nFixed bug in string prototype test.\nUpdated authors and contributors.\n\n### 2.2.0 [See changelog](https://gist.github.com/ichernev/00f837a9baf46a3565e4)\n\nAdded bower support.\n\nLanguage files now use UMD.\n\nCreating moment defaults to current date/month/year.\n\nAdded a bundle of moment and all language files.\n\n### 2.1.0 [See changelog](https://gist.github.com/timrwood/b8c2d90d528eddb53ab5)\n\nAdded better week support.\n\nAdded ability to set offset with `moment#zone`.\n\nAdded ability to set month or weekday from a string.\n\nAdded `moment#min` and `moment#max`\n\n### 2.0.0 [See changelog](https://gist.github.com/timrwood/e72f2eef320ed9e37c51)\n\nAdded short form localized tokens.\n\nAdded ability to define language a string should be parsed in.\n\nAdded support for reversed add/subtract arguments.\n\nAdded support for `endOf('week')` and `startOf('week')`.\n\nFixed the logic for `moment#diff(Moment, 'months')` and `moment#diff(Moment, 'years')`\n\n`moment#diff` now floors instead of rounds.\n\nNormalized `moment#toString`.\n\nAdded `isSame`, `isAfter`, and `isBefore` methods.\n\nAdded better week support.\n\nAdded `moment#toJSON`\n\nBugfix: Fixed parsing of first century dates\n\nBugfix: Parsing 10Sep2001 should work as expected\n\nBugfix: Fixed wierdness with `moment.utc()` parsing.\n\nChanged language ordinal method to return the number + ordinal instead of just the ordinal.\n\nChanged two digit year parsing cutoff to match strptime.\n\nRemoved `moment#sod` and `moment#eod` in favor of `moment#startOf` and `moment#endOf`.\n\nRemoved `moment.humanizeDuration()` in favor of `moment.duration().humanize()`.\n\nRemoved the lang data objects from the top level namespace.\n\nDuplicate `Date` passed to `moment()` instead of referencing it.\n\n### 1.7.2 [See discussion](https://github.com/timrwood/moment/issues/456)\n\nBugfixes\n\n### 1.7.1 [See discussion](https://github.com/timrwood/moment/issues/384)\n\nBugfixes\n\n### 1.7.0 [See discussion](https://github.com/timrwood/moment/issues/288)\n\nAdded `moment.fn.endOf()` and `moment.fn.startOf()`.\n\nAdded validation via `moment.fn.isValid()`.\n\nMade formatting method 3x faster. http://jsperf.com/momentjs-cached-format-functions\n\nAdd support for month/weekday callbacks in `moment.fn.format()`\n\nAdded instance specific languages.\n\nAdded two letter weekday abbreviations with the formatting token `dd`.\n\nVarious language updates.\n\nVarious bugfixes.\n\n### 1.6.0 [See discussion](https://github.com/timrwood/moment/pull/268)\n\nAdded Durations.\n\nRevamped parser to support parsing non-separated strings (YYYYMMDD vs YYYY-MM-DD).\n\nAdded support for millisecond parsing and formatting tokens (S SS SSS)\n\nAdded a getter for `moment.lang()`\n\nVarious bugfixes.\n\nThere are a few things deprecated in the 1.6.0 release.\n\n1. The format tokens `z` and `zz` (timezone abbreviations like EST CST MST etc) will no longer be supported. Due to inconsistent browser support, we are unable to consistently produce this value. See [this issue](https://github.com/timrwood/moment/issues/162) for more background.\n\n2. The method `moment.fn.native` is deprecated in favor of `moment.fn.toDate`. There continue to be issues with Google Closure Compiler throwing errors when using `native`, even in valid instances.\n\n3. The way to customize am/pm strings is being changed. This would only affect you if you created a custom language file. For more information, see [this issue](https://github.com/timrwood/moment/pull/222).\n\n### 1.5.0 [See milestone](https://github.com/timrwood/moment/issues?milestone=10&page=1&state=closed)\n\nAdded UTC mode.\n\nAdded automatic ISO8601 parsing.\n\nVarious bugfixes.\n\n### 1.4.0 [See milestone](https://github.com/timrwood/moment/issues?milestone=8&state=closed)\n\nAdded `moment.fn.toDate` as a replacement for `moment.fn.native`.\n\nAdded `moment.fn.sod` and `moment.fn.eod` to get the start and end of day.\n\nVarious bugfixes.\n\n### 1.3.0 [See milestone](https://github.com/timrwood/moment/issues?milestone=7&state=closed)\n\nAdded support for parsing month names in the current language.\n\nAdded escape blocks for parsing tokens.\n\nAdded `moment.fn.calendar` to format strings like 'Today 2:30 PM', 'Tomorrow 1:25 AM', and 'Last Sunday 4:30 AM'.\n\nAdded `moment.fn.day` as a setter.\n\nVarious bugfixes\n\n### 1.2.0 [See milestone](https://github.com/timrwood/moment/issues?milestone=4&state=closed)\n\nAdded timezones to parser and formatter.\n\nAdded `moment.fn.isDST`.\n\nAdded `moment.fn.zone` to get the timezone offset in minutes.\n\n### 1.1.2 [See milestone](https://github.com/timrwood/moment/issues?milestone=6&state=closed)\n\nVarious bugfixes\n\n### 1.1.1 [See milestone](https://github.com/timrwood/moment/issues?milestone=5&state=closed)\n\nAdded time specific diffs (months, days, hours, etc)\n\n### 1.1.0\n\nAdded `moment.fn.format` localized masks. 'L LL LLL LLLL' [issue 29](https://github.com/timrwood/moment/pull/29)\n\nFixed [issue 31](https://github.com/timrwood/moment/pull/31).\n\n### 1.0.1\n\nAdded `moment.version` to get the current version.\n\nRemoved `window !== undefined` when checking if module exists to support browserify. [issue 25](https://github.com/timrwood/moment/pull/25)\n\n### 1.0.0\n\nAdded convenience methods for getting and setting date parts.\n\nAdded better support for `moment.add()`.\n\nAdded better lang support in NodeJS.\n\nRenamed library from underscore.date to Moment.js\n\n### 0.6.1\n\nAdded Portuguese, Italian, and French language support\n\n### 0.6.0\n\nAdded _date.lang() support.\nAdded support for passing multiple formats to try to parse a date. _date(\"07-10-1986\", [\"MM-DD-YYYY\", \"YYYY-MM-DD\"]);\nMade parse from string and single format 25% faster.\n\n### 0.5.2\n\nBugfix for [issue 8](https://github.com/timrwood/underscore.date/pull/8) and [issue 9](https://github.com/timrwood/underscore.date/pull/9).\n\n### 0.5.1\n\nBugfix for [issue 5](https://github.com/timrwood/underscore.date/pull/5).\n\n### 0.5.0\n\nDropped the redundant `_date.date()` in favor of `_date()`.\nRemoved `_date.now()`, as it is a duplicate of `_date()` with no parameters.\nRemoved `_date.isLeapYear(yearNumber)`. Use `_date([yearNumber]).isLeapYear()` instead.\nExposed customization options through the `_date.relativeTime`, `_date.weekdays`, `_date.weekdaysShort`, `_date.months`, `_date.monthsShort`, and `_date.ordinal` variables instead of the `_date.customize()` function.\n\n### 0.4.1\n\nAdded date input formats for input strings.\n\n### 0.4.0\n\nAdded underscore.date to npm. Removed dependencies on underscore.\n\n### 0.3.2\n\nAdded `'z'` and `'zz'` to `_.date().format()`. Cleaned up some redundant code to trim off some bytes.\n\n### 0.3.1\n\nCleaned up the namespace. Moved all date manipulation and display functions to the _.date() object.\n\n### 0.3.0\n\nSwitched to the Underscore methodology of not mucking with the native objects' prototypes.\nMade chaining possible.\n\n### 0.2.1\n\nChanged date names to be a more pseudo standardized 'dddd, MMMM Do YYYY, h:mm:ss a'.\nAdded `Date.prototype` functions `add`, `subtract`, `isdst`, and `isleapyear`.\n\n### 0.2.0\n\nChanged function names to be more concise.\nChanged date format from php date format to custom format.\n\n### 0.1.0\n\nInitial release\n\nLicense\n=======\n\nMoment.js is freely distributable under the terms of the MIT license.\n",
	  "readmeFilename": "readme.md",
	  "_id": "moment@2.4.0",
	  "dist": {
	    "shasum": "aff644965e7275488b4217db6d02c8b45b36b0ad"
	  },
	  "_from": "moment@2.4.0",
	  "_resolved": "https://registry.npmjs.org/moment/-/moment-2.4.0.tgz"
	}
	
	}).call(this);
	

}, 'browser-http/package.json': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'browser-http/package.json');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'browser-http/package.json';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'browser-http/package.json';
	var __dirname = 'browser-http';
	var process = {cwd: function() {return '/';}, argv: ['node', 'browser-http/package.json'], env: {}};

	/** code **/
	module.exports = (function() {
	return {
	  "name": "browser-http",
	  "description": "Simple HTTP for browser",
	  "version": "2.0.0",
	  "author": {
	    "name": "David Kudera",
	    "email": "sakren@gmail.com"
	  },
	  "repository": {
	    "type": "git",
	    "url": "git@github.com:sakren/node-browser-http.git"
	  },
	  "license": "MIT",
	  "keywords": [
	    "http",
	    "client",
	    "browser",
	    "ajax",
	    "url"
	  ],
	  "engines": {
	    "node": ">=0.9"
	  },
	  "main": "./lib/Http.js",
	  "dependencies": {
	    "q": "0.9.7"
	  },
	  "devDependencies": {
	    "mocha": "1.15.1",
	    "mocha-phantomjs": "3.1.6",
	    "phantomjs": "1.9.2-5",
	    "chai": "1.8.1"
	  },
	  "scripts": {
	    "test": "mocha-phantomjs -p ./node_modules/phantomjs/bin/phantomjs ./test/index.html",
	    "prepare-browser": "cd test; simq build;"
	  },
	  "readme": "[![NPM version](https://badge.fury.io/js/browser-http.png)](http://badge.fury.io/js/browser-http)\n[![Dependency Status](https://gemnasium.com/sakren/node-browser-http.png)](https://gemnasium.com/sakren/node-browser-http)\n[![Build Status](https://travis-ci.org/sakren/node-browser-http.png?branch=master)](https://travis-ci.org/sakren/node-browser-http)\n\n# http-browser\n\nSome simple classes for working with http in browser (for example with [simq](https://npmjs.org/package/simq)).\n\nNow it is really simple and more functions will be added.\n\nhttp-browser uses [q](https://npmjs.org/package/q) promise pattern and is instance of [EventEmitter](http://nodejs.org/api/events.html).\n\n## Installation\n\n```\n$ npm install browser-http\n```\n\n## Usage\n\n```\nvar http = require('browser-http');\n\nhttp.request('http://www.google.com', {type: 'GET'}).then(function(response) {\n\tconsole.log(response.text);\n}, function(e) {\n\tthrow e;\t\t// some error occurred\n});\n```\n\nIn then function, you will get response object with data from server.\n\n## Shorthands\n\n```\nvar http = require('browser-http');\n\nhttp.get('http://www.google.com');\nhttp.post('http://www.google.com');\nhttp.put('http://www.google.com');\nhttp.delete('http://www.google.com');\n```\n\n## Options\n\nIn every http function, you can set other options. Now it is just type and data.\n\n* type: GET, POST, PUT or DELETE\n* data: literal object of data which needs to be send to server\n\n## Response object\n\nBasically it is just wrapper for some data from XMLHttpRequest.\n\n* state\n* status\n* statusText\n* rawData: same like responseText\n* data: same like responseText or literal object (json)\n* xml: same like responseXML\n\n## Load JSON\n\nIf content-type in response header is `application/json` then your data will be automatically transformed into js object.\n\nIf you can not set this header on your server, than you can use `*Json` methods.\n\n```\nhttp.getJson('http://www.google.com/some.json').then(function(response) {\n\tconsole.log(response.data);\t\t// output will be object\n});\n\nhttp.postJson('http://www.google.com/some.json');\n```\n\n## Requests queue\n\nBy default all your requests are called from queue one by one, so there is always just one request running (or zero).\nInspiration from this article [http://blog.alexmaccaw.com/queuing-ajax-requests](http://blog.alexmaccaw.com/queuing-ajax-requests).\n\nYou can of course disable this behavior:\n```\nhttp.useQueue = false;\n```\n\n## JSONP\n\nIt is very easy to work with jsonp requests.\n\n```\nhttp.jsonp('http://some.url.com').then(function(response) {\n\tconsole.log(response.data);\n});\n```\n\n## Events\n\nYou can listen for all http events with your own functions.\n\n```\nhttp.on('send', function(response, request) {\n\tconsole.log('In any moment, new http request will be send to server');\n});\n\nhttp.on('complete', function(response, request) {\n\tconsole.log('I just finished some request, but there may be some errors');\n});\n\nhttp.on('success', function(response, request) {\n\tconsole.log('I have got response from server without any error :-)');\n});\n\nhttp.on('error', function(err, response, request) {\n\tconsole.log('Sorry, there was some error with this response');\n});\n```\n\n## Extensions\n\nSometimes it will be better to register whole group of events and this group is called extension.\n\n```\nhttp.addExtension('nameOfMyExtension', {\n\tsend: function(response, request) {},\n\tcomplete: function(response, request) {},\n\tsuccess: function(response, request) {},\n\terror: function(err, response, request) {},\n});\n```\n\nYou can also remove other extensions.\n\n```\nhttp.removeExtension('nameOfMyExtension');\n```\n\n### Build in extensions\n\nbrowser-http already comes with few extensions. Originally they were created for projects build on [Nette](http://nette.org/en/)\nframework, but can be used on any other project.\n\n#### Loading cursor\n\n```\nnew (require('browser-http/Extensions/Loading'));\n```\n\nEvery time new request is send, your cursor is changed into `progress` cursor. After receiving response from server, cursor\nis changed into `auto`.\n\n#### Redirect\n\n```\nnew (require('browser-http/Extensions/Redirect'));\n```\n\nIf your server sends json data with `redirect` variable, then you will be redirected to address in this variable.\n\n#### Snippets\n\n```\nvar Snippets = require('browser-http/Extensions/Snippets');\nnew Snippets(window.jQuery);\n```\n\nIf in response data is `snippets` object with html id and content pairs, then browser-http will iterate throw this object,\nfind element in page with given id and change content of this element into the one from given data.\n\nThis extension depends on jquery.\n\n#### Ajax links\n\n```\nvar Links = require('browser-http/Extensions/Links');\nnew Links(window.jQuery);\n```\n\nThis is not true extension for browser-http. It listen for all click events on `a` links with class `ajax` but not with\nclass `not-ajax` and after this click, it creates ajax request.\n\nDepends on jquery.\n\n#### Ajax forms\n\nThis is the same like the previous one, but apply for all forms with `ajax` class.\nThis extension can not handle forms with file uploads.\nDepends on jquery.\n\n```\nvar Forms = require('browser-http/Extensions/Forms');\nnew Forms(window.jQuery);\n```\n\n## Tests\n\n```\n$ npm test\n```\n\n### Own tests\n\n```\nvar http = require('browser-http/Mocks/Http');\n\nafterEach(function() {\n\thttp.restore();\n});\n\nit('should load some data', function(done) {\n\thttp.receive('some data', {'content-type': 'text/plain'}, 200);\n\n\thttp.get('localhost').then(function(response) {\n\t\texpect(response.data).to.be.equal('some data');\n\t\tdone();\n\t});\n});\n\n// text/plain in headers list is default content-type, so you don't have to set it. Also status 200 is default.\n\nit('should load some data and check received data', function(done) {\n\thttp.receive('some data', {'content-type': 'application/json'});\n\n\thttp.once('send', function(response, request) {\n\t\texpect(request.xhr.url).to.be.equal('localhost?greeting=hello')\t\t\t// now we can test eg. url with parsed data\n\t});\n\n\thttp.get('localhost', {data: {greeting: 'hello'}}).then(function(response) {\n\t\texpect(response.data).to.be.eql({greeting: 'hello'});\n\t\tdone()\n\t});\n});\n```\n\n## Changelog\n\n* 2.0.0\n\t+ jQuery must be passed in constructor into extensions which depends on it\n\t+ Updated dependencies\n\t+ Test frameworks are in devDependencies (not globally installed)\n\t+ Large refactoring (better for testing)\n\t+ Tests does not need real server (using mock from [philikon/MockHttpRequest](https://github.com/philikon/MockHttpRequest))\n\t+ Many optimizations\n\t+ Added some badges + travis\n\n* 1.8.0\n\t+ Requests are added into queue\n\t+ Added support for jsonp\n\n* 1.7.1\n\t+ Added some tests\n\t+ Bug with responses without content-type header\n\n* 1.7.0\n\t+ Refactoring\n\t+ `buildQuery` and `urlencode` moved to `browser-http/Helpers`\n\t+ Instance of EventEmitter\n\n* 1.6.4\n\t+ Optimizations + bug with sending data\n\n* 1.6.3\n\t+ Bug with `buildQuery` - replaced with the real one from jQuery\n\n* 1.6.2\n\t+ Just removed some useless code\n\n* 1.6.1\n\t+ Forgot to add Extensions/Links shortcut\n\n* 1.6.0\n\t+ `buildQuery` should got the same output like jQuery.param\n\t+ Added some extensions\n\n* 1.5.2\n\t+ Bug with sending data via POST method\n\n* 1.5.1\n\t+ Bug with X-Requested-With header\n\n* 1.5.0\n\t+ Added method isHistoryApiSupported\n\n* 1.4.0\n\t+ Sending X-Requested-With header\n\n* 1.3.1 - 1.3.5\n\t+ Bugs\n\n* 1.3.0\n\t+ Added `urlencode` and `buildQuery` methods\n\t+ Prepared changelog\n\t+ Added some tests\n\t+ Some bugs and optimizations\n\t+ Transforming response data into json if mime type is application/json",
	  "readmeFilename": "README.md",
	  "bugs": {
	    "url": "https://github.com/sakren/node-browser-http/issues"
	  },
	  "homepage": "https://github.com/sakren/node-browser-http",
	  "_id": "browser-http@2.0.0",
	  "dist": {
	    "shasum": "ade0ad473b4eeec2d37a928ab3666679228e3f0c"
	  },
	  "_from": "browser-http@2.0.0",
	  "_resolved": "https://registry.npmjs.org/browser-http/-/browser-http-2.0.0.tgz"
	}
	
	}).call(this);
	

}, 'ares-data': function(exports, module) { module.exports = window.require('/lib/Ares'); }
, 'ares-data/Validators': function(exports, module) { module.exports = window.require('/lib/Validators'); }
, 'q': function(exports, module) { module.exports = window.require('q/q.js'); }
, 'xml2js': function(exports, module) { module.exports = window.require('xml2js/lib/xml2js.js'); }
, 'sax': function(exports, module) { module.exports = window.require('sax/lib/sax.js'); }
, 'xmlbuilder': function(exports, module) { module.exports = window.require('xmlbuilder/lib/index.js'); }
, 'underscore': function(exports, module) { module.exports = window.require('underscore/underscore.js'); }
, 'moment': function(exports, module) { module.exports = window.require('moment/moment.js'); }
, 'browser-http': function(exports, module) { module.exports = window.require('browser-http/lib/Http.js'); }

});
require.__setStats({"/lib/Validators.js":{"atime":1386520527000,"mtime":1386520524000,"ctime":1386520524000},"q/q.js":{"atime":1386520665000,"mtime":1378314231000,"ctime":1385674058000},"xml2js/lib/xml2js.js":{"atime":1386529645000,"mtime":1386529549000,"ctime":1386529549000},"sax/lib/sax.js":{"atime":1386520665000,"mtime":1377100127000,"ctime":1385675518000},"xmlbuilder/lib/index.js":{"atime":1386520665000,"mtime":1385545552000,"ctime":1385675518000},"xmlbuilder/lib/XMLBuilder.js":{"atime":1386520665000,"mtime":1385545552000,"ctime":1385675518000},"underscore/underscore.js":{"atime":1386520665000,"mtime":1378558789000,"ctime":1385675521000},"xmlbuilder/lib/XMLFragment.js":{"atime":1386520665000,"mtime":1385545552000,"ctime":1385675518000},"xmlbuilder/lib/XMLStringifier.js":{"atime":1386520665000,"mtime":1385545552000,"ctime":1385675518000},"xml2js/lib/bom.js":{"atime":1386534008000,"mtime":1386529807000,"ctime":1386529807000},"moment/moment.js":{"atime":1386520665000,"mtime":1382840735000,"ctime":1385675364000},"browser-http/Helpers.js":{"atime":1386520665000,"mtime":1386498223000,"ctime":1386520573000},"browser-http/lib/Helpers.js":{"atime":1386520665000,"mtime":1386498372000,"ctime":1386520573000},"browser-http/lib/Http.js":{"atime":1386520575000,"mtime":1386518765000,"ctime":1386520573000},"browser-http/lib/Request.js":{"atime":1386520575000,"mtime":1386518451000,"ctime":1386520573000},"browser-http/lib/Xhr.js":{"atime":1386520575000,"mtime":1386518401000,"ctime":1386520573000},"browser-http/lib/Response.js":{"atime":1386520575000,"mtime":1386498372000,"ctime":1386520573000},"browser-http/lib/Queue.js":{"atime":1386520575000,"mtime":1386498372000,"ctime":1386520573000},"browser-http/lib/Mocks/Request.js":{"atime":1386520575000,"mtime":1386509567000,"ctime":1386520573000},"browser-http/lib/Mocks/Xhr.js":{"atime":1386520575000,"mtime":1386517288000,"ctime":1386520573000},"browser-http/Mocks/XmlHttpRequest.js":{"atime":1386520575000,"mtime":1386518844000,"ctime":1386520574000},"browser-http/lib/Mocks/Http.js":{"atime":1386520575000,"mtime":1386515114000,"ctime":1386520573000},"/lib/Ares.js":{"atime":1386535985000,"mtime":1386535964000,"ctime":1386535964000},"/test/browser/tests/Ares.coffee":{"atime":1386536299000,"mtime":1386536288000,"ctime":1386536288000},"/test/browser/tests/Validators.coffee":{"atime":1386520844000,"mtime":1385674038000,"ctime":1386520843000},"/test/responses/companies.coffee":{"atime":1386535590000,"mtime":1386535590000,"ctime":1386535590000},"/test/responses/employer.coffee":{"atime":1386535079000,"mtime":1386535078000,"ctime":1386535078000},"/test/responses/limitError.coffee":{"atime":1386535868000,"mtime":1386535867000,"ctime":1386535867000},"moment/lang/en-gb.js":{"atime":1386520886000,"mtime":1381735465000,"ctime":1385675364000},"q/benchmark/compare-with-callbacks.js":{"atime":1386520886000,"mtime":1377038829000,"ctime":1385674058000},"q/benchmark/scenarios.js":{"atime":1386520886000,"mtime":1377038829000,"ctime":1385674058000},"q/package.json":{"atime":1386520569000,"mtime":1385674058000,"ctime":1385674058000},"q/queue.js":{"atime":1386520886000,"mtime":1377499944000,"ctime":1385674058000},"sax/component.json":{"atime":1386520888000,"mtime":1365268143000,"ctime":1385675518000},"sax/examples/example.js":{"atime":1386520886000,"mtime":1357492957000,"ctime":1385675518000},"sax/examples/get-products.js":{"atime":1386520886000,"mtime":1320543013000,"ctime":1385675518000},"sax/examples/hello-world.js":{"atime":1386520886000,"mtime":1320543013000,"ctime":1385675518000},"sax/examples/pretty-print.js":{"atime":1386520886000,"mtime":1319428513000,"ctime":1385675518000},"sax/package.json":{"atime":1386520574000,"mtime":1385675518000,"ctime":1385675518000},"sax/test/attribute-name.js":{"atime":1386520886000,"mtime":1366665960000,"ctime":1385675518000},"sax/test/buffer-overrun.js":{"atime":1386520886000,"mtime":1357497822000,"ctime":1385675518000},"sax/test/case.js":{"atime":1386520886000,"mtime":1357497822000,"ctime":1385675518000},"sax/test/cdata-chunked.js":{"atime":1386520886000,"mtime":1357497822000,"ctime":1385675518000},"sax/test/cdata-end-split.js":{"atime":1386520886000,"mtime":1357497822000,"ctime":1385675518000},"sax/test/cdata-fake-end.js":{"atime":1386520886000,"mtime":1357497822000,"ctime":1385675518000},"sax/test/cdata-multiple.js":{"atime":1386520886000,"mtime":1357497822000,"ctime":1385675518000},"sax/test/cdata.js":{"atime":1386520886000,"mtime":1357497822000,"ctime":1385675518000},"sax/test/cyrillic.js":{"atime":1386520886000,"mtime":1357498148000,"ctime":1385675518000},"sax/test/duplicate-attribute.js":{"atime":1386520886000,"mtime":1357498138000,"ctime":1385675518000},"sax/test/entities.js":{"atime":1386520886000,"mtime":1357498124000,"ctime":1385675518000},"sax/test/entity-mega.js":{"atime":1386520886000,"mtime":1357498115000,"ctime":1385675518000},"sax/test/index.js":{"atime":1386520886000,"mtime":1324057127000,"ctime":1385675518000},"sax/test/issue-23.js":{"atime":1386520886000,"mtime":1357497822000,"ctime":1385675518000},"sax/test/issue-30.js":{"atime":1386520886000,"mtime":1357497822000,"ctime":1385675518000},"sax/test/issue-35.js":{"atime":1386520886000,"mtime":1357497822000,"ctime":1385675518000},"sax/test/issue-47.js":{"atime":1386520886000,"mtime":1357593113000,"ctime":1385675518000},"sax/test/issue-49.js":{"atime":1386520886000,"mtime":1357497822000,"ctime":1385675518000},"sax/test/issue-84.js":{"atime":1386520886000,"mtime":1357498101000,"ctime":1385675518000},"sax/test/parser-position.js":{"atime":1386520886000,"mtime":1316220482000,"ctime":1385675518000},"sax/test/script-close-better.js":{"atime":1386520886000,"mtime":1357498085000,"ctime":1385675518000},"sax/test/script.js":{"atime":1386520886000,"mtime":1357497822000,"ctime":1385675518000},"sax/test/self-closing-child-strict.js":{"atime":1386520886000,"mtime":1357497857000,"ctime":1385675518000},"sax/test/self-closing-child.js":{"atime":1386520886000,"mtime":1357497822000,"ctime":1385675518000},"sax/test/self-closing-tag.js":{"atime":1386520886000,"mtime":1357497822000,"ctime":1385675518000},"sax/test/stray-ending.js":{"atime":1386520886000,"mtime":1357497822000,"ctime":1385675518000},"sax/test/trailing-attribute-no-value.js":{"atime":1386520886000,"mtime":1357498062000,"ctime":1385675518000},"sax/test/trailing-non-whitespace.js":{"atime":1386520886000,"mtime":1357497822000,"ctime":1385675518000},"sax/test/unclosed-root.js":{"atime":1386520886000,"mtime":1357498036000,"ctime":1385675518000},"sax/test/unquoted.js":{"atime":1386520886000,"mtime":1357497822000,"ctime":1385675518000},"sax/test/utf8-split.js":{"atime":1386520886000,"mtime":1377100256000,"ctime":1385675518000},"sax/test/xmlns-issue-41.js":{"atime":1386520886000,"mtime":1357497822000,"ctime":1385675518000},"sax/test/xmlns-rebinding.js":{"atime":1386520886000,"mtime":1357497822000,"ctime":1385675518000},"sax/test/xmlns-strict.js":{"atime":1386520886000,"mtime":1357497955000,"ctime":1385675518000},"sax/test/xmlns-unbound-element.js":{"atime":1386520886000,"mtime":1366931421000,"ctime":1385675518000},"sax/test/xmlns-unbound.js":{"atime":1386520886000,"mtime":1357497822000,"ctime":1385675518000},"sax/test/xmlns-xml-default-ns.js":{"atime":1386520886000,"mtime":1357497822000,"ctime":1385675518000},"sax/test/xmlns-xml-default-prefix-attribute.js":{"atime":1386520886000,"mtime":1357497822000,"ctime":1385675518000},"sax/test/xmlns-xml-default-prefix.js":{"atime":1386520886000,"mtime":1357497822000,"ctime":1385675518000},"sax/test/xmlns-xml-default-redefine.js":{"atime":1386520886000,"mtime":1357497822000,"ctime":1385675518000},"underscore/package.json":{"atime":1386520574000,"mtime":1385675521000,"ctime":1385675521000},"underscore/underscore-min.js":{"atime":1386520886000,"mtime":1378558789000,"ctime":1385675521000},"xmlbuilder/package.json":{"atime":1386520574000,"mtime":1385675518000,"ctime":1385675518000},"xml2js/package.json":{"atime":1386520510000,"mtime":1385675516000,"ctime":1385675516000},"browser-http/lib/Extensions/Forms.js":{"atime":1386520886000,"mtime":1386498894000,"ctime":1386520573000},"browser-http/lib/Extensions/Links.js":{"atime":1386520886000,"mtime":1386498867000,"ctime":1386520573000},"browser-http/lib/Extensions/Loading.js":{"atime":1386520886000,"mtime":1386498372000,"ctime":1386520573000},"browser-http/lib/Extensions/Redirect.js":{"atime":1386520886000,"mtime":1386498372000,"ctime":1386520573000},"browser-http/lib/Extensions/Snippets.js":{"atime":1386520886000,"mtime":1386498898000,"ctime":1386520573000},"browser-http/Mocks/Http.js":{"atime":1386520575000,"mtime":1386508351000,"ctime":1386520573000},"browser-http/Mocks/Request.js":{"atime":1386520575000,"mtime":1386508363000,"ctime":1386520574000},"browser-http/Mocks/Xhr.js":{"atime":1386520575000,"mtime":1386508374000,"ctime":1386520574000},"events":{"atime":1386503870000,"mtime":1384294623000,"ctime":1385364984000},"/package.json":{"atime":1386536297000,"mtime":1386536293000,"ctime":1386536293000},"moment/package.json":{"atime":1386520569000,"mtime":1385675364000,"ctime":1385675364000},"browser-http/package.json":{"atime":1386520575000,"mtime":1386520574000,"ctime":1386520574000}});
require.version = '5.5.1';

/** run section **/

/** /test/browser/tests/Validators **/
require('/test/browser/tests/Validators');

/** /test/browser/tests/Ares **/
require('/test/browser/tests/Ares');